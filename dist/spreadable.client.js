/*!
 * spreadable client
 * @version 0.0.19
 * {@link https://github.com/ortexx/spreadable}
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ClientSpreadable"] = factory();
	else
		root["ClientSpreadable"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/browser/client/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/assert-plus/assert.js":
/*!********************************************!*\
  !*** ./node_modules/assert-plus/assert.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer, process) {

var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2012, Mark Cavage. All rights reserved.
// Copyright 2015 Joyent, Inc.

var assert = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");
var Stream = __webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js").Stream;
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

///--- Globals

/* JSSTYLED */
var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;

///--- Internal

function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

function _toss(name, expected, oper, arg, actual) {
    throw new assert.AssertionError({
        message: util.format('%s (%s) is required', name, expected),
        actual: actual === undefined ? typeof arg === 'undefined' ? 'undefined' : (0, _typeof3.default)(arg) : actual(arg),
        expected: expected,
        operator: oper || '===',
        stackStartFunction: _toss.caller
    });
}

function _getClass(arg) {
    return Object.prototype.toString.call(arg).slice(8, -1);
}

function noop() {}
// Why even bother with asserts?


///--- Exports

var types = {
    bool: {
        check: function check(arg) {
            return typeof arg === 'boolean';
        }
    },
    func: {
        check: function check(arg) {
            return typeof arg === 'function';
        }
    },
    string: {
        check: function check(arg) {
            return typeof arg === 'string';
        }
    },
    object: {
        check: function check(arg) {
            return (typeof arg === 'undefined' ? 'undefined' : (0, _typeof3.default)(arg)) === 'object' && arg !== null;
        }
    },
    number: {
        check: function check(arg) {
            return typeof arg === 'number' && !isNaN(arg);
        }
    },
    finite: {
        check: function check(arg) {
            return typeof arg === 'number' && !isNaN(arg) && isFinite(arg);
        }
    },
    buffer: {
        check: function check(arg) {
            return Buffer.isBuffer(arg);
        },
        operator: 'Buffer.isBuffer'
    },
    array: {
        check: function check(arg) {
            return Array.isArray(arg);
        },
        operator: 'Array.isArray'
    },
    stream: {
        check: function check(arg) {
            return arg instanceof Stream;
        },
        operator: 'instanceof',
        actual: _getClass
    },
    date: {
        check: function check(arg) {
            return arg instanceof Date;
        },
        operator: 'instanceof',
        actual: _getClass
    },
    regexp: {
        check: function check(arg) {
            return arg instanceof RegExp;
        },
        operator: 'instanceof',
        actual: _getClass
    },
    uuid: {
        check: function check(arg) {
            return typeof arg === 'string' && UUID_REGEXP.test(arg);
        },
        operator: 'isUUID'
    }
};

function _setExports(ndebug) {
    var keys = (0, _keys2.default)(types);
    var out;

    /* re-export standard assert */
    if (process.env.NODE_NDEBUG) {
        out = noop;
    } else {
        out = function out(arg, msg) {
            if (!arg) {
                _toss(msg, 'true', arg);
            }
        };
    }

    /* standard checks */
    keys.forEach(function (k) {
        if (ndebug) {
            out[k] = noop;
            return;
        }
        var type = types[k];
        out[k] = function (arg, msg) {
            if (!type.check(arg)) {
                _toss(msg, k, type.operator, arg, type.actual);
            }
        };
    });

    /* optional checks */
    keys.forEach(function (k) {
        var name = 'optional' + _capitalize(k);
        if (ndebug) {
            out[name] = noop;
            return;
        }
        var type = types[k];
        out[name] = function (arg, msg) {
            if (arg === undefined || arg === null) {
                return;
            }
            if (!type.check(arg)) {
                _toss(msg, k, type.operator, arg, type.actual);
            }
        };
    });

    /* arrayOf checks */
    keys.forEach(function (k) {
        var name = 'arrayOf' + _capitalize(k);
        if (ndebug) {
            out[name] = noop;
            return;
        }
        var type = types[k];
        var expected = '[' + k + ']';
        out[name] = function (arg, msg) {
            if (!Array.isArray(arg)) {
                _toss(msg, expected, type.operator, arg, type.actual);
            }
            var i;
            for (i = 0; i < arg.length; i++) {
                if (!type.check(arg[i])) {
                    _toss(msg, expected, type.operator, arg, type.actual);
                }
            }
        };
    });

    /* optionalArrayOf checks */
    keys.forEach(function (k) {
        var name = 'optionalArrayOf' + _capitalize(k);
        if (ndebug) {
            out[name] = noop;
            return;
        }
        var type = types[k];
        var expected = '[' + k + ']';
        out[name] = function (arg, msg) {
            if (arg === undefined || arg === null) {
                return;
            }
            if (!Array.isArray(arg)) {
                _toss(msg, expected, type.operator, arg, type.actual);
            }
            var i;
            for (i = 0; i < arg.length; i++) {
                if (!type.check(arg[i])) {
                    _toss(msg, expected, type.operator, arg, type.actual);
                }
            }
        };
    });

    /* re-export built-in assertions */
    (0, _keys2.default)(assert).forEach(function (k) {
        if (k === 'AssertionError') {
            out[k] = assert[k];
            return;
        }
        if (ndebug) {
            out[k] = noop;
            return;
        }
        out[k] = assert[k];
    });

    /* export ourselves (for unit tests _only_) */
    out._setExports = _setExports;

    return out;
}

module.exports = _setExports(process.env.NODE_NDEBUG);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/assert/assert.js":
/*!***************************************!*\
  !*** ./node_modules/assert/assert.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var objectAssign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = __webpack_require__(/*! util/ */ "./node_modules/util/util.js");
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = function () {
  return function foo() {}.name === 'foo';
}();
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' + name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

    // 7.2. If the expected value is a Date object, the actual value is
    // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

    // 7.3 If the expected value is a RegExp object, the actual value is
    // equivalent if it is also a RegExp object with the same source and
    // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;

    // 7.4. Other pairs that do not both pass typeof value == 'object',
    // equivalence is determined by ==.
  } else if ((actual === null || (typeof actual === 'undefined' ? 'undefined' : (0, _typeof3.default)(actual)) !== 'object') && (expected === null || (typeof expected === 'undefined' ? 'undefined' : (0, _typeof3.default)(expected)) !== 'object')) {
    return strict ? actual === expected : actual == expected;

    // If both values are instances of typed arrays, wrap their underlying
    // ArrayBuffers in a Buffer each to increase performance
    // This optimization requires the arrays to have the same type as checked by
    // Object.prototype.toString (aka pToString). Never perform binary
    // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
    // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;

    // 7.5 For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
  if (strict && (0, _getPrototypeOf2.default)(a) !== (0, _getPrototypeOf2.default)(b)) return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length) return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i]) return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function (block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function (block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function (err) {
  if (err) throw err;
};

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = _keys2.default || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/array/from.js":
/*!**********************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/array/from.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/array/from */ "./node_modules/core-js/library/fn/array/from.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/json/stringify.js":
/*!**************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/json/stringify.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/json/stringify */ "./node_modules/core-js/library/fn/json/stringify.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/number/is-finite.js":
/*!****************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/number/is-finite.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/number/is-finite */ "./node_modules/core-js/library/fn/number/is-finite.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/number/is-nan.js":
/*!*************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/number/is-nan.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/number/is-nan */ "./node_modules/core-js/library/fn/number/is-nan.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/number/max-safe-integer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/number/max-safe-integer.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/number/max-safe-integer */ "./node_modules/core-js/library/fn/number/max-safe-integer.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/number/min-safe-integer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/number/min-safe-integer.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/number/min-safe-integer */ "./node_modules/core-js/library/fn/number/min-safe-integer.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/assign.js":
/*!*************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/assign.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/assign */ "./node_modules/core-js/library/fn/object/assign.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/create.js":
/*!*************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/create.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/create */ "./node_modules/core-js/library/fn/object/create.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/define-properties.js":
/*!************************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/define-properties.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/define-properties */ "./node_modules/core-js/library/fn/object/define-properties.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/define-property.js":
/*!**********************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/define-property.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/define-property */ "./node_modules/core-js/library/fn/object/define-property.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/get-own-property-descriptor.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/get-own-property-descriptor.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/get-own-property-descriptor */ "./node_modules/core-js/library/fn/object/get-own-property-descriptor.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/get-own-property-descriptors.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/get-own-property-descriptors.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/get-own-property-descriptors */ "./node_modules/core-js/library/fn/object/get-own-property-descriptors.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/get-own-property-names.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/get-own-property-names.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/get-own-property-names */ "./node_modules/core-js/library/fn/object/get-own-property-names.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/get-own-property-symbols.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/get-own-property-symbols.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/get-own-property-symbols */ "./node_modules/core-js/library/fn/object/get-own-property-symbols.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js":
/*!***********************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/get-prototype-of.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/get-prototype-of */ "./node_modules/core-js/library/fn/object/get-prototype-of.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/is-extensible.js":
/*!********************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/is-extensible.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/is-extensible */ "./node_modules/core-js/library/fn/object/is-extensible.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/keys.js":
/*!***********************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/keys.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/keys */ "./node_modules/core-js/library/fn/object/keys.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/prevent-extensions.js":
/*!*************************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/prevent-extensions.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/prevent-extensions */ "./node_modules/core-js/library/fn/object/prevent-extensions.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/object/set-prototype-of.js":
/*!***********************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/set-prototype-of.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/set-prototype-of */ "./node_modules/core-js/library/fn/object/set-prototype-of.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/promise.js":
/*!*******************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/promise.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/promise */ "./node_modules/core-js/library/fn/promise.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/set-immediate.js":
/*!*************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/set-immediate.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/set-immediate */ "./node_modules/core-js/library/fn/set-immediate.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/symbol.js":
/*!******************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/symbol.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol */ "./node_modules/core-js/library/fn/symbol/index.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/symbol/has-instance.js":
/*!*******************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/symbol/has-instance.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol/has-instance */ "./node_modules/core-js/library/fn/symbol/has-instance.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/symbol/iterator.js":
/*!***************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/symbol/iterator.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol/iterator */ "./node_modules/core-js/library/fn/symbol/iterator.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/symbol/species.js":
/*!**************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/symbol/species.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = { "default": __webpack_require__(/*! core-js/library/fn/symbol/species */ "./node_modules/core-js/library/fn/symbol/species.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/asyncToGenerator.js":
/*!****************************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/asyncToGenerator.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _promise = __webpack_require__(/*! ../core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/classCallCheck.js":
/*!**************************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/classCallCheck.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/createClass.js":
/*!***********************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/createClass.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(/*! ../core-js/object/define-property */ "./node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/get.js":
/*!***************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/get.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _getPrototypeOf = __webpack_require__(/*! ../core-js/object/get-prototype-of */ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _getOwnPropertyDescriptor = __webpack_require__(/*! ../core-js/object/get-own-property-descriptor */ "./node_modules/babel-runtime/core-js/object/get-own-property-descriptor.js");

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);

  if (desc === undefined) {
    var parent = (0, _getPrototypeOf2.default)(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/inherits.js":
/*!********************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/inherits.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _setPrototypeOf = __webpack_require__(/*! ../core-js/object/set-prototype-of */ "./node_modules/babel-runtime/core-js/object/set-prototype-of.js");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(/*! ../core-js/object/create */ "./node_modules/babel-runtime/core-js/object/create.js");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js":
/*!*************************************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/possibleConstructorReturn.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/toConsumableArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/toConsumableArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _from = __webpack_require__(/*! ../core-js/array/from */ "./node_modules/babel-runtime/core-js/array/from.js");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/typeof.js":
/*!******************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/typeof.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof3 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof4 = _interopRequireDefault2(_typeof3);

function _interopRequireDefault2(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.__esModule = true;

var _iterator = __webpack_require__(/*! ../core-js/symbol/iterator */ "./node_modules/babel-runtime/core-js/symbol/iterator.js");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(/*! ../core-js/symbol */ "./node_modules/babel-runtime/core-js/symbol.js");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && (0, _typeof4.default)(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
};

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),

/***/ "./node_modules/babel-runtime/regenerator/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/babel-runtime/regenerator/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime-module.js");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;

  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;

  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var _defineProperty = __webpack_require__(/*! babel-runtime/core-js/object/define-property */ "./node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _species = __webpack_require__(/*! babel-runtime/core-js/symbol/species */ "./node_modules/babel-runtime/core-js/symbol/species.js");

var _species2 = _interopRequireDefault(_species);

var _symbol = __webpack_require__(/*! babel-runtime/core-js/symbol */ "./node_modules/babel-runtime/core-js/symbol.js");

var _symbol2 = _interopRequireDefault(_symbol);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof _symbol2.default !== 'undefined' && _species2.default && Buffer[_species2.default] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    (0, _defineProperty2.default)(Buffer, _species2.default, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/builtin-status-codes/browser.js":
/*!******************************************************!*\
  !*** ./node_modules/builtin-status-codes/browser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};

/***/ }),

/***/ "./node_modules/bytes/index.js":
/*!*************************************!*\
  !*** ./node_modules/bytes/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */



/**
 * Module exports.
 * @public
 */

var _isFinite = __webpack_require__(/*! babel-runtime/core-js/number/is-finite */ "./node_modules/babel-runtime/core-js/number/is-finite.js");

var _isFinite2 = _interopRequireDefault(_isFinite);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = bytes;
module.exports.format = format;
module.exports.parse = parse;

/**
 * Module variables.
 * @private
 */

var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;

var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

var map = {
  b: 1,
  kb: 1 << 10,
  mb: 1 << 20,
  gb: 1 << 30,
  tb: Math.pow(1024, 4),
  pb: Math.pow(1024, 5)
};

var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;

/**
 * Convert the given value in bytes into a string or parse to string to an integer in bytes.
 *
 * @param {string|number} value
 * @param {{
 *  case: [string],
 *  decimalPlaces: [number]
 *  fixedDecimals: [boolean]
 *  thousandsSeparator: [string]
 *  unitSeparator: [string]
 *  }} [options] bytes options.
 *
 * @returns {string|number|null}
 */

function bytes(value, options) {
  if (typeof value === 'string') {
    return parse(value);
  }

  if (typeof value === 'number') {
    return format(value, options);
  }

  return null;
}

/**
 * Format the given value in bytes into a string.
 *
 * If the value is negative, it is kept as such. If it is a float,
 * it is rounded.
 *
 * @param {number} value
 * @param {object} [options]
 * @param {number} [options.decimalPlaces=2]
 * @param {number} [options.fixedDecimals=false]
 * @param {string} [options.thousandsSeparator=]
 * @param {string} [options.unit=]
 * @param {string} [options.unitSeparator=]
 *
 * @returns {string|null}
 * @public
 */

function format(value, options) {
  if (!(0, _isFinite2.default)(value)) {
    return null;
  }

  var mag = Math.abs(value);
  var thousandsSeparator = options && options.thousandsSeparator || '';
  var unitSeparator = options && options.unitSeparator || '';
  var decimalPlaces = options && options.decimalPlaces !== undefined ? options.decimalPlaces : 2;
  var fixedDecimals = Boolean(options && options.fixedDecimals);
  var unit = options && options.unit || '';

  if (!unit || !map[unit.toLowerCase()]) {
    if (mag >= map.pb) {
      unit = 'PB';
    } else if (mag >= map.tb) {
      unit = 'TB';
    } else if (mag >= map.gb) {
      unit = 'GB';
    } else if (mag >= map.mb) {
      unit = 'MB';
    } else if (mag >= map.kb) {
      unit = 'KB';
    } else {
      unit = 'B';
    }
  }

  var val = value / map[unit.toLowerCase()];
  var str = val.toFixed(decimalPlaces);

  if (!fixedDecimals) {
    str = str.replace(formatDecimalsRegExp, '$1');
  }

  if (thousandsSeparator) {
    str = str.replace(formatThousandsRegExp, thousandsSeparator);
  }

  return str + unitSeparator + unit;
}

/**
 * Parse the string value into an integer in bytes.
 *
 * If no unit is given, it is assumed the value is in bytes.
 *
 * @param {number|string} val
 *
 * @returns {number|null}
 * @public
 */

function parse(val) {
  if (typeof val === 'number' && !isNaN(val)) {
    return val;
  }

  if (typeof val !== 'string') {
    return null;
  }

  // Test if the string passed is valid
  var results = parseRegExp.exec(val);
  var floatValue;
  var unit = 'b';

  if (!results) {
    // Nothing could be extracted from the given string
    floatValue = parseInt(val, 10);
    unit = 'b';
  } else {
    // Retrieve the value and the unit
    floatValue = parseFloat(results[1]);
    unit = results[4].toLowerCase();
  }

  return Math.floor(map[unit] * floatValue);
}

/***/ }),

/***/ "./node_modules/core-js/library/fn/array/from.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/fn/array/from.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.string.iterator */ "./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__(/*! ../../modules/es6.array.from */ "./node_modules/core-js/library/modules/es6.array.from.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Array.from;

/***/ }),

/***/ "./node_modules/core-js/library/fn/json/stringify.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/fn/json/stringify.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ "./node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var core = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js");
var $JSON = core.JSON || (core.JSON = { stringify: _stringify2.default });
module.exports = function stringify(it) {
  // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};

/***/ }),

/***/ "./node_modules/core-js/library/fn/number/is-finite.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/fn/number/is-finite.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.number.is-finite */ "./node_modules/core-js/library/modules/es6.number.is-finite.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Number.isFinite;

/***/ }),

/***/ "./node_modules/core-js/library/fn/number/is-nan.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/fn/number/is-nan.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.number.is-nan */ "./node_modules/core-js/library/modules/es6.number.is-nan.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Number.isNaN;

/***/ }),

/***/ "./node_modules/core-js/library/fn/number/max-safe-integer.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/fn/number/max-safe-integer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.number.max-safe-integer */ "./node_modules/core-js/library/modules/es6.number.max-safe-integer.js");
module.exports = 0x1fffffffffffff;

/***/ }),

/***/ "./node_modules/core-js/library/fn/number/min-safe-integer.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/fn/number/min-safe-integer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.number.min-safe-integer */ "./node_modules/core-js/library/modules/es6.number.min-safe-integer.js");
module.exports = -0x1fffffffffffff;

/***/ }),

/***/ "./node_modules/core-js/library/fn/object/assign.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/assign.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.object.assign */ "./node_modules/core-js/library/modules/es6.object.assign.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.assign;

/***/ }),

/***/ "./node_modules/core-js/library/fn/object/create.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/create.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.object.create */ "./node_modules/core-js/library/modules/es6.object.create.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};

/***/ }),

/***/ "./node_modules/core-js/library/fn/object/define-properties.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/define-properties.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.object.define-properties */ "./node_modules/core-js/library/modules/es6.object.define-properties.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function defineProperties(T, D) {
  return $Object.defineProperties(T, D);
};

/***/ }),

/***/ "./node_modules/core-js/library/fn/object/define-property.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/define-property.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.object.define-property */ "./node_modules/core-js/library/modules/es6.object.define-property.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};

/***/ }),

/***/ "./node_modules/core-js/library/fn/object/get-own-property-descriptor.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/get-own-property-descriptor.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.object.get-own-property-descriptor */ "./node_modules/core-js/library/modules/es6.object.get-own-property-descriptor.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function getOwnPropertyDescriptor(it, key) {
  return $Object.getOwnPropertyDescriptor(it, key);
};

/***/ }),

/***/ "./node_modules/core-js/library/fn/object/get-own-property-descriptors.js":
/*!********************************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/get-own-property-descriptors.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es7.object.get-own-property-descriptors */ "./node_modules/core-js/library/modules/es7.object.get-own-property-descriptors.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.getOwnPropertyDescriptors;

/***/ }),

/***/ "./node_modules/core-js/library/fn/object/get-own-property-names.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/get-own-property-names.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.object.get-own-property-names */ "./node_modules/core-js/library/modules/es6.object.get-own-property-names.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object;
module.exports = function getOwnPropertyNames(it) {
  return $Object.getOwnPropertyNames(it);
};

/***/ }),

/***/ "./node_modules/core-js/library/fn/object/get-own-property-symbols.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/get-own-property-symbols.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.symbol */ "./node_modules/core-js/library/modules/es6.symbol.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.getOwnPropertySymbols;

/***/ }),

/***/ "./node_modules/core-js/library/fn/object/get-prototype-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/get-prototype-of.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.object.get-prototype-of */ "./node_modules/core-js/library/modules/es6.object.get-prototype-of.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.getPrototypeOf;

/***/ }),

/***/ "./node_modules/core-js/library/fn/object/is-extensible.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/is-extensible.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.object.is-extensible */ "./node_modules/core-js/library/modules/es6.object.is-extensible.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.isExtensible;

/***/ }),

/***/ "./node_modules/core-js/library/fn/object/keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.object.keys */ "./node_modules/core-js/library/modules/es6.object.keys.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.keys;

/***/ }),

/***/ "./node_modules/core-js/library/fn/object/prevent-extensions.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/prevent-extensions.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.object.prevent-extensions */ "./node_modules/core-js/library/modules/es6.object.prevent-extensions.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.preventExtensions;

/***/ }),

/***/ "./node_modules/core-js/library/fn/object/set-prototype-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/fn/object/set-prototype-of.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.object.set-prototype-of */ "./node_modules/core-js/library/modules/es6.object.set-prototype-of.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Object.setPrototypeOf;

/***/ }),

/***/ "./node_modules/core-js/library/fn/promise.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/library/fn/promise.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../modules/es6.object.to-string */ "./node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__(/*! ../modules/es6.string.iterator */ "./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__(/*! ../modules/es6.promise */ "./node_modules/core-js/library/modules/es6.promise.js");
__webpack_require__(/*! ../modules/es7.promise.finally */ "./node_modules/core-js/library/modules/es7.promise.finally.js");
__webpack_require__(/*! ../modules/es7.promise.try */ "./node_modules/core-js/library/modules/es7.promise.try.js");
module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Promise;

/***/ }),

/***/ "./node_modules/core-js/library/fn/set-immediate.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/fn/set-immediate.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../modules/web.immediate */ "./node_modules/core-js/library/modules/web.immediate.js");
module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/core-js/library/modules/_core.js").setImmediate;

/***/ }),

/***/ "./node_modules/core-js/library/fn/symbol/has-instance.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/fn/symbol/has-instance.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.function.has-instance */ "./node_modules/core-js/library/modules/es6.function.has-instance.js");
module.exports = __webpack_require__(/*! ../../modules/_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js").f('hasInstance');

/***/ }),

/***/ "./node_modules/core-js/library/fn/symbol/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/fn/symbol/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.symbol */ "./node_modules/core-js/library/modules/es6.symbol.js");
__webpack_require__(/*! ../../modules/es6.object.to-string */ "./node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__(/*! ../../modules/es7.symbol.async-iterator */ "./node_modules/core-js/library/modules/es7.symbol.async-iterator.js");
__webpack_require__(/*! ../../modules/es7.symbol.observable */ "./node_modules/core-js/library/modules/es7.symbol.observable.js");
module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/core-js/library/modules/_core.js").Symbol;

/***/ }),

/***/ "./node_modules/core-js/library/fn/symbol/iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/fn/symbol/iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.string.iterator */ "./node_modules/core-js/library/modules/es6.string.iterator.js");
__webpack_require__(/*! ../../modules/web.dom.iterable */ "./node_modules/core-js/library/modules/web.dom.iterable.js");
module.exports = __webpack_require__(/*! ../../modules/_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js").f('iterator');

/***/ }),

/***/ "./node_modules/core-js/library/fn/symbol/species.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/fn/symbol/species.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ../../modules/_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js").f('species');

/***/ }),

/***/ "./node_modules/core-js/library/modules/_a-function.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_a-function.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_add-to-unscopables.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_add-to-unscopables.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {/* empty */};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_an-instance.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_an-instance.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }return it;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_an-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_an-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_array-includes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_array-includes.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/core-js/library/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }
    }return !IS_INCLUDES && -1;
  };
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_classof.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_classof.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');
// ES3 wrong here
var ARG = cof(function () {
  return arguments;
}()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (e) {/* empty */}
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
  // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
  // builtinTag case
  : ARG ? cof(O)
  // ES3 arguments fallback
  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_cof.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_cof.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_core.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_core.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var core = module.exports = { version: '2.6.3' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/core-js/library/modules/_create-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_create-property.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_ctx.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_ctx.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_defined.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_defined.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_descriptors.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_descriptors.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

/***/ }),

/***/ "./node_modules/core-js/library/modules/_dom-create.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_dom-create.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_enum-bug-keys.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_enum-bug-keys.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// IE 8- don't enum bug keys
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

/***/ }),

/***/ "./node_modules/core-js/library/modules/_enum-keys.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_enum-keys.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) {
      if (isEnum.call(it, key = symbols[i++])) result.push(key);
    }
  }return result;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_export.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_export.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? function (C) {
      var F = function F(a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0:
              return new C();
            case 1:
              return new C(a);
            case 2:
              return new C(a, b);
          }return new C(a, b, c);
        }return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
      // make static versions for prototype methods
    }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

/***/ }),

/***/ "./node_modules/core-js/library/modules/_fails.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_fails.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_for-of.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_for-of.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/library/modules/_iter-call.js");
var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/library/modules/_is-array-iter.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/library/modules/core.get-iterator-method.js");
var BREAK = {};
var RETURN = {};
var _exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () {
    return iterable;
  } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
_exports.BREAK = BREAK;
_exports.RETURN = RETURN;

/***/ }),

/***/ "./node_modules/core-js/library/modules/_global.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_global.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self
// eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/core-js/library/modules/_has.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_has.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_hide.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_hide.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_html.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_html.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var document = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").document;
module.exports = document && document.documentElement;

/***/ }),

/***/ "./node_modules/core-js/library/modules/_ie8-dom-define.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_ie8-dom-define.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

/***/ }),

/***/ "./node_modules/core-js/library/modules/_invoke.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_invoke.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
                  var un = that === undefined;
                  switch (args.length) {
                                    case 0:
                                                      return un ? fn() : fn.call(that);
                                    case 1:
                                                      return un ? fn(args[0]) : fn.call(that, args[0]);
                                    case 2:
                                                      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                                    case 3:
                                                      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                                    case 4:
                                                      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
                  }return fn.apply(that, args);
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_iobject.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iobject.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-array-iter.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-array-iter.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-array.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-array.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_is-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_is-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function (it) {
  return (typeof it === 'undefined' ? 'undefined' : (0, _typeof3.default)(it)) === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-call.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-call.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-create.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-create.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js");
var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-define.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-define.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/library/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/core-js/library/modules/_iter-create.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/library/modules/_object-gpo.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function returnThis() {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function getMethod(kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };
      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }return function entries() {
      return new Constructor(this, kind);
    };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() {
      return $native.call(this);
    };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-detect.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-detect.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _from = __webpack_require__(/*! babel-runtime/core-js/array/from */ "./node_modules/babel-runtime/core-js/array/from.js");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () {
    SAFE_CLOSING = true;
  };
  // eslint-disable-next-line no-throw-literal
  (0, _from2.default)(riter, function () {
    throw 2;
  });
} catch (e) {/* empty */}

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () {
      return { done: safe = true };
    };
    arr[ITERATOR] = function () {
      return iter;
    };
    exec(arr);
  } catch (e) {/* empty */}
  return safe;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_iter-step.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iter-step.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (done, value) {
  return { value: value, done: !!done };
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_iterators.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_iterators.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_library.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_library.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = true;

/***/ }),

/***/ "./node_modules/core-js/library/modules/_meta.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_meta.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

var _preventExtensions = __webpack_require__(/*! babel-runtime/core-js/object/prevent-extensions */ "./node_modules/babel-runtime/core-js/object/prevent-extensions.js");

var _preventExtensions2 = _interopRequireDefault(_preventExtensions);

var _isExtensible = __webpack_require__(/*! babel-runtime/core-js/object/is-extensible */ "./node_modules/babel-runtime/core-js/object/is-extensible.js");

var _isExtensible2 = _interopRequireDefault(_isExtensible);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var META = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js")('meta');
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var id = 0;
var isExtensible = _isExtensible2.default || function () {
  return true;
};
var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  return isExtensible((0, _preventExtensions2.default)({}));
});
var setMeta = function setMeta(it) {
  setDesc(it, META, { value: {
      i: 'O' + ++id, // object ID
      w: {} // weak collections IDs
    } });
};
var fastKey = function fastKey(it, create) {
  // return primitive with prefix
  if (!isObject(it)) return (typeof it === 'undefined' ? 'undefined' : (0, _typeof3.default)(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
    // return object ID
  }return it[META].i;
};
var getWeak = function getWeak(it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
    // return hash weak collections IDs
  }return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function onFreeze(it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_microtask.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_microtask.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var macrotask = __webpack_require__(/*! ./_task */ "./node_modules/core-js/library/modules/_task.js").set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function flush() {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();else last = undefined;
        throw e;
      }
    }last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function notify() {
      process.nextTick(flush);
    };
    // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function notify() {
      node.data = toggle = !toggle;
    };
    // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function notify() {
      promise.then(flush);
    };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout
  } else {
    notify = function notify() {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    }last = task;
  };
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_new-promise-capability.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_new-promise-capability.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-assign.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-assign.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)

var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _symbol = __webpack_require__(/*! babel-runtime/core-js/symbol */ "./node_modules/babel-runtime/core-js/symbol.js");

var _symbol2 = _interopRequireDefault(_symbol);

var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var $assign = _assign2.default;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = (0, _symbol2.default)();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || (0, _keys2.default)($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }
  }return T;
} : $assign;

/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-create.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ "./node_modules/babel-runtime/core-js/object/create.js");

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/library/modules/_object-dps.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var Empty = function Empty() {/* empty */};
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var _createDict = function createDict() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(/*! ./_html */ "./node_modules/core-js/library/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;
  while (i--) {
    delete _createDict[PROTOTYPE][enumBugKeys[i]];
  }return _createDict();
};

module.exports = _create2.default || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = _createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dp.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-dp.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _defineProperty = __webpack_require__(/*! babel-runtime/core-js/object/define-property */ "./node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/library/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var dP = _defineProperty2.default;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? _defineProperty2.default : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-dps.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-dps.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _defineProperties = __webpack_require__(/*! babel-runtime/core-js/object/define-properties */ "./node_modules/babel-runtime/core-js/object/define-properties.js");

var _defineProperties2 = _interopRequireDefault(_defineProperties);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? _defineProperties2.default : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) {
    dP.f(O, P = keys[i++], Properties[P]);
  }return O;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopd.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gopd.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _getOwnPropertyDescriptor = __webpack_require__(/*! babel-runtime/core-js/object/get-own-property-descriptor */ "./node_modules/babel-runtime/core-js/object/get-own-property-descriptor.js");

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/core-js/library/modules/_ie8-dom-define.js");
var gOPD = _getOwnPropertyDescriptor2.default;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) {/* empty */}
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopn-ext.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gopn-ext.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _getOwnPropertyNames = __webpack_require__(/*! babel-runtime/core-js/object/get-own-property-names */ "./node_modules/babel-runtime/core-js/object/get-own-property-names.js");

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/library/modules/_object-gopn.js").f;
var toString = {}.toString;

var windowNames = (typeof window === 'undefined' ? 'undefined' : (0, _typeof3.default)(window)) == 'object' && window && _getOwnPropertyNames2.default ? (0, _getOwnPropertyNames2.default)(window) : [];

var getWindowNames = function getWindowNames(it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gopn.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gopn.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _getOwnPropertyNames = __webpack_require__(/*! babel-runtime/core-js/object/get-own-property-names */ "./node_modules/babel-runtime/core-js/object/get-own-property-names.js");

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/library/modules/_object-keys-internal.js");
var hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = _getOwnPropertyNames2.default || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gops.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gops.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _getOwnPropertySymbols = __webpack_require__(/*! babel-runtime/core-js/object/get-own-property-symbols */ "./node_modules/babel-runtime/core-js/object/get-own-property-symbols.js");

var _getOwnPropertySymbols2 = _interopRequireDefault(_getOwnPropertySymbols);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.f = _getOwnPropertySymbols2.default;

/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-gpo.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-gpo.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = _getPrototypeOf2.default || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }return O instanceof Object ? ObjectProto : null;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-keys-internal.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-keys-internal.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/core-js/library/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) {
    if (key != IE_PROTO) has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys
  while (names.length > i) {
    if (has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
  }return result;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-keys.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-keys.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/core-js/library/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/core-js/library/modules/_enum-bug-keys.js");

module.exports = _keys2.default || function keys(O) {
  return $keys(O, enumBugKeys);
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-pie.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-pie.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.f = {}.propertyIsEnumerable;

/***/ }),

/***/ "./node_modules/core-js/library/modules/_object-sap.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_object-sap.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js");
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () {
    fn(1);
  }), 'Object', exp);
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_own-keys.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_own-keys.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/library/modules/_object-gopn.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var Reflect = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_perform.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_perform.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_promise-resolve.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_promise-resolve.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/library/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_property-desc.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_property-desc.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_redefine-all.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_redefine-all.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];else hide(target, key, src[key]);
  }return target;
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_redefine.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_redefine.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");

/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-proto.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-proto.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _setPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/set-prototype-of */ "./node_modules/babel-runtime/core-js/object/set-prototype-of.js");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var check = function check(O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: _setPrototypeOf2.default || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js")(Function.call, __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/library/modules/_object-gopd.js").f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }
    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-species.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-species.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function get() {
      return this;
    }
  });
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_set-to-string-tag.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_set-to-string-tag.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_shared-key.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_shared-key.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js")('keys');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_shared.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_shared.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js") ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

/***/ }),

/***/ "./node_modules/core-js/library/modules/_species-constructor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_species-constructor.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_string-at.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_string-at.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_task.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_task.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/core-js/library/modules/_invoke.js");
var html = __webpack_require__(/*! ./_html */ "./node_modules/core-js/library/modules/_html.js");
var cel = __webpack_require__(/*! ./_dom-create */ "./node_modules/core-js/library/modules/_dom-create.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function run() {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function listener(event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) {
      args.push(arguments[i++]);
    }queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(/*! ./_cof */ "./node_modules/core-js/library/modules/_cof.js")(process) == 'process') {
    defer = function defer(id) {
      process.nextTick(ctx(run, id, 1));
    };
    // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function defer(id) {
      Dispatch.now(ctx(run, id, 1));
    };
    // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function defer(id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
    // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function defer(id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
    // Rest old browsers
  } else {
    defer = function defer(id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-absolute-index.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-absolute-index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-integer.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-integer.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-iobject.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-iobject.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/core-js/library/modules/_iobject.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-length.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-length.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/core-js/library/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-object.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-object.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_to-primitive.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_to-primitive.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_uid.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_uid.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_user-agent.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_user-agent.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks-define.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks-define.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js");
var defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks-ext.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks-ext.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.f = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js");

/***/ }),

/***/ "./node_modules/core-js/library/modules/_wks.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/library/modules/_wks.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var store = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js")('wks');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
var _Symbol = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").Symbol;
var USE_SYMBOL = typeof _Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),

/***/ "./node_modules/core-js/library/modules/core.get-iterator-method.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/core.get-iterator-method.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/library/modules/_classof.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('iterator');
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
module.exports = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.from.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.from.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _from = __webpack_require__(/*! babel-runtime/core-js/array/from */ "./node_modules/babel-runtime/core-js/array/from.js");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/core-js/library/modules/_iter-call.js");
var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/core-js/library/modules/_is-array-iter.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/core-js/library/modules/_to-length.js");
var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/library/modules/_create-property.js");
var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/core-js/library/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/library/modules/_iter-detect.js")(function (iter) {
  (0, _from2.default)(iter);
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.array.iterator.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.array.iterator.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/core-js/library/modules/_add-to-unscopables.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/core-js/library/modules/_iter-step.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/library/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0; // next index
  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.function.has-instance.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.function.has-instance.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/library/modules/_object-gpo.js");
var HAS_INSTANCE = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f(FunctionProto, HAS_INSTANCE, { value: function value(O) {
    if (typeof this != 'function' || !isObject(O)) return false;
    if (!isObject(this.prototype)) return O instanceof this;
    // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
    while (O = getPrototypeOf(O)) {
      if (this.prototype === O) return true;
    }return false;
  } });

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.number.is-finite.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.number.is-finite.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var _isFinite = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js").isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.number.is-nan.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.number.is-nan.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.number.max-safe-integer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.number.max-safe-integer.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.number.min-safe-integer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.number.min-safe-integer.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.assign.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.assign.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(/*! ./_object-assign */ "./node_modules/core-js/library/modules/_object-assign.js") });

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.create.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.create.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js") });

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.define-properties.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.define-properties.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js"), 'Object', { defineProperties: __webpack_require__(/*! ./_object-dps */ "./node_modules/core-js/library/modules/_object-dps.js") });

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.define-property.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.define-property.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js"), 'Object', { defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js").f });

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.get-own-property-descriptor.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.get-own-property-descriptor.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var $getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/library/modules/_object-gopd.js").f;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/library/modules/_object-sap.js")('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.get-own-property-names.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.get-own-property-names.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/library/modules/_object-sap.js")('getOwnPropertyNames', function () {
  return __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/library/modules/_object-gopn-ext.js").f;
});

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.get-prototype-of.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.get-prototype-of.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var $getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/core-js/library/modules/_object-gpo.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/library/modules/_object-sap.js")('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.is-extensible.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.is-extensible.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/library/modules/_object-sap.js")('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.keys.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.keys.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/core-js/library/modules/_to-object.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/library/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.prevent-extensions.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.prevent-extensions.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/library/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "./node_modules/core-js/library/modules/_object-sap.js")('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.set-prototype-of.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.set-prototype-of.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(/*! ./_set-proto */ "./node_modules/core-js/library/modules/_set-proto.js").set });

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.object.to-string.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.object.to-string.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.promise.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.promise.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/core-js/library/modules/_ctx.js");
var classof = __webpack_require__(/*! ./_classof */ "./node_modules/core-js/library/modules/_classof.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/core-js/library/modules/_a-function.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/core-js/library/modules/_an-instance.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/core-js/library/modules/_for-of.js");
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/library/modules/_species-constructor.js");
var task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/library/modules/_task.js").set;
var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/core-js/library/modules/_microtask.js")();
var newPromiseCapabilityModule = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/library/modules/_new-promise-capability.js");
var perform = __webpack_require__(/*! ./_perform */ "./node_modules/core-js/library/modules/_perform.js");
var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/core-js/library/modules/_user-agent.js");
var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/library/modules/_promise-resolve.js");
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function empty() {/* empty */};
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise
    // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // we can't detect it synchronously, so just check versions
    && v8.indexOf('6.6') !== 0 && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) {/* empty */}
}();

// helpers
var isThenable = function isThenable(it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function notify(promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function run(reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) {
      run(chain[i++]);
    } // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function onUnhandled(promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    }promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function isUnhandled(promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function onHandleUnhandled(promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function $reject(value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function $resolve(value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = []; // <- awaiting reactions
    this._a = undefined; // <- checked in isUnhandled reactions
    this._s = 0; // <- state
    this._d = false; // <- done
    this._v = undefined; // <- value
    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false; // <- notify
  };
  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ "./node_modules/core-js/library/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function _catch(onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function OwnPromiseCapability() {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js")($Promise, PROMISE);
__webpack_require__(/*! ./_set-species */ "./node_modules/core-js/library/modules/_set-species.js")(PROMISE);
Wrapper = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js")[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ "./node_modules/core-js/library/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.string.iterator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.string.iterator.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/core-js/library/modules/_string-at.js")(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(/*! ./_iter-define */ "./node_modules/core-js/library/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

/***/ }),

/***/ "./node_modules/core-js/library/modules/es6.symbol.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es6.symbol.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/core-js/library/modules/_has.js");
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/core-js/library/modules/_descriptors.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/core-js/library/modules/_redefine.js");
var META = __webpack_require__(/*! ./_meta */ "./node_modules/core-js/library/modules/_meta.js").KEY;
var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/core-js/library/modules/_fails.js");
var shared = __webpack_require__(/*! ./_shared */ "./node_modules/core-js/library/modules/_shared.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/core-js/library/modules/_set-to-string-tag.js");
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/core-js/library/modules/_uid.js");
var wks = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js");
var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/core-js/library/modules/_wks-ext.js");
var wksDefine = __webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/library/modules/_wks-define.js");
var enumKeys = __webpack_require__(/*! ./_enum-keys */ "./node_modules/core-js/library/modules/_enum-keys.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/core-js/library/modules/_is-array.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/core-js/library/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/core-js/library/modules/_is-object.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/core-js/library/modules/_to-primitive.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/core-js/library/modules/_property-desc.js");
var _create = __webpack_require__(/*! ./_object-create */ "./node_modules/core-js/library/modules/_object-create.js");
var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/core-js/library/modules/_object-gopn-ext.js");
var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/library/modules/_object-gopd.js");
var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/core-js/library/modules/_object-dp.js");
var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/core-js/library/modules/_object-keys.js");
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function get() {
      return dP(this, 'a', { value: 7 }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function wrap(tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && (0, _typeof3.default)($Symbol.iterator) == 'symbol' ? function (it) {
  return (typeof it === 'undefined' ? 'undefined' : (0, _typeof3.default)(it)) == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    }return setSymbolDesc(it, key, D);
  }return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) {
    $defineProperty(it, key = keys[i++], P[key]);
  }return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function _Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function $set(value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(/*! ./_object-gopn */ "./node_modules/core-js/library/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(/*! ./_object-pie */ "./node_modules/core-js/library/modules/_object-pie.js").f = $propertyIsEnumerable;
  __webpack_require__(/*! ./_object-gops */ "./node_modules/core-js/library/modules/_object-gops.js").f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "./node_modules/core-js/library/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols =
// 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
  wks(es6Symbols[j++]);
}for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) {
  wksDefine(wellKnownSymbols[k++]);
}$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function _for(key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) {
      if (SymbolRegistry[key] === sym) return key;
    }
  },
  useSetter: function useSetter() {
    setter = true;
  },
  useSimple: function useSimple() {
    setter = false;
  }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) {
      args.push(arguments[i++]);
    }$replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function replacer(key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.object.get-own-property-descriptors.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.object.get-own-property-descriptors.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var ownKeys = __webpack_require__(/*! ./_own-keys */ "./node_modules/core-js/library/modules/_own-keys.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/core-js/library/modules/_to-iobject.js");
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/core-js/library/modules/_object-gopd.js");
var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/core-js/library/modules/_create-property.js");

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.promise.finally.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.promise.finally.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/core-js/library/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/core-js/library/modules/_species-constructor.js");
var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/core-js/library/modules/_promise-resolve.js");

$export($export.P + $export.R, 'Promise', { 'finally': function _finally(onFinally) {
    var C = speciesConstructor(this, core.Promise || global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  } });

/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.promise.try.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.promise.try.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try

var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/core-js/library/modules/_new-promise-capability.js");
var perform = __webpack_require__(/*! ./_perform */ "./node_modules/core-js/library/modules/_perform.js");

$export($export.S, 'Promise', { 'try': function _try(callbackfn) {
    var promiseCapability = newPromiseCapability.f(this);
    var result = perform(callbackfn);
    (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
    return promiseCapability.promise;
  } });

/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.symbol.async-iterator.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.symbol.async-iterator.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/library/modules/_wks-define.js")('asyncIterator');

/***/ }),

/***/ "./node_modules/core-js/library/modules/es7.symbol.observable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/library/modules/es7.symbol.observable.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./_wks-define */ "./node_modules/core-js/library/modules/_wks-define.js")('observable');

/***/ }),

/***/ "./node_modules/core-js/library/modules/web.dom.iterable.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/library/modules/web.dom.iterable.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./es6.array.iterator */ "./node_modules/core-js/library/modules/es6.array.iterator.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/core-js/library/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/core-js/library/modules/_iterators.js");
var TO_STRING_TAG = __webpack_require__(/*! ./_wks */ "./node_modules/core-js/library/modules/_wks.js")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' + 'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' + 'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' + 'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' + 'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

/***/ }),

/***/ "./node_modules/core-js/library/modules/web.immediate.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/library/modules/web.immediate.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/core-js/library/modules/_export.js");
var $task = __webpack_require__(/*! ./_task */ "./node_modules/core-js/library/modules/_task.js");
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : (0, _typeof3.default)(arg)) === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : (0, _typeof3.default)(arg)) === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : (0, _typeof3.default)(arg)) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ "./node_modules/babel-runtime/core-js/object/create.js");

var _create2 = _interopRequireDefault(_create);

var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _isNan = __webpack_require__(/*! babel-runtime/core-js/number/is-nan */ "./node_modules/babel-runtime/core-js/number/is-nan.js");

var _isNan2 = _interopRequireDefault(_isNan);

var _getOwnPropertyNames = __webpack_require__(/*! babel-runtime/core-js/object/get-own-property-names */ "./node_modules/babel-runtime/core-js/object/get-own-property-names.js");

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _getOwnPropertySymbols = __webpack_require__(/*! babel-runtime/core-js/object/get-own-property-symbols */ "./node_modules/babel-runtime/core-js/object/get-own-property-symbols.js");

var _getOwnPropertySymbols2 = _interopRequireDefault(_getOwnPropertySymbols);

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var R = (typeof Reflect === 'undefined' ? 'undefined' : (0, _typeof3.default)(Reflect)) === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};

var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (_getOwnPropertySymbols2.default) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return (0, _getOwnPropertyNames2.default)(target).concat((0, _getOwnPropertySymbols2.default)(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return (0, _getOwnPropertyNames2.default)(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = _isNan2.default || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {

  if (this._events === undefined || this._events === (0, _getPrototypeOf2.default)(this)._events) {
    this._events = (0, _create2.default)(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) {
    args.push(arguments[i]);
  }var doError = type === 'error';

  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0) er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) {
      ReflectApply(listeners[i], this, args);
    }
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + (typeof listener === 'undefined' ? 'undefined' : (0, _typeof3.default)(listener)));
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = (0, _create2.default)(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) {
    args.push(arguments[i]);
  }if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + (typeof listener === 'undefined' ? 'undefined' : (0, _typeof3.default)(listener)));
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + (typeof listener === 'undefined' ? 'undefined' : (0, _typeof3.default)(listener)));
  }
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + (typeof listener === 'undefined' ? 'undefined' : (0, _typeof3.default)(listener)));
  }

  events = this._events;
  if (events === undefined) return this;

  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = (0, _create2.default)(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }

    if (list.length === 1) events[type] = list[0];

    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;

  events = this._events;
  if (events === undefined) return this;

  // not listening for removeListener, no need to emit
  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = (0, _create2.default)(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = (0, _create2.default)(null);else delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = (0, _keys2.default)(events);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = (0, _create2.default)(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined) return [];

  var evlistener = events[type];
  if (evlistener === undefined) return [];

  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i) {
    copy[i] = arr[i];
  }return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) {
    list[index] = list[index + 1];
  }list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

/***/ }),

/***/ "./node_modules/extsprintf/lib/extsprintf.js":
/*!***************************************************!*\
  !*** ./node_modules/extsprintf/lib/extsprintf.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * extsprintf.js: extended POSIX-style sprintf
 */

var mod_assert = __webpack_require__(/*! assert */ "./node_modules/assert/assert.js");
var mod_util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

/*
 * Public interface
 */
exports.sprintf = jsSprintf;
exports.printf = jsPrintf;
exports.fprintf = jsFprintf;

/*
 * Stripped down version of s[n]printf(3c).  We make a best effort to throw an
 * exception when given a format string we don't understand, rather than
 * ignoring it, so that we won't break existing programs if/when we go implement
 * the rest of this.
 *
 * This implementation currently supports specifying
 *	- field alignment ('-' flag),
 * 	- zero-pad ('0' flag)
 *	- always show numeric sign ('+' flag),
 *	- field width
 *	- conversions for strings, decimal integers, and floats (numbers).
 *	- argument size specifiers.  These are all accepted but ignored, since
 *	  Javascript has no notion of the physical size of an argument.
 *
 * Everything else is currently unsupported, most notably precision, unsigned
 * numbers, non-decimal numbers, and characters.
 */
function jsSprintf(fmt) {
	var regex = ['([^%]*)', /* normal text */
	'%', /* start of format */
	'([\'\\-+ #0]*?)', /* flags (optional) */
	'([1-9]\\d*)?', /* width (optional) */
	'(\\.([1-9]\\d*))?', /* precision (optional) */
	'[lhjztL]*?', /* length mods (ignored) */
	'([diouxXfFeEgGaAcCsSp%jr])' /* conversion */
	].join('');

	var re = new RegExp(regex);
	var args = Array.prototype.slice.call(arguments, 1);
	var flags, width, precision, conversion;
	var left, pad, sign, arg, match;
	var ret = '';
	var argn = 1;

	mod_assert.equal('string', typeof fmt === 'undefined' ? 'undefined' : (0, _typeof3.default)(fmt));

	while ((match = re.exec(fmt)) !== null) {
		ret += match[1];
		fmt = fmt.substring(match[0].length);

		flags = match[2] || '';
		width = match[3] || 0;
		precision = match[4] || '';
		conversion = match[6];
		left = false;
		sign = false;
		pad = ' ';

		if (conversion == '%') {
			ret += '%';
			continue;
		}

		if (args.length === 0) throw new Error('too few args to sprintf');

		arg = args.shift();
		argn++;

		if (flags.match(/[\' #]/)) throw new Error('unsupported flags: ' + flags);

		if (precision.length > 0) throw new Error('non-zero precision not supported');

		if (flags.match(/-/)) left = true;

		if (flags.match(/0/)) pad = '0';

		if (flags.match(/\+/)) sign = true;

		switch (conversion) {
			case 's':
				if (arg === undefined || arg === null) throw new Error('argument ' + argn + ': attempted to print undefined or null ' + 'as a string');
				ret += doPad(pad, width, left, arg.toString());
				break;

			case 'd':
				arg = Math.floor(arg);
			/*jsl:fallthru*/
			case 'f':
				sign = sign && arg > 0 ? '+' : '';
				ret += sign + doPad(pad, width, left, arg.toString());
				break;

			case 'x':
				ret += doPad(pad, width, left, arg.toString(16));
				break;

			case 'j':
				/* non-standard */
				if (width === 0) width = 10;
				ret += mod_util.inspect(arg, false, width);
				break;

			case 'r':
				/* non-standard */
				ret += dumpException(arg);
				break;

			default:
				throw new Error('unsupported conversion: ' + conversion);
		}
	}

	ret += fmt;
	return ret;
}

function jsPrintf() {
	var args = Array.prototype.slice.call(arguments);
	args.unshift(process.stdout);
	jsFprintf.apply(null, args);
}

function jsFprintf(stream) {
	var args = Array.prototype.slice.call(arguments, 1);
	return stream.write(jsSprintf.apply(this, args));
}

function doPad(chr, width, left, str) {
	var ret = str;

	while (ret.length < width) {
		if (left) ret += chr;else ret = chr + ret;
	}

	return ret;
}

/*
 * This function dumps long stack traces for exceptions having a cause() method.
 * See node-verror for an example.
 */
function dumpException(ex) {
	var ret;

	if (!(ex instanceof Error)) throw new Error(jsSprintf('invalid type for %%r: %j', ex));

	/* Note that V8 prepends "ex.stack" with ex.toString(). */
	ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;

	if (ex.cause && typeof ex.cause === 'function') {
		var cex = ex.cause();
		if (cex) {
			ret += '\nCaused by: ' + dumpException(cex);
		}
	}

	return ret;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/form-data/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/form-data/lib/browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-env browser */
module.exports = (typeof self === 'undefined' ? 'undefined' : (0, _typeof3.default)(self)) == 'object' ? self.FormData : window.FormData;

/***/ }),

/***/ "./node_modules/https-browserify/index.js":
/*!************************************************!*\
  !*** ./node_modules/https-browserify/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var http = __webpack_require__(/*! http */ "./node_modules/stream-http/index.js");
var url = __webpack_require__(/*! url */ "./node_modules/node-libs-browser/mock/empty.js");

var https = module.exports;

for (var key in http) {
  if (http.hasOwnProperty(key)) https[key] = http[key];
}

https.request = function (params, cb) {
  params = validateParams(params);
  return http.request.call(this, params, cb);
};

https.get = function (params, cb) {
  params = validateParams(params);
  return http.get.call(this, params, cb);
};

function validateParams(params) {
  if (typeof params === 'string') {
    params = url.parse(params);
  }
  if (!params.protocol) {
    params.protocol = 'https:';
  }
  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
  }
  return params;
}

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ "./node_modules/babel-runtime/core-js/object/create.js");

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (typeof _create2.default === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = (0, _create2.default)(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function TempCtor() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

/***/ }),

/***/ "./node_modules/ip6addr/ip6addr.js":
/*!*****************************************!*\
  !*** ./node_modules/ip6addr/ip6addr.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright 2016, Joyent, Inc.
 */

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var jsprim = __webpack_require__(/*! jsprim */ "./node_modules/jsprim/lib/jsprim.js");
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

///--- Helpers

function ParseError(input, message, index) {
  if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);

  this.input = input;
  this.message = message;
  if (index !== undefined) {
    this.message += ' at index ' + index;
  }
}
util.inherits(ParseError, Error);

function modulo(a, n) {
  return (n + a % n) % n;
}

function _arrayToOctetString(input) {
  var out;
  out = (input[0] >> 8) + '.' + (input[0] & 0xff) + '.';
  out += (input[1] >> 8) + '.' + (input[1] & 0xff);
  return out;
}

function _isAddr(addr) {
  if ((typeof addr === 'undefined' ? 'undefined' : (0, _typeof3.default)(addr)) === 'object') {
    /* It must resemble an Addr object */
    if (Array.isArray(addr._fields) && (0, _typeof3.default)(addr._attrs) === 'object') {
      return true;
    }
  }
  return false;
}

function _toAddr(input) {
  if (typeof input === 'string') {
    return ip6addrParse(input);
  } else if (_isAddr(input)) {
    return input;
  } else {
    throw new Error('Invalid argument: Addr or parsable string expected');
  }
}

function _arrayToHex(input, zeroElide, zeroPad) {
  var i;
  var elStart = null;
  var elLen = 0;
  if (zeroElide) {
    /* find longest run of zeroes to potentially elide */
    var start = null;
    var len = null;
    for (i = 0; i < input.length; i++) {
      if (input[i] === 0) {
        if (start === null) {
          start = i;
          len = 1;
        } else {
          len++;
        }
      } else if (start !== null) {
        if (len > elLen) {
          elStart = start;
          elLen = len;
        }
        start = null;
      }
    }
    /* capturing last potential zero */
    if (start !== null && len > elLen) {
      elStart = start;
      elLen = len;
    }
  }

  var output = [];
  var num;
  for (i = 0; i < input.length; i++) {
    if (elStart !== null) {
      if (i === elStart) {
        if (elLen === 8) {
          /* all-zeroes is just '::' */
          return ['::'];
        } else if (elStart === 0 || elStart + elLen === input.length) {
          /*
           * For elided zeroes at the beginning/end of the address, an extra
           * ':' is needed during the join step.
           */
          output.push(':');
        } else {
          output.push('');
        }
      }
      if (i >= elStart && i < elStart + elLen) {
        continue;
      }
    }
    num = input[i].toString(16);
    if (zeroPad && num.length != 4) {
      num = '0000'.slice(num.length) + num;
    }
    output.push(num);
  }
  return output;
}

function _ipv4Mapped(input) {
  var comp = [0, 0, 0, 0, 0, 0xffff];
  var i;
  for (i = 0; i < 6; i++) {
    if (input[i] != comp[i]) return false;
  }
  return true;
}

function _prefixToAddr(len) {
  assert.number(len);
  len = len | 0;
  assert.ok(len <= 128);
  assert.ok(len >= 0);

  var output = new Addr();
  var i;
  for (i = 0; len > 16; i++, len -= 16) {
    output._fields[i] = 0xffff;
  }
  if (len > 0) {
    output._fields[i] = 0xffff - ((1 << 16 - len) - 1);
  }
  return output;
}

function _toCIDR(input) {
  if (typeof input === 'string') {
    return new CIDR(input);
  } else if (input instanceof CIDR) {
    return input;
  } else {
    throw new Error('Invalid argument: CIDR or parsable string expected');
  }
}

var strDefaults = {
  format: 'auto', // Control format of printed address
  zeroElide: true, // Elide longest run of zeros
  zeroPad: false // Pad with zeros when a group would print as < 4 chars
};

function getStrOpt(opts, name) {
  if (opts && opts.hasOwnProperty(name)) {
    return opts[name];
  } else {
    return strDefaults[name];
  }
}

///--- Public Classes

/**
 * IPv6/IPv4 address representation.
 *
 * It should not be instantiated directly by library consumers.
 */
function Addr() {
  this._fields = [0, 0, 0, 0, 0, 0, 0, 0];
  this._attrs = {};
}

Addr.prototype.kind = function getKind() {
  if (v4subnet.contains(this)) {
    return 'ipv4';
  } else {
    return 'ipv6';
  }
};

Addr.prototype.toString = function toString(opts) {
  assert.optionalObject(opts, 'opts');
  var format = getStrOpt(opts, 'format');
  var zeroElide = getStrOpt(opts, 'zeroElide');
  var zeroPad = getStrOpt(opts, 'zeroPad');

  assert.string(format, 'opts.format');
  assert.bool(zeroElide, 'opts.zeroElide');
  assert.bool(zeroPad, 'opts.zeroPad');

  // Try to print the address the way it was originally formatted
  if (format === 'auto') {
    if (this._attrs.ipv4Bare) {
      format = 'v4';
    } else if (this._attrs.ipv4Mapped) {
      format = 'v4-mapped';
    } else {
      format = 'v6';
    }
  }

  switch (format) {
    // Print in dotted-quad notation (but only if truly IPv4)
    case 'v4':
      if (!v4subnet.contains(this)) {
        throw new Error('cannot print non-v4 address in dotted quad notation');
      }
      return _arrayToOctetString(this._fields.slice(6));

    // Print as an IPv4-mapped IPv6 address
    case 'v4-mapped':
      if (!v4subnet.contains(this)) {
        throw new Error('cannot print non-v4 address as a v4-mapped address');
      }
      var output = _arrayToHex(this._fields.slice(0, 6), zeroElide, zeroPad);
      output.push(_arrayToOctetString(this._fields.slice(6)));
      return output.join(':');

    // Print as an IPv6 address
    case 'v6':
      return _arrayToHex(this._fields, zeroElide, zeroPad).join(':');

    // Unrecognized formatting method
    default:
      throw new Error('unrecognized format method "' + format + '"');
  }
};

Addr.prototype.toBuffer = function toBuffer(buf) {
  if (buf !== undefined) {
    if (!Buffer.isBuffer(buf)) {
      throw new Error('optional arg must be Buffer');
    }
  } else {
    buf = new Buffer(16);
  }
  var i;
  for (i = 0; i < 8; i++) {
    buf.writeUInt16BE(this._fields[i], i * 2);
  }
  return buf;
};

Addr.prototype.toLong = function toLong() {
  if (!v4subnet.contains(this)) {
    throw new Error('only possible for ipv4-mapped addresses');
  }
  return (this._fields[6] << 16 >>> 0) + this._fields[7];
};

Addr.prototype.clone = function cloneAddr() {
  var out = new Addr();
  out._fields = this._fields.slice();
  for (var k in this._attrs) {
    out._attrs[k] = this._attrs[k];
  }
  return out;
};

Addr.prototype.offset = function offset(num) {
  if (num < -4294967295 || num > 4294967295) {
    throw new Error('offsets should be between -4294967295 and 4294967295');
  }
  var out = this.clone();
  var i, moved;
  for (i = 7; i >= 0; i--) {
    moved = out._fields[i] + num;
    if (moved > 65535) {
      num = moved >>> 16;
      moved = moved & 0xffff;
    } else if (moved < 0) {
      num = Math.floor(moved / (1 << 16));
      moved = modulo(moved, 1 << 16);
    } else {
      num = 0;
    }
    out._fields[i] = moved;

    /* Prevent wrap-around for both ipv6 and ipv4-mapped addresses */
    if (num !== 0) {
      if (i === 0 || i === 6 && this._attrs.ipv4Mapped) {
        return null;
      }
    } else {
      break;
    }
  }
  return out;
};

Addr.prototype.and = function addrAnd(input) {
  input = _toAddr(input);
  var i;
  var output = this.clone();
  for (i = 0; i < 8; i++) {
    output._fields[i] = output._fields[i] & input._fields[i];
  }
  return output;
};

Addr.prototype.or = function addrOr(input) {
  input = _toAddr(input);
  var i;
  var output = this.clone();
  for (i = 0; i < 8; i++) {
    output._fields[i] = output._fields[i] | input._fields[i];
  }
  return output;
};

Addr.prototype.not = function addrNot() {
  var i;
  var output = this.clone();
  for (i = 0; i < 8; i++) {
    output._fields[i] = ~output._fields[i] & 0xffff;
  }
  return output;
};

Addr.prototype.compare = function compareMember(addr) {
  return ip6addrCompare(this, addr);
};

/**
 * CIDR Block
 * @param addr CIDR network address
 * @param prefixLen Length of network prefix
 *
 * The addr parameter can be an Addr object or a parseable string.
 * If prefixLen is omitted, then addr must contain a parseable string in the
 * form '<address>/<prefix>'.
 */
function CIDR(addr, prefixLen) {
  if (prefixLen === undefined) {
    /* OK to pass pass string of "<addr>/<prefix>" */
    assert.string(addr);
    var fields = addr.match(/^([a-fA-F0-9:.]+)\/([0-9]+)$/);
    if (fields === null) {
      throw new Error('Invalid argument: <addr>/<prefix> expected');
    }
    addr = fields[1];
    prefixLen = parseInt(fields[2], 10);
  }
  assert.number(prefixLen);
  prefixLen = prefixLen | 0;
  addr = _toAddr(addr);

  /* Expand prefix to ipv6 length of bare ipv4 address provided */
  if (addr._attrs.ipv4Bare) {
    prefixLen += 96;
  }
  if (prefixLen < 0 || prefixLen > 128) {
    throw new Error('Invalid prefix length');
  }
  this._prefix = prefixLen;
  this._mask = _prefixToAddr(prefixLen);
  this._addr = addr.and(this._mask);
}

CIDR.prototype.contains = function cidrContains(input) {
  input = _toAddr(input);
  return this._addr.compare(input.and(this._mask)) === 0;
};

CIDR.prototype.first = function cidrFirst() {
  if (this._prefix >= 127) {
    /* Support single-address and point-to-point networks */
    return this._addr;
  } else {
    return this._addr.offset(1);
  }
};

CIDR.prototype.last = function cidrLast() {
  var ending = this._addr.or(this._mask.not());
  if (this._prefix >= 127) {
    /* Support single-address and point-to-point networks */
    return ending;
  } else {
    if (this._addr._attrs.ipv4Mapped) {
      /* don't include the broadcast for ipv4 */
      return ending.offset(-1);
    } else {
      return ending;
    }
  }
};

CIDR.prototype.broadcast = function getBroadcast() {
  if (!v4subnet.contains(this._addr)) {
    throw new Error('Only IPv4 networks have broadcast addresses');
  }
  return this._addr.or(this._mask.not());
};

CIDR.prototype.compare = function compareCIDR(cidr) {
  return ip6cidrCompare(this, cidr);
};

CIDR.prototype.prefixLength = function getPrefixLength(format) {
  assert.optionalString(format, 'format');
  if (format === undefined || format === 'auto') {
    format = this._addr._attrs.ipv4Bare ? 'v4' : 'v6';
  }

  switch (format) {
    case 'v4':
      if (!v4subnet.contains(this._addr)) {
        throw new Error('cannot return v4 prefix length for non-v4 address');
      }
      return this._prefix - 96;
    case 'v6':
      return this._prefix;
    default:
      throw new Error('unrecognized format method "' + format + '"');
  }
};

CIDR.prototype.address = function getAddressComponent() {
  return this._addr;
};

CIDR.prototype.toString = function cidrString(opts) {
  assert.optionalObject(opts, 'opts');

  var format = getStrOpt(opts, 'format');
  if (format === 'v4-mapped') {
    format = 'v6';
  }

  return this._addr.toString(opts) + '/' + this.prefixLength(format);
};

var v4subnet = new CIDR('::ffff:0:0', 96);

function ip6cidrCompare(a, b) {
  a = _toCIDR(a);
  b = _toCIDR(b);

  /*
   * We compare first on the address component, and then on the prefix length,
   * such that the network with the smaller prefix length (the larger subnet)
   * is greater than the network with the larger prefix (the smaller subnet).
   * This is the same ordering used in Postgres.
   */
  var cmp = ip6addrCompare(a._addr, b._addr);
  return cmp === 0 ? b._prefix - a._prefix : cmp;
}

/**
 * Range of addresses.
 * @param begin Beginning address of the range
 * @param end Ending address of the range
 *
 * Parameters can be Addr objects or parsable address strings.
 */
function AddrRange(begin, end) {
  begin = _toAddr(begin);
  end = _toAddr(end);

  if (begin.compare(end) > 0) {
    throw new Error('begin address must be <= end address');
  }

  this._begin = begin;
  this._end = end;
}

AddrRange.prototype.contains = function addrRangeContains(input) {
  input = _toAddr(input);
  return this._begin.compare(input) <= 0 && this._end.compare(input) >= 0;
};

AddrRange.prototype.first = function addrRangeFirst() {
  return this._begin;
};

AddrRange.prototype.last = function addrRangeLast() {
  return this._end;
};

///--- Public Functions

function ip6addrParse(input) {
  if (typeof input === 'string') {
    return parseString(input);
  } else if (typeof input === 'number') {
    return parseLong(input);
  } else if ((typeof input === 'undefined' ? 'undefined' : (0, _typeof3.default)(input)) === 'object' && _isAddr(input)) {
    return input;
  } else {
    throw new Error('Invalid argument: only string|number allowed');
  }
}

function parseString(input) {
  assert.string(input);
  input = input.toLowerCase();
  var result = new Addr();

  var ip6Fields = []; // hold unparsed hex fields
  var ip4Fields = []; // hold unparsed decimal fields
  var expIndex = null; // field index of '::' delimiter
  var value = ''; // accumulate unparsed hex/dec field
  var i, c;

  /*
   * No valid ipv6 is longer than 39 characters.
   * An extra character of leeway is there to tolerate some :: funny business.
   */
  if (input.length > 40) {
    throw new ParseError(input, 'Input too long');
  }

  for (i = 0; i < input.length; i++) {
    c = input[i];
    if (c === ':') {
      if (i + 1 < input.length && input[i + 1] === ':') {
        /*
         * Variable length '::' delimiter.
         * Multiples would be ambiguous
         */
        if (expIndex !== null) {
          throw new ParseError(input, 'Multiple :: delimiters', i);
        }

        /*
         * The value buffer can be empty for cases where the '::' delimiter is
         * the first portion of the address.
         */
        if (value !== '') {
          ip6Fields.push(value);
          value = '';
        }
        expIndex = ip6Fields.length;
        i++;
      } else {
        /*
         * Standard ':' delimiter
         * The value buffer cannot be empty since that would imply an illegal
         * pattern such as ':::' or ':.'.
         */
        if (value === '') {
          throw new ParseError(input, 'illegal delimiter', i);
        }
        ip6Fields.push(value);
        value = '';
      }
    } else if (c === '.') {
      /*
       * Handle dotted quad notation for ipv4 and ipv4-mapped addresses.
       */
      ip4Fields.push(value);
      value = '';
    } else {
      value = value + c;
    }
  }
  /* Handle the last stashed value */
  if (value !== '') {
    if (ip4Fields.length !== 0) {
      ip4Fields.push(value);
    } else {
      ip6Fields.push(value);
    }
    value = '';
  } else {
    /* With no stashed value, the address must end with '::'. */
    if (expIndex !== ip6Fields.length || ip4Fields.length > 0) {
      throw new ParseError(input, 'Cannot end with delimiter besides ::');
    }
  }

  /* With values collected, ensure we don't have too many/few */
  if (ip4Fields.length === 0) {
    if (ip6Fields.length > 8) {
      throw new ParseError(input, 'Too many fields');
    } else if (ip6Fields.length < 8 && expIndex === null) {
      throw new ParseError(input, 'Too few fields');
    }
  } else {
    if (ip4Fields.length !== 4) {
      throw new ParseError(input, 'IPv4 portion must have 4 fields');
    }
    /* If this is a bare IP address, implicitly convert to IPv4 mapped */
    if (ip6Fields.length === 0 && expIndex === null) {
      result._attrs.ipv4Bare = true;
      ip6Fields = ['ffff'];
      expIndex = 0;
    }

    if (ip6Fields.length > 6) {
      throw new ParseError(input, 'Too many fields');
    } else if (ip6Fields.length < 6 && expIndex === null) {
      throw new ParseError(input, 'Too few fields');
    }
  }

  /* Parse integer values */
  var field, num;
  for (i = 0; i < ip6Fields.length; i++) {
    field = ip6Fields[i];
    num = jsprim.parseInteger(field, { base: 16, allowSign: false });
    if (num instanceof Error || num < 0 || num > 65535) {
      throw new ParseError(input, 'Invalid field value: ' + field);
    }
    ip6Fields[i] = num;
  }
  for (i = 0; i < ip4Fields.length; i++) {
    field = ip4Fields[i];
    num = jsprim.parseInteger(field, { base: 10, allowSign: false });
    if (num instanceof Error || num < 0 || num > 255) {
      throw new ParseError(input, 'Invalid field value: ' + field);
    }
    ip4Fields[i] = num;
  }

  /* Collapse IPv4 portion, if necessary */
  if (ip4Fields.length !== 0) {
    ip6Fields.push(ip4Fields[0] * 256 + ip4Fields[1]);
    ip6Fields.push(ip4Fields[2] * 256 + ip4Fields[3]);
  }

  /* Expand '::' delimiter into implied 0s */
  if (ip6Fields.length < 8 && expIndex !== null) {
    var filler = [];
    for (i = 0; i < 8 - ip6Fields.length; i++) {
      filler.push(0);
    }
    ip6Fields = Array.prototype.concat(ip6Fields.slice(0, expIndex), filler, ip6Fields.slice(expIndex));
  }

  /*
   * If dotted-quad notation was used, ensure the input was either a bare ipv4
   * address or a valid ipv4-mapped address.
   */
  if (ip4Fields.length !== 0) {
    if (!_ipv4Mapped(ip6Fields)) {
      throw new ParseError(input, 'invalid dotted-quad notation');
    } else {
      result._attrs.ipv4Mapped = true;
    }
  }

  result._fields = ip6Fields;

  return result;
}

function parseLong(input) {
  assert.number(input);
  if (input !== Math.floor(input)) {
    throw new Error('Value must be integer');
  }
  if (input < 0 || input > 0xffffffff) {
    throw new Error('Value must be 32 bit');
  }
  var out = new Addr();
  out._fields[7] = input & 0xffff;
  out._fields[6] = input >>> 16;
  /* this is ipv4-mapped */
  out._fields[5] = 0xffff;
  out._attrs.ipv4Bare = true;
  out._attrs.ipv4Mapped = true;
  return out;
}

/**
 * Compare Addr objects in a manner suitable for Array.sort().
 */
function ip6addrCompare(a, b) {
  a = _toAddr(a);
  b = _toAddr(b);

  var i;
  for (i = 0; i < 8; i++) {
    if (a._fields[i] < b._fields[i]) {
      return -1;
    } else if (a._fields[i] > b._fields[i]) {
      return 1;
    }
  }
  return 0;
}

///--- Exports

module.exports = {
  parse: ip6addrParse,
  compare: ip6addrCompare,
  createCIDR: function createCIDR(addr, len) {
    return new CIDR(addr, len);
  },
  compareCIDR: ip6cidrCompare,
  createAddrRange: function createAddrRange(begin, end) {
    return new AddrRange(begin, end);
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),

/***/ "./node_modules/json-schema/lib/validate.js":
/*!**************************************************!*\
  !*** ./node_modules/json-schema/lib/validate.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * JSONSchema Validator - Validates JavaScript objects using JSON Schemas
 *	(http://www.json.com/json-schema-proposal/)
 *
 * Copyright (c) 2007 Kris Zyp SitePen (www.sitepen.com)
 * Licensed under the MIT (MIT-LICENSE.txt) license.
To use the validator call the validate function with an instance object and an optional schema object.
If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
that schema will be used to validate and the schema parameter is not necessary (if both exist,
both validations will occur).
The validate method will return an array of validation errors. If there are no errors, then an
empty list will be returned. A validation error will have two properties:
"property" which indicates which property had the error
"message" which indicates what the error was
 */
(function (root, factory) {
	if (true) {
		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return factory();
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
})(undefined, function () {
	// setup primitive classes to be JSON Schema types
	var exports = validate;
	exports.Integer = { type: "integer" };
	var primitiveConstructors = {
		String: String,
		Boolean: Boolean,
		Number: Number,
		Object: Object,
		Array: Array,
		Date: Date
	};
	exports.validate = validate;
	function validate( /*Any*/instance, /*Object*/schema) {
		// Summary:
		//  	To use the validator call JSONSchema.validate with an instance object and an optional schema object.
		// 		If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
		// 		that schema will be used to validate and the schema parameter is not necessary (if both exist,
		// 		both validations will occur).
		// 		The validate method will return an object with two properties:
		// 			valid: A boolean indicating if the instance is valid by the schema
		// 			errors: An array of validation errors. If there are no errors, then an
		// 					empty list will be returned. A validation error will have two properties:
		// 						property: which indicates which property had the error
		// 						message: which indicates what the error was
		//
		return validate(instance, schema, { changing: false }); //, coerce: false, existingOnly: false});
	};
	exports.checkPropertyChange = function ( /*Any*/value, /*Object*/schema, /*String*/property) {
		// Summary:
		// 		The checkPropertyChange method will check to see if an value can legally be in property with the given schema
		// 		This is slightly different than the validate method in that it will fail if the schema is readonly and it will
		// 		not check for self-validation, it is assumed that the passed in value is already internally valid.
		// 		The checkPropertyChange method will return the same object type as validate, see JSONSchema.validate for
		// 		information.
		//
		return validate(value, schema, { changing: property || "property" });
	};
	var validate = exports._validate = function ( /*Any*/instance, /*Object*/schema, /*Object*/options) {

		if (!options) options = {};
		var _changing = options.changing;

		function getType(schema) {
			return schema.type || primitiveConstructors[schema.name] == schema && schema.name.toLowerCase();
		}
		var errors = [];
		// validate a value against a property definition
		function checkProp(value, schema, path, i) {

			var l;
			path += path ? typeof i == 'number' ? '[' + i + ']' : typeof i == 'undefined' ? '' : '.' + i : i;
			function addError(message) {
				errors.push({ property: path, message: message });
			}

			if (((typeof schema === 'undefined' ? 'undefined' : (0, _typeof3.default)(schema)) != 'object' || schema instanceof Array) && (path || typeof schema != 'function') && !(schema && getType(schema))) {
				if (typeof schema == 'function') {
					if (!(value instanceof schema)) {
						addError("is not an instance of the class/constructor " + schema.name);
					}
				} else if (schema) {
					addError("Invalid schema/property definition " + schema);
				}
				return null;
			}
			if (_changing && schema.readonly) {
				addError("is a readonly field, it can not be changed");
			}
			if (schema['extends']) {
				// if it extends another schema, it must pass that schema as well
				checkProp(value, schema['extends'], path, i);
			}
			// validate a value against a type definition
			function checkType(type, value) {
				if (type) {
					if (typeof type == 'string' && type != 'any' && (type == 'null' ? value !== null : (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) != type) && !(value instanceof Array && type == 'array') && !(value instanceof Date && type == 'date') && !(type == 'integer' && value % 1 === 0)) {
						return [{ property: path, message: (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) + " value found, but a " + type + " is required" }];
					}
					if (type instanceof Array) {
						var unionErrors = [];
						for (var j = 0; j < type.length; j++) {
							// a union type
							if (!(unionErrors = checkType(type[j], value)).length) {
								break;
							}
						}
						if (unionErrors.length) {
							return unionErrors;
						}
					} else if ((typeof type === 'undefined' ? 'undefined' : (0, _typeof3.default)(type)) == 'object') {
						var priorErrors = errors;
						errors = [];
						checkProp(value, type, path);
						var theseErrors = errors;
						errors = priorErrors;
						return theseErrors;
					}
				}
				return [];
			}
			if (value === undefined) {
				if (schema.required) {
					addError("is missing and it is required");
				}
			} else {
				errors = errors.concat(checkType(getType(schema), value));
				if (schema.disallow && !checkType(schema.disallow, value).length) {
					addError(" disallowed value was matched");
				}
				if (value !== null) {
					if (value instanceof Array) {
						if (schema.items) {
							var itemsIsArray = schema.items instanceof Array;
							var propDef = schema.items;
							for (i = 0, l = value.length; i < l; i += 1) {
								if (itemsIsArray) propDef = schema.items[i];
								if (options.coerce) value[i] = options.coerce(value[i], propDef);
								errors.concat(checkProp(value[i], propDef, path, i));
							}
						}
						if (schema.minItems && value.length < schema.minItems) {
							addError("There must be a minimum of " + schema.minItems + " in the array");
						}
						if (schema.maxItems && value.length > schema.maxItems) {
							addError("There must be a maximum of " + schema.maxItems + " in the array");
						}
					} else if (schema.properties || schema.additionalProperties) {
						errors.concat(checkObj(value, schema.properties, path, schema.additionalProperties));
					}
					if (schema.pattern && typeof value == 'string' && !value.match(schema.pattern)) {
						addError("does not match the regex pattern " + schema.pattern);
					}
					if (schema.maxLength && typeof value == 'string' && value.length > schema.maxLength) {
						addError("may only be " + schema.maxLength + " characters long");
					}
					if (schema.minLength && typeof value == 'string' && value.length < schema.minLength) {
						addError("must be at least " + schema.minLength + " characters long");
					}
					if ((0, _typeof3.default)(schema.minimum) !== undefined && (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) == (0, _typeof3.default)(schema.minimum) && schema.minimum > value) {
						addError("must have a minimum value of " + schema.minimum);
					}
					if ((0, _typeof3.default)(schema.maximum) !== undefined && (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) == (0, _typeof3.default)(schema.maximum) && schema.maximum < value) {
						addError("must have a maximum value of " + schema.maximum);
					}
					if (schema['enum']) {
						var enumer = schema['enum'];
						l = enumer.length;
						var found;
						for (var j = 0; j < l; j++) {
							if (enumer[j] === value) {
								found = 1;
								break;
							}
						}
						if (!found) {
							addError("does not have a value in the enumeration " + enumer.join(", "));
						}
					}
					if (typeof schema.maxDecimal == 'number' && value.toString().match(new RegExp("\\.[0-9]{" + (schema.maxDecimal + 1) + ",}"))) {
						addError("may only have " + schema.maxDecimal + " digits of decimal places");
					}
				}
			}
			return null;
		}
		// validate an object against a schema
		function checkObj(instance, objTypeDef, path, additionalProp) {

			if ((typeof objTypeDef === 'undefined' ? 'undefined' : (0, _typeof3.default)(objTypeDef)) == 'object') {
				if ((typeof instance === 'undefined' ? 'undefined' : (0, _typeof3.default)(instance)) != 'object' || instance instanceof Array) {
					errors.push({ property: path, message: "an object is required" });
				}

				for (var i in objTypeDef) {
					if (objTypeDef.hasOwnProperty(i)) {
						var value = instance[i];
						// skip _not_ specified properties
						if (value === undefined && options.existingOnly) continue;
						var propDef = objTypeDef[i];
						// set default
						if (value === undefined && propDef["default"]) {
							value = instance[i] = propDef["default"];
						}
						if (options.coerce && i in instance) {
							value = instance[i] = options.coerce(value, propDef);
						}
						checkProp(value, propDef, path, i);
					}
				}
			}
			for (i in instance) {
				if (instance.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_') && objTypeDef && !objTypeDef[i] && additionalProp === false) {
					if (options.filter) {
						delete instance[i];
						continue;
					} else {
						errors.push({ property: path, message: (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) + "The property " + i + " is not defined in the schema and the schema does not allow additional properties" });
					}
				}
				var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
				if (requires && !(requires in instance)) {
					errors.push({ property: path, message: "the presence of the property " + i + " requires that " + requires + " also be present" });
				}
				value = instance[i];
				if (additionalProp && (!(objTypeDef && (typeof objTypeDef === 'undefined' ? 'undefined' : (0, _typeof3.default)(objTypeDef)) == 'object') || !(i in objTypeDef))) {
					if (options.coerce) {
						value = instance[i] = options.coerce(value, additionalProp);
					}
					checkProp(value, additionalProp, path, i);
				}
				if (!_changing && value && value.$schema) {
					errors = errors.concat(checkProp(value, value.$schema, path, i));
				}
			}
			return errors;
		}
		if (schema) {
			checkProp(instance, schema, '', _changing || '');
		}
		if (!_changing && instance && instance.$schema) {
			checkProp(instance, instance.$schema, '', '');
		}
		return { valid: !errors.length, errors: errors };
	};
	exports.mustBeValid = function (result) {
		//	summary:
		//		This checks to ensure that the result is valid and will throw an appropriate error message if it is not
		// result: the result returned from checkPropertyChange or validate
		if (!result.valid) {
			throw new TypeError(result.errors.map(function (error) {
				return "for property " + error.property + ': ' + error.message;
			}).join(", \n"));
		}
	};

	return exports;
});

/***/ }),

/***/ "./node_modules/jsprim/lib/jsprim.js":
/*!*******************************************!*\
  !*** ./node_modules/jsprim/lib/jsprim.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ "./node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

var _minSafeInteger = __webpack_require__(/*! babel-runtime/core-js/number/min-safe-integer */ "./node_modules/babel-runtime/core-js/number/min-safe-integer.js");

var _minSafeInteger2 = _interopRequireDefault(_minSafeInteger);

var _maxSafeInteger = __webpack_require__(/*! babel-runtime/core-js/number/max-safe-integer */ "./node_modules/babel-runtime/core-js/number/max-safe-integer.js");

var _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * lib/jsprim.js: utilities for primitive JavaScript types
 */

var mod_assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var mod_util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

var mod_extsprintf = __webpack_require__(/*! extsprintf */ "./node_modules/extsprintf/lib/extsprintf.js");
var mod_verror = __webpack_require__(/*! verror */ "./node_modules/verror/lib/verror.js");
var mod_jsonschema = __webpack_require__(/*! json-schema */ "./node_modules/json-schema/lib/validate.js");

/*
 * Public interface
 */
exports.deepCopy = deepCopy;
exports.deepEqual = deepEqual;
exports.isEmpty = isEmpty;
exports.hasKey = hasKey;
exports.forEachKey = forEachKey;
exports.pluck = pluck;
exports.flattenObject = flattenObject;
exports.flattenIter = flattenIter;
exports.validateJsonObject = validateJsonObjectJS;
exports.validateJsonObjectJS = validateJsonObjectJS;
exports.randElt = randElt;
exports.extraProperties = extraProperties;
exports.mergeObjects = mergeObjects;

exports.startsWith = startsWith;
exports.endsWith = endsWith;

exports.parseInteger = parseInteger;

exports.iso8601 = iso8601;
exports.rfc1123 = rfc1123;
exports.parseDateTime = parseDateTime;

exports.hrtimediff = hrtimeDiff;
exports.hrtimeDiff = hrtimeDiff;
exports.hrtimeAccum = hrtimeAccum;
exports.hrtimeAdd = hrtimeAdd;
exports.hrtimeNanosec = hrtimeNanosec;
exports.hrtimeMicrosec = hrtimeMicrosec;
exports.hrtimeMillisec = hrtimeMillisec;

/*
 * Deep copy an acyclic *basic* Javascript object.  This only handles basic
 * scalars (strings, numbers, booleans) and arbitrarily deep arrays and objects
 * containing these.  This does *not* handle instances of other classes.
 */
function deepCopy(obj) {
	var ret, key;
	var marker = '__deepCopy';

	if (obj && obj[marker]) throw new Error('attempted deep copy of cyclic object');

	if (obj && obj.constructor == Object) {
		ret = {};
		obj[marker] = true;

		for (key in obj) {
			if (key == marker) continue;

			ret[key] = deepCopy(obj[key]);
		}

		delete obj[marker];
		return ret;
	}

	if (obj && obj.constructor == Array) {
		ret = [];
		obj[marker] = true;

		for (key = 0; key < obj.length; key++) {
			ret.push(deepCopy(obj[key]));
		}delete obj[marker];
		return ret;
	}

	/*
  * It must be a primitive type -- just return it.
  */
	return obj;
}

function deepEqual(obj1, obj2) {
	if ((typeof obj1 === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj1)) != (typeof obj2 === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj2))) return false;

	if (obj1 === null || obj2 === null || (typeof obj1 === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj1)) != 'object') return obj1 === obj2;

	if (obj1.constructor != obj2.constructor) return false;

	var k;
	for (k in obj1) {
		if (!obj2.hasOwnProperty(k)) return false;

		if (!deepEqual(obj1[k], obj2[k])) return false;
	}

	for (k in obj2) {
		if (!obj1.hasOwnProperty(k)) return false;
	}

	return true;
}

function isEmpty(obj) {
	var key;
	for (key in obj) {
		return false;
	}return true;
}

function hasKey(obj, key) {
	mod_assert.equal(typeof key === 'undefined' ? 'undefined' : (0, _typeof3.default)(key), 'string');
	return Object.prototype.hasOwnProperty.call(obj, key);
}

function forEachKey(obj, callback) {
	for (var key in obj) {
		if (hasKey(obj, key)) {
			callback(key, obj[key]);
		}
	}
}

function pluck(obj, key) {
	mod_assert.equal(typeof key === 'undefined' ? 'undefined' : (0, _typeof3.default)(key), 'string');
	return pluckv(obj, key);
}

function pluckv(obj, key) {
	if (obj === null || (typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) !== 'object') return undefined;

	if (obj.hasOwnProperty(key)) return obj[key];

	var i = key.indexOf('.');
	if (i == -1) return undefined;

	var key1 = key.substr(0, i);
	if (!obj.hasOwnProperty(key1)) return undefined;

	return pluckv(obj[key1], key.substr(i + 1));
}

/*
 * Invoke callback(row) for each entry in the array that would be returned by
 * flattenObject(data, depth).  This is just like flattenObject(data,
 * depth).forEach(callback), except that the intermediate array is never
 * created.
 */
function flattenIter(data, depth, callback) {
	doFlattenIter(data, depth, [], callback);
}

function doFlattenIter(data, depth, accum, callback) {
	var each;
	var key;

	if (depth === 0) {
		each = accum.slice(0);
		each.push(data);
		callback(each);
		return;
	}

	mod_assert.ok(data !== null);
	mod_assert.equal(typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data), 'object');
	mod_assert.equal(typeof depth === 'undefined' ? 'undefined' : (0, _typeof3.default)(depth), 'number');
	mod_assert.ok(depth >= 0);

	for (key in data) {
		each = accum.slice(0);
		each.push(key);
		doFlattenIter(data[key], depth - 1, each, callback);
	}
}

function flattenObject(data, depth) {
	if (depth === 0) return [data];

	mod_assert.ok(data !== null);
	mod_assert.equal(typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data), 'object');
	mod_assert.equal(typeof depth === 'undefined' ? 'undefined' : (0, _typeof3.default)(depth), 'number');
	mod_assert.ok(depth >= 0);

	var rv = [];
	var key;

	for (key in data) {
		flattenObject(data[key], depth - 1).forEach(function (p) {
			rv.push([key].concat(p));
		});
	}

	return rv;
}

function startsWith(str, prefix) {
	return str.substr(0, prefix.length) == prefix;
}

function endsWith(str, suffix) {
	return str.substr(str.length - suffix.length, suffix.length) == suffix;
}

function iso8601(d) {
	if (typeof d == 'number') d = new Date(d);
	mod_assert.ok(d.constructor === Date);
	return mod_extsprintf.sprintf('%4d-%02d-%02dT%02d:%02d:%02d.%03dZ', d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
}

var RFC1123_MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
var RFC1123_DAYS = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

function rfc1123(date) {
	return mod_extsprintf.sprintf('%s, %02d %s %04d %02d:%02d:%02d GMT', RFC1123_DAYS[date.getUTCDay()], date.getUTCDate(), RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
}

/*
 * Parses a date expressed as a string, as either a number of milliseconds since
 * the epoch or any string format that Date accepts, giving preference to the
 * former where these two sets overlap (e.g., small numbers).
 */
function parseDateTime(str) {
	/*
  * This is irritatingly implicit, but significantly more concise than
  * alternatives.  The "+str" will convert a string containing only a
  * number directly to a Number, or NaN for other strings.  Thus, if the
  * conversion succeeds, we use it (this is the milliseconds-since-epoch
  * case).  Otherwise, we pass the string directly to the Date
  * constructor to parse.
  */
	var numeric = +str;
	if (!isNaN(numeric)) {
		return new Date(numeric);
	} else {
		return new Date(str);
	}
}

/*
 * Number.*_SAFE_INTEGER isn't present before node v0.12, so we hardcode
 * the ES6 definitions here, while allowing for them to someday be higher.
 */
var MAX_SAFE_INTEGER = _maxSafeInteger2.default || 9007199254740991;
var MIN_SAFE_INTEGER = _minSafeInteger2.default || -9007199254740991;

/*
 * Default options for parseInteger().
 */
var PI_DEFAULTS = {
	base: 10,
	allowSign: true,
	allowPrefix: false,
	allowTrailing: false,
	allowImprecise: false,
	trimWhitespace: false,
	leadingZeroIsOctal: false
};

var CP_0 = 0x30;
var CP_9 = 0x39;

var CP_A = 0x41;
var CP_B = 0x42;
var CP_O = 0x4f;
var CP_T = 0x54;
var CP_X = 0x58;
var CP_Z = 0x5a;

var CP_a = 0x61;
var CP_b = 0x62;
var CP_o = 0x6f;
var CP_t = 0x74;
var CP_x = 0x78;
var CP_z = 0x7a;

var PI_CONV_DEC = 0x30;
var PI_CONV_UC = 0x37;
var PI_CONV_LC = 0x57;

/*
 * A stricter version of parseInt() that provides options for changing what
 * is an acceptable string (for example, disallowing trailing characters).
 */
function parseInteger(str, uopts) {
	mod_assert.string(str, 'str');
	mod_assert.optionalObject(uopts, 'options');

	var baseOverride = false;
	var options = PI_DEFAULTS;

	if (uopts) {
		baseOverride = hasKey(uopts, 'base');
		options = mergeObjects(options, uopts);
		mod_assert.number(options.base, 'options.base');
		mod_assert.ok(options.base >= 2, 'options.base >= 2');
		mod_assert.ok(options.base <= 36, 'options.base <= 36');
		mod_assert.bool(options.allowSign, 'options.allowSign');
		mod_assert.bool(options.allowPrefix, 'options.allowPrefix');
		mod_assert.bool(options.allowTrailing, 'options.allowTrailing');
		mod_assert.bool(options.allowImprecise, 'options.allowImprecise');
		mod_assert.bool(options.trimWhitespace, 'options.trimWhitespace');
		mod_assert.bool(options.leadingZeroIsOctal, 'options.leadingZeroIsOctal');

		if (options.leadingZeroIsOctal) {
			mod_assert.ok(!baseOverride, '"base" and "leadingZeroIsOctal" are ' + 'mutually exclusive');
		}
	}

	var c;
	var pbase = -1;
	var base = options.base;
	var start;
	var mult = 1;
	var value = 0;
	var idx = 0;
	var len = str.length;

	/* Trim any whitespace on the left side. */
	if (options.trimWhitespace) {
		while (idx < len && isSpace(str.charCodeAt(idx))) {
			++idx;
		}
	}

	/* Check the number for a leading sign. */
	if (options.allowSign) {
		if (str[idx] === '-') {
			idx += 1;
			mult = -1;
		} else if (str[idx] === '+') {
			idx += 1;
		}
	}

	/* Parse the base-indicating prefix if there is one. */
	if (str[idx] === '0') {
		if (options.allowPrefix) {
			pbase = prefixToBase(str.charCodeAt(idx + 1));
			if (pbase !== -1 && (!baseOverride || pbase === base)) {
				base = pbase;
				idx += 2;
			}
		}

		if (pbase === -1 && options.leadingZeroIsOctal) {
			base = 8;
		}
	}

	/* Parse the actual digits. */
	for (start = idx; idx < len; ++idx) {
		c = translateDigit(str.charCodeAt(idx));
		if (c !== -1 && c < base) {
			value *= base;
			value += c;
		} else {
			break;
		}
	}

	/* If we didn't parse any digits, we have an invalid number. */
	if (start === idx) {
		return new Error('invalid number: ' + (0, _stringify2.default)(str));
	}

	/* Trim any whitespace on the right side. */
	if (options.trimWhitespace) {
		while (idx < len && isSpace(str.charCodeAt(idx))) {
			++idx;
		}
	}

	/* Check for trailing characters. */
	if (idx < len && !options.allowTrailing) {
		return new Error('trailing characters after number: ' + (0, _stringify2.default)(str.slice(idx)));
	}

	/* If our value is 0, we return now, to avoid returning -0. */
	if (value === 0) {
		return 0;
	}

	/* Calculate our final value. */
	var result = value * mult;

	/*
  * If the string represents a value that cannot be precisely represented
  * by JavaScript, then we want to check that:
  *
  * - We never increased the value past MAX_SAFE_INTEGER
  * - We don't make the result negative and below MIN_SAFE_INTEGER
  *
  * Because we only ever increment the value during parsing, there's no
  * chance of moving past MAX_SAFE_INTEGER and then dropping below it
  * again, losing precision in the process. This means that we only need
  * to do our checks here, at the end.
  */
	if (!options.allowImprecise && (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)) {
		return new Error('number is outside of the supported range: ' + (0, _stringify2.default)(str.slice(start, idx)));
	}

	return result;
}

/*
 * Interpret a character code as a base-36 digit.
 */
function translateDigit(d) {
	if (d >= CP_0 && d <= CP_9) {
		/* '0' to '9' -> 0 to 9 */
		return d - PI_CONV_DEC;
	} else if (d >= CP_A && d <= CP_Z) {
		/* 'A' - 'Z' -> 10 to 35 */
		return d - PI_CONV_UC;
	} else if (d >= CP_a && d <= CP_z) {
		/* 'a' - 'z' -> 10 to 35 */
		return d - PI_CONV_LC;
	} else {
		/* Invalid character code */
		return -1;
	}
}

/*
 * Test if a value matches the ECMAScript definition of trimmable whitespace.
 */
function isSpace(c) {
	return c === 0x20 || c >= 0x0009 && c <= 0x000d || c === 0x00a0 || c === 0x1680 || c === 0x180e || c >= 0x2000 && c <= 0x200a || c === 0x2028 || c === 0x2029 || c === 0x202f || c === 0x205f || c === 0x3000 || c === 0xfeff;
}

/*
 * Determine which base a character indicates (e.g., 'x' indicates hex).
 */
function prefixToBase(c) {
	if (c === CP_b || c === CP_B) {
		/* 0b/0B (binary) */
		return 2;
	} else if (c === CP_o || c === CP_O) {
		/* 0o/0O (octal) */
		return 8;
	} else if (c === CP_t || c === CP_T) {
		/* 0t/0T (decimal) */
		return 10;
	} else if (c === CP_x || c === CP_X) {
		/* 0x/0X (hexadecimal) */
		return 16;
	} else {
		/* Not a meaningful character */
		return -1;
	}
}

function validateJsonObjectJS(schema, input) {
	var report = mod_jsonschema.validate(input, schema);

	if (report.errors.length === 0) return null;

	/* Currently, we only do anything useful with the first error. */
	var error = report.errors[0];

	/* The failed property is given by a URI with an irrelevant prefix. */
	var propname = error['property'];
	var reason = error['message'].toLowerCase();
	var i, j;

	/*
  * There's at least one case where the property error message is
  * confusing at best.  We work around this here.
  */
	if ((i = reason.indexOf('the property ')) != -1 && (j = reason.indexOf(' is not defined in the schema and the ' + 'schema does not allow additional properties')) != -1) {
		i += 'the property '.length;
		if (propname === '') propname = reason.substr(i, j - i);else propname = propname + '.' + reason.substr(i, j - i);

		reason = 'unsupported property';
	}

	var rv = new mod_verror.VError('property "%s": %s', propname, reason);
	rv.jsv_details = error;
	return rv;
}

function randElt(arr) {
	mod_assert.ok(Array.isArray(arr) && arr.length > 0, 'randElt argument must be a non-empty array');

	return arr[Math.floor(Math.random() * arr.length)];
}

function assertHrtime(a) {
	mod_assert.ok(a[0] >= 0 && a[1] >= 0, 'negative numbers not allowed in hrtimes');
	mod_assert.ok(a[1] < 1e9, 'nanoseconds column overflow');
}

/*
 * Compute the time elapsed between hrtime readings A and B, where A is later
 * than B.  hrtime readings come from Node's process.hrtime().  There is no
 * defined way to represent negative deltas, so it's illegal to diff B from A
 * where the time denoted by B is later than the time denoted by A.  If this
 * becomes valuable, we can define a representation and extend the
 * implementation to support it.
 */
function hrtimeDiff(a, b) {
	assertHrtime(a);
	assertHrtime(b);
	mod_assert.ok(a[0] > b[0] || a[0] == b[0] && a[1] >= b[1], 'negative differences not allowed');

	var rv = [a[0] - b[0], 0];

	if (a[1] >= b[1]) {
		rv[1] = a[1] - b[1];
	} else {
		rv[0]--;
		rv[1] = 1e9 - (b[1] - a[1]);
	}

	return rv;
}

/*
 * Convert a hrtime reading from the array format returned by Node's
 * process.hrtime() into a scalar number of nanoseconds.
 */
function hrtimeNanosec(a) {
	assertHrtime(a);

	return Math.floor(a[0] * 1e9 + a[1]);
}

/*
 * Convert a hrtime reading from the array format returned by Node's
 * process.hrtime() into a scalar number of microseconds.
 */
function hrtimeMicrosec(a) {
	assertHrtime(a);

	return Math.floor(a[0] * 1e6 + a[1] / 1e3);
}

/*
 * Convert a hrtime reading from the array format returned by Node's
 * process.hrtime() into a scalar number of milliseconds.
 */
function hrtimeMillisec(a) {
	assertHrtime(a);

	return Math.floor(a[0] * 1e3 + a[1] / 1e6);
}

/*
 * Add two hrtime readings A and B, overwriting A with the result of the
 * addition.  This function is useful for accumulating several hrtime intervals
 * into a counter.  Returns A.
 */
function hrtimeAccum(a, b) {
	assertHrtime(a);
	assertHrtime(b);

	/*
  * Accumulate the nanosecond component.
  */
	a[1] += b[1];
	if (a[1] >= 1e9) {
		/*
   * The nanosecond component overflowed, so carry to the seconds
   * field.
   */
		a[0]++;
		a[1] -= 1e9;
	}

	/*
  * Accumulate the seconds component.
  */
	a[0] += b[0];

	return a;
}

/*
 * Add two hrtime readings A and B, returning the result as a new hrtime array.
 * Does not modify either input argument.
 */
function hrtimeAdd(a, b) {
	assertHrtime(a);

	var rv = [a[0], a[1]];

	return hrtimeAccum(rv, b);
}

/*
 * Check an object for unexpected properties.  Accepts the object to check, and
 * an array of allowed property names (strings).  Returns an array of key names
 * that were found on the object, but did not appear in the list of allowed
 * properties.  If no properties were found, the returned array will be of
 * zero length.
 */
function extraProperties(obj, allowed) {
	mod_assert.ok((typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) === 'object' && obj !== null, 'obj argument must be a non-null object');
	mod_assert.ok(Array.isArray(allowed), 'allowed argument must be an array of strings');
	for (var i = 0; i < allowed.length; i++) {
		mod_assert.ok(typeof allowed[i] === 'string', 'allowed argument must be an array of strings');
	}

	return (0, _keys2.default)(obj).filter(function (key) {
		return allowed.indexOf(key) === -1;
	});
}

/*
 * Given three sets of properties "provided" (may be undefined), "overrides"
 * (required), and "defaults" (may be undefined), construct an object containing
 * the union of these sets with "overrides" overriding "provided", and
 * "provided" overriding "defaults".  None of the input objects are modified.
 */
function mergeObjects(provided, overrides, defaults) {
	var rv, k;

	rv = {};
	if (defaults) {
		for (k in defaults) {
			rv[k] = defaults[k];
		}
	}

	if (provided) {
		for (k in provided) {
			rv[k] = provided[k];
		}
	}

	if (overrides) {
		for (k in overrides) {
			rv[k] = overrides[k];
		}
	}

	return rv;
}

/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(/*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "./node_modules/lodash/_hashSet.js");

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js");

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js");

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "./node_modules/lodash/_stackSet.js");

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ "./node_modules/lodash/_apply.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_apply.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ "./node_modules/lodash/_assignMergeValue.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_assignMergeValue.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),

/***/ "./node_modules/lodash/_assignValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignValue.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js");

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ "./node_modules/lodash/_baseCreate.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseCreate.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ "./node_modules/lodash/_baseFor.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseFor.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(/*! ./_createBaseFor */ "./node_modules/lodash/_createBaseFor.js");

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_baseKeysIn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseKeysIn.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ "./node_modules/lodash/_nativeKeysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_baseMerge.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseMerge.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ "./node_modules/lodash/_assignMergeValue.js"),
    baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    baseMergeDeep = __webpack_require__(/*! ./_baseMergeDeep */ "./node_modules/lodash/_baseMergeDeep.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js"),
    safeGet = __webpack_require__(/*! ./_safeGet */ "./node_modules/lodash/_safeGet.js");

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),

/***/ "./node_modules/lodash/_baseMergeDeep.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseMergeDeep.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ "./node_modules/lodash/_assignMergeValue.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ "./node_modules/lodash/isArrayLikeObject.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPlainObject = __webpack_require__(/*! ./isPlainObject */ "./node_modules/lodash/isPlainObject.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js"),
    safeGet = __webpack_require__(/*! ./_safeGet */ "./node_modules/lodash/_safeGet.js"),
    toPlainObject = __webpack_require__(/*! ./toPlainObject */ "./node_modules/lodash/toPlainObject.js");

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseRest.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),

/***/ "./node_modules/lodash/_baseSetToString.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseSetToString.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(/*! ./constant */ "./node_modules/lodash/constant.js"),
    defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "./node_modules/lodash/_cloneArrayBuffer.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_cloneArrayBuffer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js");

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),

/***/ "./node_modules/lodash/_cloneBuffer.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneBuffer.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/_cloneTypedArray.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_cloneTypedArray.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_copyArray.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_copyArray.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),

/***/ "./node_modules/lodash/_copyObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_copyObject.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js");

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ "./node_modules/lodash/_createAssigner.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createAssigner.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js");

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),

/***/ "./node_modules/lodash/_createBaseFor.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_createBaseFor.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js");

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ "./node_modules/lodash/_initCloneObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_initCloneObject.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js");

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ "./node_modules/lodash/_isIterateeCall.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_isIterateeCall.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(/*! ./_Hash */ "./node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js");

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeKeysIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "./node_modules/lodash/_overRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_overRest.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/_safeGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_safeGet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),

/***/ "./node_modules/lodash/_setToString.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setToString.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(/*! ./_baseSetToString */ "./node_modules/lodash/_baseSetToString.js"),
    shortOut = __webpack_require__(/*! ./_shortOut */ "./node_modules/lodash/_shortOut.js");

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),

/***/ "./node_modules/lodash/_shortOut.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_shortOut.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js");

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ "./node_modules/lodash/constant.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/constant.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "./node_modules/lodash/identity.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "./node_modules/lodash/isArrayLikeObject.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/isArrayLikeObject.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isPlainObject.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/isPlainObject.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ "./node_modules/lodash/_baseKeysIn.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ "./node_modules/lodash/merge.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/merge.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(/*! ./_baseMerge */ "./node_modules/lodash/_baseMerge.js"),
    createAssigner = __webpack_require__(/*! ./_createAssigner */ "./node_modules/lodash/_createAssigner.js");

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/toPlainObject.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/toPlainObject.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ "./node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val === 'undefined' ? 'undefined' : (0, _typeof3.default)(val);
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + (0, _stringify2.default)(val));
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/***/ }),

/***/ "./node_modules/node-fetch/browser.js":
/*!********************************************!*\
  !*** ./node_modules/node-fetch/browser.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// ref: https://github.com/tc39/proposal-global

var getGlobal = function getGlobal() {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') {
		return self;
	}
	if (typeof window !== 'undefined') {
		return window;
	}
	if (typeof global !== 'undefined') {
		return global;
	}
	throw new Error('unable to locate global object');
};

var global = getGlobal();

module.exports = exports = global.fetch;

// Needed for TypeScript and Webpack.
exports.default = global.fetch.bind(global);

exports.Headers = global.Headers;
exports.Request = global.Request;
exports.Response = global.Response;

/***/ }),

/***/ "./node_modules/node-libs-browser/mock/empty.js":
/*!******************************************************!*\
  !*** ./node_modules/node-libs-browser/mock/empty.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _getOwnPropertyNames = __webpack_require__(/*! babel-runtime/core-js/object/get-own-property-names */ "./node_modules/babel-runtime/core-js/object/get-own-property-names.js");

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _assign = __webpack_require__(/*! babel-runtime/core-js/object/assign */ "./node_modules/babel-runtime/core-js/object/assign.js");

var _assign2 = _interopRequireDefault(_assign);

var _getOwnPropertySymbols = __webpack_require__(/*! babel-runtime/core-js/object/get-own-property-symbols */ "./node_modules/babel-runtime/core-js/object/get-own-property-symbols.js");

var _getOwnPropertySymbols2 = _interopRequireDefault(_getOwnPropertySymbols);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getOwnPropertySymbols = _getOwnPropertySymbols2.default;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!_assign2.default) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if ((0, _getOwnPropertyNames2.default)(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = (0, _getOwnPropertyNames2.default)(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if ((0, _keys2.default)((0, _assign2.default)({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? _assign2.default : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (typeof process === 'undefined' || !process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);
    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });
    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });
    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });
    default:
      args = new Array(len - 1);
      i = 0;
      while (i < args.length) {
        args[i++] = arguments[i];
      }
      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var stringifyPrimitive = function stringifyPrimitive(v) {
  switch (typeof v === 'undefined' ? 'undefined' : (0, _typeof3.default)(v)) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if ((typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) === 'object') {
    return map(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = _keys2.default || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring-es3/encode.js");

/***/ }),

/***/ "./node_modules/readable-stream/duplex-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/
var objectKeys = _keys2.default || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/readable-stream/lib/_stream_transform.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(/*! util */ 0);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ "./node_modules/readable-stream/lib/internal/streams/BufferList.js");
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && (0, _getPrototypeOf2.default)(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var _defineProperty = __webpack_require__(/*! babel-runtime/core-js/object/define-property */ "./node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _hasInstance = __webpack_require__(/*! babel-runtime/core-js/symbol/has-instance */ "./node_modules/babel-runtime/core-js/symbol/has-instance.js");

var _hasInstance2 = _interopRequireDefault(_hasInstance);

var _symbol = __webpack_require__(/*! babel-runtime/core-js/symbol */ "./node_modules/babel-runtime/core-js/symbol.js");

var _symbol2 = _interopRequireDefault(_symbol);

var _setImmediate2 = __webpack_require__(/*! babel-runtime/core-js/set-immediate */ "./node_modules/babel-runtime/core-js/set-immediate.js");

var _setImmediate3 = _interopRequireDefault(_setImmediate2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? _setImmediate3.default : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "./node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof _symbol2.default === 'function' && _hasInstance2.default && typeof Function.prototype[_hasInstance2.default] === 'function') {
  realHasInstance = Function.prototype[_hasInstance2.default];
  (0, _defineProperty2.default)(Writable, _hasInstance2.default, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
var util = __webpack_require__(/*! util */ 1);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "./node_modules/process-nextick-args/index.js");
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./readable */ "./node_modules/readable-stream/readable-browser.js").PassThrough;

/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "./node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js");

/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./readable */ "./node_modules/readable-stream/readable-browser.js").Transform;

/***/ }),

/***/ "./node_modules/readable-stream/writable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime-module.js":
/*!************************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime-module.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _getOwnPropertyNames = __webpack_require__(/*! babel-runtime/core-js/object/get-own-property-names */ "./node_modules/babel-runtime/core-js/object/get-own-property-names.js");

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = function () {
  return this;
}() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime && (0, _getOwnPropertyNames2.default)(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(/*! ./runtime */ "./node_modules/regenerator-runtime/runtime.js");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch (e) {
    g.regeneratorRuntime = undefined;
  }
}

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

var _setPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/set-prototype-of */ "./node_modules/babel-runtime/core-js/object/set-prototype-of.js");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ "./node_modules/babel-runtime/core-js/object/create.js");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

var _symbol = __webpack_require__(/*! babel-runtime/core-js/symbol */ "./node_modules/babel-runtime/core-js/symbol.js");

var _symbol2 = _interopRequireDefault(_symbol);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof _symbol2.default === "function" ? _symbol2.default : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = ( false ? undefined : (0, _typeof3.default)(module)) === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = (0, _create2.default)(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = _getPrototypeOf2.default;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = (0, _create2.default)(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction ||
    // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (_setPrototypeOf2.default) {
      (0, _setPrototypeOf2.default)(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = (0, _create2.default)(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function (arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value && (typeof value === "undefined" ? "undefined" : (0, _typeof3.default)(value)) === "object" && hasOwn.call(value, "__await")) {
          return _promise2.default.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return _promise2.default.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new _promise2.default(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
      // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
      // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function stop() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
}(
// In sloppy mode, unbound `this` refers to the global object, fallback to
// Function constructor if we're in global strict mode. That is sadly a form
// of indirect eval which violates Content Security Policy.
function () {
  return this;
}() || Function("return this")());
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");
var Buffer = buffer.Buffer;

// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }
  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  var buf = Buffer(size);
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }
  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return buffer.SlowBuffer(size);
};

/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

inherits(Stream, EE);
Stream.Readable = __webpack_require__(/*! readable-stream/readable.js */ "./node_modules/readable-stream/readable-browser.js");
Stream.Writable = __webpack_require__(/*! readable-stream/writable.js */ "./node_modules/readable-stream/writable-browser.js");
Stream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ "./node_modules/readable-stream/duplex-browser.js");
Stream.Transform = __webpack_require__(/*! readable-stream/transform.js */ "./node_modules/readable-stream/transform.js");
Stream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ "./node_modules/readable-stream/passthrough.js");

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;

// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

/***/ }),

/***/ "./node_modules/stream-http/index.js":
/*!*******************************************!*\
  !*** ./node_modules/stream-http/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var ClientRequest = __webpack_require__(/*! ./lib/request */ "./node_modules/stream-http/lib/request.js");
var response = __webpack_require__(/*! ./lib/response */ "./node_modules/stream-http/lib/response.js");
var extend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");
var statusCodes = __webpack_require__(/*! builtin-status-codes */ "./node_modules/builtin-status-codes/browser.js");
var url = __webpack_require__(/*! url */ "./node_modules/node-libs-browser/mock/empty.js");

var http = exports;

http.request = function (opts, cb) {
	if (typeof opts === 'string') opts = url.parse(opts);else opts = extend(opts);

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : '';

	var protocol = opts.protocol || defaultProtocol;
	var host = opts.hostname || opts.host;
	var port = opts.port;
	var path = opts.path || '/';

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1) host = '[' + host + ']';

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? protocol + '//' + host : '') + (port ? ':' + port : '') + path;
	opts.method = (opts.method || 'GET').toUpperCase();
	opts.headers = opts.headers || {};

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts);
	if (cb) req.on('response', cb);
	return req;
};

http.get = function get(opts, cb) {
	var req = http.request(opts, cb);
	req.end();
	return req;
};

http.ClientRequest = ClientRequest;
http.IncomingMessage = response.IncomingMessage;

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

http.globalAgent = new http.Agent();

http.STATUS_CODES = statusCodes;

http.METHODS = ['CHECKOUT', 'CONNECT', 'COPY', 'DELETE', 'GET', 'HEAD', 'LOCK', 'M-SEARCH', 'MERGE', 'MKACTIVITY', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS', 'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'REPORT', 'SEARCH', 'SUBSCRIBE', 'TRACE', 'UNLOCK', 'UNSUBSCRIBE'];
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/stream-http/lib/capability.js":
/*!****************************************************!*\
  !*** ./node_modules/stream-http/lib/capability.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream);

exports.writableStream = isFunction(global.WritableStream);

exports.abortController = isFunction(global.AbortController);

exports.blobConstructor = false;
try {
	new Blob([new ArrayBuffer(1)]);
	exports.blobConstructor = true;
} catch (e) {}

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr;
function getXHR() {
	// Cache the xhr value
	if (xhr !== undefined) return xhr;

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest();
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com');
		} catch (e) {
			xhr = null;
		}
	} else {
		// Service workers don't have XHR
		xhr = null;
	}
	return xhr;
}

function checkTypeSupport(type) {
	var xhr = getXHR();
	if (!xhr) return false;
	try {
		xhr.responseType = type;
		return xhr.responseType === type;
	} catch (e) {}
	return false;
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined';
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice);

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || haveArrayBuffer && checkTypeSupport('arraybuffer');

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream');
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer && checkTypeSupport('moz-chunked-arraybuffer');

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);

exports.vbArray = isFunction(global.VBArray);

function isFunction(value) {
	return typeof value === 'function';
}

xhr = null; // Help gc
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/stream-http/lib/request.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-http/lib/request.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer, global, process) {

var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var capability = __webpack_require__(/*! ./capability */ "./node_modules/stream-http/lib/capability.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var response = __webpack_require__(/*! ./response */ "./node_modules/stream-http/lib/response.js");
var stream = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");
var toArrayBuffer = __webpack_require__(/*! to-arraybuffer */ "./node_modules/to-arraybuffer/index.js");

var IncomingMessage = response.IncomingMessage;
var rStates = response.readyStates;

function decideMode(preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch';
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer';
	} else if (capability.msstream) {
		return 'ms-stream';
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer';
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray';
	} else {
		return 'text';
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this;
	stream.Writable.call(self);

	self._opts = opts;
	self._body = [];
	self._headers = {};
	if (opts.auth) self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'));
	(0, _keys2.default)(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name]);
	});

	var preferBinary;
	var useFetch = true;
	if (opts.mode === 'disable-fetch' || 'requestTimeout' in opts && !capability.abortController) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false;
		preferBinary = true;
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false;
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType;
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true;
	} else {
		throw new Error('Invalid value for opts.mode');
	}
	self._mode = decideMode(preferBinary, useFetch);
	self._fetchTimer = null;

	self.on('finish', function () {
		self._onFinish();
	});
};

inherits(ClientRequest, stream.Writable);

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this;
	var lowerName = name.toLowerCase();
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1) return;

	self._headers[lowerName] = {
		name: name,
		value: value
	};
};

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()];
	if (header) return header.value;
	return null;
};

ClientRequest.prototype.removeHeader = function (name) {
	var self = this;
	delete self._headers[name.toLowerCase()];
};

ClientRequest.prototype._onFinish = function () {
	var self = this;

	if (self._destroyed) return;
	var opts = self._opts;

	var headersObj = self._headers;
	var body = null;
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
		if (capability.arraybuffer) {
			body = toArrayBuffer(Buffer.concat(self._body));
		} else if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer);
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			});
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString();
		}
	}

	// create flattened list of headers
	var headersList = [];
	(0, _keys2.default)(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name;
		var value = headersObj[keyName].value;
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v]);
			});
		} else {
			headersList.push([name, value]);
		}
	});

	if (self._mode === 'fetch') {
		var signal = null;
		var fetchTimer = null;
		if (capability.abortController) {
			var controller = new AbortController();
			signal = controller.signal;
			self._fetchAbortController = controller;

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = global.setTimeout(function () {
					self.emit('requestTimeout');
					if (self._fetchAbortController) self._fetchAbortController.abort();
				}, opts.requestTimeout);
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response;
			self._connect();
		}, function (reason) {
			global.clearTimeout(self._fetchTimer);
			if (!self._destroyed) self.emit('error', reason);
		});
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest();
		try {
			xhr.open(self._opts.method, self._opts.url, true);
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err);
			});
			return;
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr) xhr.responseType = self._mode.split(':')[0];

		if ('withCredentials' in xhr) xhr.withCredentials = !!opts.withCredentials;

		if (self._mode === 'text' && 'overrideMimeType' in xhr) xhr.overrideMimeType('text/plain; charset=x-user-defined');

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout;
			xhr.ontimeout = function () {
				self.emit('requestTimeout');
			};
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1]);
		});

		self._response = null;
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress();
					break;
			}
		};
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress();
			};
		}

		xhr.onerror = function () {
			if (self._destroyed) return;
			self.emit('error', new Error('XHR error'));
		};

		try {
			xhr.send(body);
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err);
			});
			return;
		}
	}
};

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid(xhr) {
	try {
		var status = xhr.status;
		return status !== null && status !== 0;
	} catch (e) {
		return false;
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this;

	if (!statusValid(self._xhr) || self._destroyed) return;

	if (!self._response) self._connect();

	self._response._onXHRProgress();
};

ClientRequest.prototype._connect = function () {
	var self = this;

	if (self._destroyed) return;

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer);
	self._response.on('error', function (err) {
		self.emit('error', err);
	});

	self.emit('response', self._response);
};

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this;

	self._body.push(chunk);
	cb();
};

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this;
	self._destroyed = true;
	global.clearTimeout(self._fetchTimer);
	if (self._response) self._response._destroyed = true;
	if (self._xhr) self._xhr.abort();else if (self._fetchAbortController) self._fetchAbortController.abort();
};

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this;
	if (typeof data === 'function') {
		cb = data;
		data = undefined;
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb);
};

ClientRequest.prototype.flushHeaders = function () {};
ClientRequest.prototype.setTimeout = function () {};
ClientRequest.prototype.setNoDelay = function () {};
ClientRequest.prototype.setSocketKeepAlive = function () {};

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = ['accept-charset', 'accept-encoding', 'access-control-request-headers', 'access-control-request-method', 'connection', 'content-length', 'cookie', 'cookie2', 'date', 'dnt', 'expect', 'host', 'keep-alive', 'origin', 'referer', 'te', 'trailer', 'transfer-encoding', 'upgrade', 'via'];
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/stream-http/lib/response.js":
/*!**************************************************!*\
  !*** ./node_modules/stream-http/lib/response.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global, Buffer) {

var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var capability = __webpack_require__(/*! ./capability */ "./node_modules/stream-http/lib/capability.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
var stream = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
};

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {
	var self = this;
	stream.Readable.call(self);

	self._mode = mode;
	self.headers = {};
	self.rawHeaders = [];
	self.trailers = {};
	self.rawTrailers = [];

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close');
		});
	});

	if (mode === 'fetch') {
		var read = function read() {
			reader.read().then(function (result) {
				if (self._destroyed) return;
				if (result.done) {
					global.clearTimeout(fetchTimer);
					self.push(null);
					return;
				}
				self.push(new Buffer(result.value));
				read();
			}).catch(function (err) {
				global.clearTimeout(fetchTimer);
				if (!self._destroyed) self.emit('error', err);
			});
		};

		self._fetchResponse = response;

		self.url = response.url;
		self.statusCode = response.status;
		self.statusMessage = response.statusText;

		response.headers.forEach(function (header, key) {
			self.headers[key.toLowerCase()] = header;
			self.rawHeaders.push(key, header);
		});

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function write(chunk) {
					return new _promise2.default(function (resolve, reject) {
						if (self._destroyed) {
							reject();
						} else if (self.push(new Buffer(chunk))) {
							resolve();
						} else {
							self._resumeFetch = resolve;
						}
					});
				},
				close: function close() {
					global.clearTimeout(fetchTimer);
					if (!self._destroyed) self.push(null);
				},
				abort: function abort(err) {
					if (!self._destroyed) self.emit('error', err);
				}
			});

			try {
				response.body.pipeTo(writable).catch(function (err) {
					global.clearTimeout(fetchTimer);
					if (!self._destroyed) self.emit('error', err);
				});
				return;
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader();

		read();
	} else {
		self._xhr = xhr;
		self._pos = 0;

		self.url = xhr.responseURL;
		self.statusCode = xhr.status;
		self.statusMessage = xhr.statusText;
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/);
			if (matches) {
				var key = matches[1].toLowerCase();
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = [];
					}
					self.headers[key].push(matches[2]);
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2];
				} else {
					self.headers[key] = matches[2];
				}
				self.rawHeaders.push(matches[1], matches[2]);
			}
		});

		self._charset = 'x-user-defined';
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type'];
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase();
				}
			}
			if (!self._charset) self._charset = 'utf-8'; // best guess
		}
	}
};

inherits(IncomingMessage, stream.Readable);

IncomingMessage.prototype._read = function () {
	var self = this;

	var resolve = self._resumeFetch;
	if (resolve) {
		self._resumeFetch = null;
		resolve();
	}
};

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this;

	var xhr = self._xhr;

	var response = null;
	switch (self._mode) {
		case 'text:vbarray':
			// For IE9
			if (xhr.readyState !== rStates.DONE) break;
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray();
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response));
				break;
			}
		// Falls through in IE8	
		case 'text':
			try {
				// This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText;
			} catch (e) {
				self._mode = 'text:vbarray';
				break;
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos);
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length);
					for (var i = 0; i < newData.length; i++) {
						buffer[i] = newData.charCodeAt(i) & 0xff;
					}self.push(buffer);
				} else {
					self.push(newData, self._charset);
				}
				self._pos = response.length;
			}
			break;
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response) break;
			response = xhr.response;
			self.push(new Buffer(new Uint8Array(response)));
			break;
		case 'moz-chunked-arraybuffer':
			// take whole
			response = xhr.response;
			if (xhr.readyState !== rStates.LOADING || !response) break;
			self.push(new Buffer(new Uint8Array(response)));
			break;
		case 'ms-stream':
			response = xhr.response;
			if (xhr.readyState !== rStates.LOADING) break;
			var reader = new global.MSStreamReader();
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))));
					self._pos = reader.result.byteLength;
				}
			};
			reader.onload = function () {
				self.push(null);
			};
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response);
			break;
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null);
	}
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\uFFFD';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\uFFFD';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\uFFFD';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\uFFFD';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/to-arraybuffer/index.js":
/*!**********************************************!*\
  !*** ./node_modules/to-arraybuffer/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer;
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length);
		var len = buf.length;
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i];
		}
		return arrayCopy.buffer;
	} else {
		throw new Error('Argument must be a Buffer');
	}
};

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function isBuffer(arg) {
  return arg && (typeof arg === 'undefined' ? 'undefined' : (0, _typeof3.default)(arg)) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _defineProperties = __webpack_require__(/*! babel-runtime/core-js/object/define-properties */ "./node_modules/babel-runtime/core-js/object/define-properties.js");

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _setPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/set-prototype-of */ "./node_modules/babel-runtime/core-js/object/set-prototype-of.js");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

var _defineProperty = __webpack_require__(/*! babel-runtime/core-js/object/define-property */ "./node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

var _symbol = __webpack_require__(/*! babel-runtime/core-js/symbol */ "./node_modules/babel-runtime/core-js/symbol.js");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

var _getOwnPropertyNames = __webpack_require__(/*! babel-runtime/core-js/object/get-own-property-names */ "./node_modules/babel-runtime/core-js/object/get-own-property-names.js");

var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);

var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ "./node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

var _getOwnPropertyDescriptor = __webpack_require__(/*! babel-runtime/core-js/object/get-own-property-descriptor */ "./node_modules/babel-runtime/core-js/object/get-own-property-descriptor.js");

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _getOwnPropertyDescriptors = __webpack_require__(/*! babel-runtime/core-js/object/get-own-property-descriptors */ "./node_modules/babel-runtime/core-js/object/get-own-property-descriptors.js");

var _getOwnPropertyDescriptors2 = _interopRequireDefault(_getOwnPropertyDescriptors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = _getOwnPropertyDescriptors2.default || function getOwnPropertyDescriptors(obj) {
  var keys = (0, _keys2.default)(obj);
  var descriptors = {};
  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = (0, _getOwnPropertyDescriptor2.default)(obj, keys[i]);
  }
  return descriptors;
};

var formatRegExp = /%[sdj%]/g;
exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s':
        return String(args[i++]);
      case '%d':
        return Number(args[i++]);
      case '%j':
        try {
          return (0, _stringify2.default)(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function (fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;
exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }
  return debugs[set];
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\x1B[' + inspect.colors[style][0] + 'm' + str + '\x1B[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};

  array.forEach(function (val, idx) {
    hash[val] = true;
  });

  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) &&
  // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect &&
  // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = (0, _keys2.default)(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = (0, _getOwnPropertyNames2.default)(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + (0, _stringify2.default)(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = (0, _getOwnPropertyDescriptor2.default)(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = (0, _stringify2.default)('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : (0, _typeof3.default)(arg)) === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : (0, _typeof3.default)(arg)) === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : (0, _typeof3.default)(arg)) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = (0, _keys2.default)(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof _symbol2.default !== 'undefined' ? (0, _symbol2.default)('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    (0, _defineProperty2.default)(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new _promise2.default(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  (0, _setPrototypeOf2.default)(fn, (0, _getPrototypeOf2.default)(original));

  if (kCustomPromisifiedSymbol) (0, _defineProperty2.default)(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return (0, _defineProperties2.default)(fn, getOwnPropertyDescriptors(original));
};

exports.promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function cb() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args).then(function (ret) {
      process.nextTick(cb, null, ret);
    }, function (rej) {
      process.nextTick(callbackifyOnRejected, rej, cb);
    });
  }

  (0, _setPrototypeOf2.default)(callbackified, (0, _getPrototypeOf2.default)(original));
  (0, _defineProperties2.default)(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/verror/lib/verror.js":
/*!*******************************************!*\
  !*** ./node_modules/verror/lib/verror.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _create = __webpack_require__(/*! babel-runtime/core-js/object/create */ "./node_modules/babel-runtime/core-js/object/create.js");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * verror.js: richer JavaScript errors
 */

var mod_assertplus = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var mod_util = __webpack_require__(/*! util */ "./node_modules/util/util.js");

var mod_extsprintf = __webpack_require__(/*! extsprintf */ "./node_modules/extsprintf/lib/extsprintf.js");
var mod_isError = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js").isError;
var sprintf = mod_extsprintf.sprintf;

/*
 * Public interface
 */

/* So you can 'var VError = require('verror')' */
module.exports = VError;
/* For compatibility */
VError.VError = VError;
/* Other exported classes */
VError.SError = SError;
VError.WError = WError;
VError.MultiError = MultiError;

/*
 * Common function used to parse constructor arguments for VError, WError, and
 * SError.  Named arguments to this function:
 *
 *     strict		force strict interpretation of sprintf arguments, even
 *     			if the options in "argv" don't say so
 *
 *     argv		error's constructor arguments, which are to be
 *     			interpreted as described in README.md.  For quick
 *     			reference, "argv" has one of the following forms:
 *
 *          [ sprintf_args... ]           (argv[0] is a string)
 *          [ cause, sprintf_args... ]    (argv[0] is an Error)
 *          [ options, sprintf_args... ]  (argv[0] is an object)
 *
 * This function normalizes these forms, producing an object with the following
 * properties:
 *
 *    options           equivalent to "options" in third form.  This will never
 *    			be a direct reference to what the caller passed in
 *    			(i.e., it may be a shallow copy), so it can be freely
 *    			modified.
 *
 *    shortmessage      result of sprintf(sprintf_args), taking options.strict
 *    			into account as described in README.md.
 */
function parseConstructorArguments(args) {
	var argv, options, sprintf_args, shortmessage, k;

	mod_assertplus.object(args, 'args');
	mod_assertplus.bool(args.strict, 'args.strict');
	mod_assertplus.array(args.argv, 'args.argv');
	argv = args.argv;

	/*
  * First, figure out which form of invocation we've been given.
  */
	if (argv.length === 0) {
		options = {};
		sprintf_args = [];
	} else if (mod_isError(argv[0])) {
		options = { 'cause': argv[0] };
		sprintf_args = argv.slice(1);
	} else if ((0, _typeof3.default)(argv[0]) === 'object') {
		options = {};
		for (k in argv[0]) {
			options[k] = argv[0][k];
		}
		sprintf_args = argv.slice(1);
	} else {
		mod_assertplus.string(argv[0], 'first argument to VError, SError, or WError ' + 'constructor must be a string, object, or Error');
		options = {};
		sprintf_args = argv;
	}

	/*
  * Now construct the error's message.
  *
  * extsprintf (which we invoke here with our caller's arguments in order
  * to construct this Error's message) is strict in its interpretation of
  * values to be processed by the "%s" specifier.  The value passed to
  * extsprintf must actually be a string or something convertible to a
  * String using .toString().  Passing other values (notably "null" and
  * "undefined") is considered a programmer error.  The assumption is
  * that if you actually want to print the string "null" or "undefined",
  * then that's easy to do that when you're calling extsprintf; on the
  * other hand, if you did NOT want that (i.e., there's actually a bug
  * where the program assumes some variable is non-null and tries to
  * print it, which might happen when constructing a packet or file in
  * some specific format), then it's better to stop immediately than
  * produce bogus output.
  *
  * However, sometimes the bug is only in the code calling VError, and a
  * programmer might prefer to have the error message contain "null" or
  * "undefined" rather than have the bug in the error path crash the
  * program (making the first bug harder to identify).  For that reason,
  * by default VError converts "null" or "undefined" arguments to their
  * string representations and passes those to extsprintf.  Programmers
  * desiring the strict behavior can use the SError class or pass the
  * "strict" option to the VError constructor.
  */
	mod_assertplus.object(options);
	if (!options.strict && !args.strict) {
		sprintf_args = sprintf_args.map(function (a) {
			return a === null ? 'null' : a === undefined ? 'undefined' : a;
		});
	}

	if (sprintf_args.length === 0) {
		shortmessage = '';
	} else {
		shortmessage = sprintf.apply(null, sprintf_args);
	}

	return {
		'options': options,
		'shortmessage': shortmessage
	};
}

/*
 * See README.md for reference documentation.
 */
function VError() {
	var args, obj, parsed, cause, ctor, message, k;

	args = Array.prototype.slice.call(arguments, 0);

	/*
  * This is a regrettable pattern, but JavaScript's built-in Error class
  * is defined to work this way, so we allow the constructor to be called
  * without "new".
  */
	if (!(this instanceof VError)) {
		obj = (0, _create2.default)(VError.prototype);
		VError.apply(obj, arguments);
		return obj;
	}

	/*
  * For convenience and backwards compatibility, we support several
  * different calling forms.  Normalize them here.
  */
	parsed = parseConstructorArguments({
		'argv': args,
		'strict': false
	});

	/*
  * If we've been given a name, apply it now.
  */
	if (parsed.options.name) {
		mod_assertplus.string(parsed.options.name, 'error\'s "name" must be a string');
		this.name = parsed.options.name;
	}

	/*
  * For debugging, we keep track of the original short message (attached
  * this Error particularly) separately from the complete message (which
  * includes the messages of our cause chain).
  */
	this.jse_shortmsg = parsed.shortmessage;
	message = parsed.shortmessage;

	/*
  * If we've been given a cause, record a reference to it and update our
  * message appropriately.
  */
	cause = parsed.options.cause;
	if (cause) {
		mod_assertplus.ok(mod_isError(cause), 'cause is not an Error');
		this.jse_cause = cause;

		if (!parsed.options.skipCauseMessage) {
			message += ': ' + cause.message;
		}
	}

	/*
  * If we've been given an object with properties, shallow-copy that
  * here.  We don't want to use a deep copy in case there are non-plain
  * objects here, but we don't want to use the original object in case
  * the caller modifies it later.
  */
	this.jse_info = {};
	if (parsed.options.info) {
		for (k in parsed.options.info) {
			this.jse_info[k] = parsed.options.info[k];
		}
	}

	this.message = message;
	Error.call(this, message);

	if (Error.captureStackTrace) {
		ctor = parsed.options.constructorOpt || this.constructor;
		Error.captureStackTrace(this, ctor);
	}

	return this;
}

mod_util.inherits(VError, Error);
VError.prototype.name = 'VError';

VError.prototype.toString = function ve_toString() {
	var str = this.hasOwnProperty('name') && this.name || this.constructor.name || this.constructor.prototype.name;
	if (this.message) str += ': ' + this.message;

	return str;
};

/*
 * This method is provided for compatibility.  New callers should use
 * VError.cause() instead.  That method also uses the saner `null` return value
 * when there is no cause.
 */
VError.prototype.cause = function ve_cause() {
	var cause = VError.cause(this);
	return cause === null ? undefined : cause;
};

/*
 * Static methods
 *
 * These class-level methods are provided so that callers can use them on
 * instances of Errors that are not VErrors.  New interfaces should be provided
 * only using static methods to eliminate the class of programming mistake where
 * people fail to check whether the Error object has the corresponding methods.
 */

VError.cause = function (err) {
	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
	return mod_isError(err.jse_cause) ? err.jse_cause : null;
};

VError.info = function (err) {
	var rv, cause, k;

	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
	cause = VError.cause(err);
	if (cause !== null) {
		rv = VError.info(cause);
	} else {
		rv = {};
	}

	if ((0, _typeof3.default)(err.jse_info) == 'object' && err.jse_info !== null) {
		for (k in err.jse_info) {
			rv[k] = err.jse_info[k];
		}
	}

	return rv;
};

VError.findCauseByName = function (err, name) {
	var cause;

	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
	mod_assertplus.string(name, 'name');
	mod_assertplus.ok(name.length > 0, 'name cannot be empty');

	for (cause = err; cause !== null; cause = VError.cause(cause)) {
		mod_assertplus.ok(mod_isError(cause));
		if (cause.name == name) {
			return cause;
		}
	}

	return null;
};

VError.hasCauseWithName = function (err, name) {
	return VError.findCauseByName(err, name) !== null;
};

VError.fullStack = function (err) {
	mod_assertplus.ok(mod_isError(err), 'err must be an Error');

	var cause = VError.cause(err);

	if (cause) {
		return err.stack + '\ncaused by: ' + VError.fullStack(cause);
	}

	return err.stack;
};

VError.errorFromList = function (errors) {
	mod_assertplus.arrayOfObject(errors, 'errors');

	if (errors.length === 0) {
		return null;
	}

	errors.forEach(function (e) {
		mod_assertplus.ok(mod_isError(e));
	});

	if (errors.length == 1) {
		return errors[0];
	}

	return new MultiError(errors);
};

VError.errorForEach = function (err, func) {
	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
	mod_assertplus.func(func, 'func');

	if (err instanceof MultiError) {
		err.errors().forEach(function iterError(e) {
			func(e);
		});
	} else {
		func(err);
	}
};

/*
 * SError is like VError, but stricter about types.  You cannot pass "null" or
 * "undefined" as string arguments to the formatter.
 */
function SError() {
	var args, obj, parsed, options;

	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof SError)) {
		obj = (0, _create2.default)(SError.prototype);
		SError.apply(obj, arguments);
		return obj;
	}

	parsed = parseConstructorArguments({
		'argv': args,
		'strict': true
	});

	options = parsed.options;
	VError.call(this, options, '%s', parsed.shortmessage);

	return this;
}

/*
 * We don't bother setting SError.prototype.name because once constructed,
 * SErrors are just like VErrors.
 */
mod_util.inherits(SError, VError);

/*
 * Represents a collection of errors for the purpose of consumers that generally
 * only deal with one error.  Callers can extract the individual errors
 * contained in this object, but may also just treat it as a normal single
 * error, in which case a summary message will be printed.
 */
function MultiError(errors) {
	mod_assertplus.array(errors, 'list of errors');
	mod_assertplus.ok(errors.length > 0, 'must be at least one error');
	this.ase_errors = errors;

	VError.call(this, {
		'cause': errors[0]
	}, 'first of %d error%s', errors.length, errors.length == 1 ? '' : 's');
}

mod_util.inherits(MultiError, VError);
MultiError.prototype.name = 'MultiError';

MultiError.prototype.errors = function me_errors() {
	return this.ase_errors.slice(0);
};

/*
 * See README.md for reference details.
 */
function WError() {
	var args, obj, parsed, options;

	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof WError)) {
		obj = (0, _create2.default)(WError.prototype);
		WError.apply(obj, args);
		return obj;
	}

	parsed = parseConstructorArguments({
		'argv': args,
		'strict': false
	});

	options = parsed.options;
	options['skipCauseMessage'] = true;
	VError.call(this, options, '%s', parsed.shortmessage);

	return this;
}

mod_util.inherits(WError, VError);
WError.prototype.name = 'WError';

WError.prototype.toString = function we_toString() {
	var str = this.hasOwnProperty('name') && this.name || this.constructor.name || this.constructor.prototype.name;
	if (this.message) str += ': ' + this.message;
	if (this.jse_cause && this.jse_cause.message) str += '; caused by ' + this.jse_cause.toString();

	return str;
};

/*
 * For purely historical reasons, WError's cause() function allows you to set
 * the cause.
 */
WError.prototype.cause = function we_cause(c) {
	if (mod_isError(c)) this.jse_cause = c;

	return this.jse_cause;
};

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : (0, _typeof3.default)(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),

/***/ "./node_modules/xtend/immutable.js":
/*!*****************************************!*\
  !*** ./node_modules/xtend/immutable.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = extend;

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {};

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }

    return target;
}

/***/ }),

/***/ "./src/browser/client/index.js":
/*!*************************************!*\
  !*** ./src/browser/client/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ../../client */ "./src/client.js")();

/***/ }),

/***/ "./src/browser/client/mock/index.js":
/*!******************************************!*\
  !*** ./src/browser/client/mock/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {};

/***/ }),

/***/ "./src/client.js":
/*!***********************!*\
  !*** ./src/client.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ "./node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

var _regenerator = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = __webpack_require__(/*! babel-runtime/helpers/get */ "./node_modules/babel-runtime/helpers/get.js");

var _get3 = _interopRequireDefault(_get2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var merge = __webpack_require__(/*! lodash/merge */ "./node_modules/lodash/merge.js");
var fetch = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/browser.js");
var FormData = __webpack_require__(/*! form-data */ "./node_modules/form-data/lib/browser.js");
var https = __webpack_require__(/*! https */ "./node_modules/https-browserify/index.js");
var qs = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");
var utils = __webpack_require__(/*! ./utils */ "./src/utils.js");
var errors = __webpack_require__(/*! ./errors */ "./src/errors.js");
var ms = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
var LoggerConsole = __webpack_require__(/*! ./logger/transports/console */ "./src/logger/transports/console/index.js")();
var TaskInterval = __webpack_require__(/*! ./task/transports/interval */ "./src/task/transports/interval/index.js")();
var Service = __webpack_require__(/*! ./service */ "./src/service.js")();

module.exports = function (Parent) {
  /**
   * Class to manage client requests to the network
   */
  return function (_ref) {
    (0, _inherits3.default)(Client, _ref);
    (0, _createClass3.default)(Client, null, [{
      key: 'LoggerTransport',
      get: function get() {
        return LoggerConsole;
      }
    }, {
      key: 'TaskTransport',
      get: function get() {
        return TaskInterval;
      }

      /**
       * @param {object} options
       * @param {string|string[]} options.address
       */

    }]);

    function Client() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      (0, _classCallCheck3.default)(this, Client);

      var _this = (0, _possibleConstructorReturn3.default)(this, (Client.__proto__ || (0, _getPrototypeOf2.default)(Client)).apply(this, arguments));

      if (!options.address) {
        throw new Error('You must pass the node address in "ip:port" format');
      }

      _this.options = merge({
        request: {
          pingTimeout: '1s',
          clientTimeout: '8s'
        },
        secretKey: '',
        https: false,
        logger: {
          level: 'info'
        },
        task: {
          workerChangeInterval: '30s'
        }
      }, options);

      !_this.options.logger && (_this.options.logger = { level: false });
      _this.LoggerTransport = _this.constructor.LoggerTransport;
      _this.TaskTransport = _this.constructor.TaskTransport;
      _this.address = options.address;
      _this.prepareOptions();
      return _this;
    }

    /**
     * Initialize the client
     * 
     * @async
     */


    (0, _createClass3.default)(Client, [{
      key: 'init',
      value: function () {
        var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
          var addresses,
              availableAddress,
              _args = arguments;
          return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return this.prepareServices();

                case 2:
                  _context.next = 4;
                  return this.initServices();

                case 4:
                  addresses = Array.isArray(this.address) ? this.address : [this.address];
                  _context.next = 7;
                  return this.getAvailableAddress(addresses);

                case 7:
                  availableAddress = _context.sent;

                  if (availableAddress) {
                    _context.next = 10;
                    break;
                  }

                  throw new Error('Provided addresses are not available');

                case 10:

                  this.workerAddress = availableAddress;
                  _context.next = 13;
                  return this.changeWorker();

                case 13:
                  (0, _get3.default)(Client.prototype.__proto__ || (0, _getPrototypeOf2.default)(Client.prototype), 'init', this).apply(this, _args);

                case 14:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function init() {
          return _ref2.apply(this, arguments);
        }

        return init;
      }()

      /**
       * Deinitialize the client
       * 
       * @async
       */

    }, {
      key: 'deinit',
      value: function () {
        var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
          var _args2 = arguments;
          return _regenerator2.default.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return this.deinitServices();

                case 2:
                  (0, _get3.default)(Client.prototype.__proto__ || (0, _getPrototypeOf2.default)(Client.prototype), 'deinit', this).apply(this, _args2);

                case 3:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function deinit() {
          return _ref3.apply(this, arguments);
        }

        return deinit;
      }()

      /**
       * Prepare the services
       * 
       * @async
       */

    }, {
      key: 'prepareServices',
      value: function () {
        var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
          var _this2 = this;

          return _regenerator2.default.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  this.logger = new this.LoggerTransport(this, this.options.logger);
                  this.options.task && (this.task = new this.TaskTransport(this, this.options.task));

                  if (this.task) {
                    _context3.next = 4;
                    break;
                  }

                  return _context3.abrupt('return');

                case 4:
                  if (!this.options.task.workerChangeInterval) {
                    _context3.next = 7;
                    break;
                  }

                  _context3.next = 7;
                  return this.task.add('workerChange', this.options.task.workerChangeInterval, function () {
                    return _this2.changeWorker();
                  });

                case 7:
                case 'end':
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function prepareServices() {
          return _ref4.apply(this, arguments);
        }

        return prepareServices;
      }()

      /**
       * Initialize the services
       * 
       * @async
       */

    }, {
      key: 'initServices',
      value: function () {
        var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
          return _regenerator2.default.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return this.logger.init();

                case 2:
                  _context4.t0 = this.task;

                  if (!_context4.t0) {
                    _context4.next = 6;
                    break;
                  }

                  _context4.next = 6;
                  return this.task.init();

                case 6:
                case 'end':
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function initServices() {
          return _ref5.apply(this, arguments);
        }

        return initServices;
      }()

      /**
       * Deinitialize the services
       * 
       * @async
       */

    }, {
      key: 'deinitServices',
      value: function () {
        var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {
          return _regenerator2.default.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.t0 = this.task;

                  if (!_context5.t0) {
                    _context5.next = 4;
                    break;
                  }

                  _context5.next = 4;
                  return this.task.deinit();

                case 4:
                  _context5.next = 6;
                  return this.logger.deinit();

                case 6:
                case 'end':
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function deinitServices() {
          return _ref6.apply(this, arguments);
        }

        return deinitServices;
      }()

      /**
       * Get an available address from the list
       * 
       * @async
       * @param {string[]} addresses
       * @returns {string}
       */

    }, {
      key: 'getAvailableAddress',
      value: function () {
        var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(addresses) {
          var availableAddress, i, address;
          return _regenerator2.default.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  availableAddress = void 0;
                  i = 0;

                case 2:
                  if (!(i < addresses.length)) {
                    _context6.next = 17;
                    break;
                  }

                  address = addresses[i];
                  _context6.prev = 4;
                  _context6.next = 7;
                  return fetch(this.getRequestProtocol() + '://' + address + '/ping', this.createDefaultRequestOptions({
                    method: 'GET',
                    timeout: this.options.request.pingTimeout
                  }));

                case 7:
                  availableAddress = address;
                  return _context6.abrupt('break', 17);

                case 11:
                  _context6.prev = 11;
                  _context6.t0 = _context6['catch'](4);

                  this.logger.warn(_context6.t0.stack);

                case 14:
                  i++;
                  _context6.next = 2;
                  break;

                case 17:
                  return _context6.abrupt('return', availableAddress || null);

                case 18:
                case 'end':
                  return _context6.stop();
              }
            }
          }, _callee6, this, [[4, 11]]);
        }));

        function getAvailableAddress(_x2) {
          return _ref7.apply(this, arguments);
        }

        return getAvailableAddress;
      }()

      /**
       * Change the worker address
       * 
       * @async
       */

    }, {
      key: 'changeWorker',
      value: function () {
        var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7() {
          var lastAddress, address;
          return _regenerator2.default.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  lastAddress = this.workerAddress;
                  _context7.next = 3;
                  return this.request('get-available-node', {
                    useInitialAddress: true
                  });

                case 3:
                  address = _context7.sent.address;

                  if (!(address == lastAddress)) {
                    _context7.next = 6;
                    break;
                  }

                  return _context7.abrupt('return');

                case 6:
                  _context7.prev = 6;
                  _context7.next = 9;
                  return fetch(this.getRequestProtocol() + '://' + address + '/ping', this.createDefaultRequestOptions({
                    method: 'GET',
                    timeout: this.options.request.pingTimeout
                  }));

                case 9:
                  this.workerAddress = address;
                  _context7.next = 16;
                  break;

                case 12:
                  _context7.prev = 12;
                  _context7.t0 = _context7['catch'](6);

                  this.logger.warn(_context7.t0.stack);
                  this.workerAddress = lastAddress;

                case 16:
                case 'end':
                  return _context7.stop();
              }
            }
          }, _callee7, this, [[6, 12]]);
        }));

        function changeWorker() {
          return _ref8.apply(this, arguments);
        }

        return changeWorker;
      }()

      /**
       * Make a request to the api
       * 
       * @async
       * @param {string} endpoint
       * @param {object} [options]
       * @returns {object}
       */

    }, {
      key: 'request',
      value: function () {
        var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(endpoint) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          var body, form, key, val, start, result, _body;

          return _regenerator2.default.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  options = merge(this.createDefaultRequestOptions(), options);
                  body = options.formData || options.body || {};

                  body.timeout = options.timeout;
                  body.timestamp = Date.now();

                  if (options.formData) {
                    form = new FormData();


                    for (key in body) {
                      val = body[key];


                      if ((typeof val === 'undefined' ? 'undefined' : (0, _typeof3.default)(val)) == 'object') {
                        form.append(key, val.value, val.options);
                      } else {
                        form.append(key, val);
                      }
                    }

                    options.body = form;
                    delete options.formData;
                  } else {
                    options.headers['content-type'] = 'application/json';
                    options.body = (0, _stringify2.default)(body);
                  }

                  options.url = this.createRequestUrl(endpoint, { useInitialAddress: options.useInitialAddress });
                  start = Date.now();
                  _context8.prev = 7;
                  _context8.next = 10;
                  return fetch(options.url, options);

                case 10:
                  result = _context8.sent;

                  this.logger.info('Request to "' + options.url + '": ' + ms(Date.now() - start));
                  _context8.next = 14;
                  return result.json();

                case 14:
                  _body = _context8.sent;

                  if (!result.ok) {
                    _context8.next = 17;
                    break;
                  }

                  return _context8.abrupt('return', _body);

                case 17:
                  if (!(!_body || (typeof _body === 'undefined' ? 'undefined' : (0, _typeof3.default)(_body)) != 'object')) {
                    _context8.next = 19;
                    break;
                  }

                  throw new Error(_body || 'Unknown error');

                case 19:
                  if (_body.code) {
                    _context8.next = 21;
                    break;
                  }

                  throw new Error(_body.message);

                case 21:
                  throw new errors.WorkError(_body.message, _body.code);

                case 24:
                  _context8.prev = 24;
                  _context8.t0 = _context8['catch'](7);

                  //eslint-disable-next-line no-ex-assign
                  utils.isRequestTimeoutError(_context8.t0) && (_context8.t0 = utils.createRequestTimeoutError());
                  _context8.t0.requestOptions = options;
                  throw _context8.t0;

                case 29:
                case 'end':
                  return _context8.stop();
              }
            }
          }, _callee8, this, [[7, 24]]);
        }));

        function request(_x4) {
          return _ref9.apply(this, arguments);
        }

        return request;
      }()

      /**
       * Create a api request url
       * 
       * @param {string} endpoint 
       * @param {object} options 
       */

    }, {
      key: 'createRequestUrl',
      value: function createRequestUrl(endpoint) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var query = options.query ? qs.stringify(options.query) : null;
        var address = options.useInitialAddress ? this.address : this.workerAddress;
        var url = this.getRequestProtocol() + '://' + address + '/client/' + endpoint;
        query && (url += '?' + query);
        return url;
      }

      /**
       * Create default request options
       * 
       * @param {object} options
       * @returns {object}
       */

    }, {
      key: 'createDefaultRequestOptions',
      value: function createDefaultRequestOptions() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var defaults = {
          method: 'POST',
          timeout: this.options.request.clientTimeout,
          headers: {
            'network-secret-key': this.options.secretKey
          }
        };

        if (options.timeout) {
          options.timeout = utils.getMs(options.timeout);
        }

        if ((0, _typeof3.default)(this.options.https) == 'object' && this.options.https.ca) {
          options.agent = options.agent || new https.Agent();
          options.agent.options.ca = this.options.https.ca;
        }

        return merge({}, defaults, options);
      }

      /**
       * Create a request timer
       * 
       * @param {number} timeout 
       * @returns {function}
       */

    }, {
      key: 'createRequestTimer',
      value: function createRequestTimer(timeout) {
        return utils.getRequestTimer(timeout, { min: this.options.request.pingTimeout });
      }

      /**
       * Prepare the options
       */

    }, {
      key: 'prepareOptions',
      value: function prepareOptions() {
        this.options.request.clientTimeout = utils.getMs(this.options.request.clientTimeout);
      }

      /**
       * Get the request protocol
       * 
       * @returns {string}
       */

    }, {
      key: 'getRequestProtocol',
      value: function getRequestProtocol() {
        return this.options.https ? 'https' : 'http';
      }

      /**
       * Check the environment
       */

    }, {
      key: 'envTest',
      value: function envTest(isBrowser, name) {
        var isBrowserEnv = utils.isBrowserEnv();

        if (isBrowser && !isBrowserEnv) {
          throw new Error('You can\'t use "' + name + '" method in the nodejs environment');
        }

        if (!isBrowser && isBrowserEnv) {
          throw new Error('You can\'t use "' + name + '" method in the browser environment');
        }
      }
    }]);
    return Client;
  }(Parent || Service);
};

/***/ }),

/***/ "./src/errors.js":
/*!***********************!*\
  !*** ./src/errors.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports.WorkError = function (_Error) {
  (0, _inherits3.default)(WorkError, _Error);

  function WorkError(message, code) {
    (0, _classCallCheck3.default)(this, WorkError);

    var _this = (0, _possibleConstructorReturn3.default)(this, (WorkError.__proto__ || (0, _getPrototypeOf2.default)(WorkError)).call(this, message));

    _this.code = code;
    return _this;
  }

  return WorkError;
}(Error);

module.exports.AccessError = function (_Error2) {
  (0, _inherits3.default)(AccessError, _Error2);

  function AccessError(message) {
    (0, _classCallCheck3.default)(this, AccessError);

    var _this2 = (0, _possibleConstructorReturn3.default)(this, (AccessError.__proto__ || (0, _getPrototypeOf2.default)(AccessError)).call(this, message));

    _this2.statusCode = 403;
    return _this2;
  }

  return AccessError;
}(Error);

module.exports.NotFoundError = function (_Error3) {
  (0, _inherits3.default)(NotFoundError, _Error3);

  function NotFoundError(message) {
    (0, _classCallCheck3.default)(this, NotFoundError);

    var _this3 = (0, _possibleConstructorReturn3.default)(this, (NotFoundError.__proto__ || (0, _getPrototypeOf2.default)(NotFoundError)).call(this, message));

    _this3.statusCode = 404;
    return _this3;
  }

  return NotFoundError;
}(Error);

/***/ }),

/***/ "./src/logger/transports/console/index.js":
/*!************************************************!*\
  !*** ./src/logger/transports/console/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _regenerator = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ "./node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

var _asyncToGenerator2 = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Logger = __webpack_require__(/*! ../logger */ "./src/logger/transports/logger/index.js")();
var chalk = __webpack_require__(/*! chalk */ "./src/browser/client/mock/index.js");
var utils = __webpack_require__(/*! ../../../utils */ "./src/utils.js");

module.exports = function (Parent) {
  /**
   * Console logger transport
   */
  return function (_ref) {
    (0, _inherits3.default)(LoggerConsole, _ref);

    function LoggerConsole() {
      (0, _classCallCheck3.default)(this, LoggerConsole);

      var _this = (0, _possibleConstructorReturn3.default)(this, (LoggerConsole.__proto__ || (0, _getPrototypeOf2.default)(LoggerConsole)).apply(this, arguments));

      _this.colors = {
        info: 'white',
        warn: 'yellow',
        error: 'red'
      };
      return _this;
    }

    /**
     * @see Logger.prototype.log
     */


    (0, _createClass3.default)(LoggerConsole, [{
      key: 'log',
      value: function () {
        var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(level) {
          var _this2 = this;

          var _len,
              args,
              _key,
              _args = arguments;

          return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (this.isLevelActive(level)) {
                    for (_len = _args.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                      args[_key - 1] = _args[_key];
                    }

                    //eslint-disable-next-line no-console
                    console[level].apply(console[level], utils.isBrowserEnv() ? args : args.map(function (arg) {
                      arg && (typeof arg === 'undefined' ? 'undefined' : (0, _typeof3.default)(arg)) == 'object' && (arg = (0, _stringify2.default)(arg));
                      return chalk[_this2.colors[level]](arg);
                    }));
                  }

                case 1:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function log(_x) {
          return _ref2.apply(this, arguments);
        }

        return log;
      }()
    }]);
    return LoggerConsole;
  }(Parent || Logger);
};

/***/ }),

/***/ "./src/logger/transports/logger/index.js":
/*!***********************************************!*\
  !*** ./src/logger/transports/logger/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _toConsumableArray2 = __webpack_require__(/*! babel-runtime/helpers/toConsumableArray */ "./node_modules/babel-runtime/helpers/toConsumableArray.js");

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _regenerator = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = __webpack_require__(/*! babel-runtime/helpers/get */ "./node_modules/babel-runtime/helpers/get.js");

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Service = __webpack_require__(/*! ../../../service */ "./src/service.js")();

module.exports = function (Parent) {
  /**
   * Logger transport interface
   */
  return function (_ref) {
    (0, _inherits3.default)(Logger, _ref);

    /**
     * @param {Node} node 
     * @param {object} options 
     */
    function Logger(node) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      (0, _classCallCheck3.default)(this, Logger);

      var _this = (0, _possibleConstructorReturn3.default)(this, (Logger.__proto__ || (0, _getPrototypeOf2.default)(Logger)).apply(this, arguments));

      _this.node = node;
      _this.options = options;
      _this.levels = ['info', 'warn', 'error'];
      _this.defaultLevel = 'info';
      return _this;
    }

    /** 
     * Initialize the logger
     * 
     * @async
     */


    (0, _createClass3.default)(Logger, [{
      key: 'init',
      value: function () {
        var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
          var _args = arguments;
          return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.setLevel(this.options.level === undefined ? this.defaultLevel : this.options.level);
                  _context.next = 3;
                  return (0, _get3.default)(Logger.prototype.__proto__ || (0, _getPrototypeOf2.default)(Logger.prototype), 'init', this).apply(this, _args);

                case 3:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function init() {
          return _ref2.apply(this, arguments);
        }

        return init;
      }()

      /** 
       * Deinitialize the logger
       * 
       * @async
       */

    }, {
      key: 'deinit',
      value: function () {
        var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
          var _args2 = arguments;
          return _regenerator2.default.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  this.setLevel(false);
                  _context2.next = 3;
                  return (0, _get3.default)(Logger.prototype.__proto__ || (0, _getPrototypeOf2.default)(Logger.prototype), 'deinit', this).apply(this, _args2);

                case 3:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function deinit() {
          return _ref3.apply(this, arguments);
        }

        return deinit;
      }()

      /**
       * Log by levels
       * 
       * @async
       * @param {string} level
       */

    }, {
      key: 'log',
      value: function () {
        var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
          return _regenerator2.default.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  throw new Error('Method "log" is required for logger transport');

                case 1:
                case 'end':
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function log() {
          return _ref4.apply(this, arguments);
        }

        return log;
      }()

      /**
       * Log info
       * 
       * @async
       */

    }, {
      key: 'info',
      value: function () {
        var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return _regenerator2.default.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return this.log.apply(this, ['info'].concat((0, _toConsumableArray3.default)(args)));

                case 2:
                case 'end':
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function info() {
          return _ref5.apply(this, arguments);
        }

        return info;
      }()

      /**
       * Log a warning
       * 
       * @async
       */

    }, {
      key: 'warn',
      value: function () {
        var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return _regenerator2.default.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return this.log.apply(this, ['warn'].concat((0, _toConsumableArray3.default)(args)));

                case 2:
                case 'end':
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function warn() {
          return _ref6.apply(this, arguments);
        }

        return warn;
      }()

      /**
       * Log an error
       * 
       * @async
       */

    }, {
      key: 'error',
      value: function () {
        var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          return _regenerator2.default.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.next = 2;
                  return this.log.apply(this, ['error'].concat((0, _toConsumableArray3.default)(args)));

                case 2:
                case 'end':
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function error() {
          return _ref7.apply(this, arguments);
        }

        return error;
      }()

      /**
       * Check the log level is active
       * 
       * @param {string} level
       */

    }, {
      key: 'isLevelActive',
      value: function isLevelActive(level) {
        if (!this.level) {
          return false;
        }

        return this.levels.indexOf(level) >= this.levels.indexOf(this.level);
      }

      /**
       * Set the active level
       * 
       * @param {string} level
       */

    }, {
      key: 'setLevel',
      value: function setLevel(level) {
        if (level === false) {
          return this.level = false;
        }

        if (this.levels.indexOf(level) == -1) {
          throw new Error('Wrong logger level "' + level + '"');
        }

        this.level = level;
      }
    }]);
    return Logger;
  }(Parent || Service);
};

/***/ }),

/***/ "./src/service.js":
/*!************************!*\
  !*** ./src/service.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _regenerator = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function () {
  /**
   * The service class
   */
  return function () {
    function Service() {
      (0, _classCallCheck3.default)(this, Service);
    }

    (0, _createClass3.default)(Service, [{
      key: "init",

      /**
       * Initialize the service
       * 
       * @async
       */
      value: function () {
        var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
          return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.__initialized = Date.now();

                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function init() {
          return _ref.apply(this, arguments);
        }

        return init;
      }()

      /**
       * Deinitialize the service
       * 
       * @async
       */

    }, {
      key: "deinit",
      value: function () {
        var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
          return _regenerator2.default.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  this.__initialized = false;

                case 1:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function deinit() {
          return _ref2.apply(this, arguments);
        }

        return deinit;
      }()

      /**
       * Destroy the service
       * 
       * @async
       */

    }, {
      key: "destroy",
      value: function () {
        var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
          return _regenerator2.default.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  this.__destroying = true;
                  _context3.next = 3;
                  return this.deinit();

                case 3:
                  this.__destroying = false;

                case 4:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function destroy() {
          return _ref3.apply(this, arguments);
        }

        return destroy;
      }()

      /**
       * Check the service is initialized
       * 
       * @returns {boolean}
       */

    }, {
      key: "isInitialized",
      value: function isInitialized() {
        return !!this.__initialized;
      }

      /**
       * Check the service is destroying
       * 
       * @returns {boolean}
       */

    }, {
      key: "isDestroying",
      value: function isDestroying() {
        return !!this.__destroying;
      }
    }]);
    return Service;
  }();
};

/***/ }),

/***/ "./src/task/transports/interval/index.js":
/*!***********************************************!*\
  !*** ./src/task/transports/interval/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _regenerator = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = __webpack_require__(/*! babel-runtime/helpers/get */ "./node_modules/babel-runtime/helpers/get.js");

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Task = __webpack_require__(/*! ../task */ "./src/task/transports/task/index.js")();
var utils = __webpack_require__(/*! ../../../utils */ "./src/utils.js");

module.exports = function (Parent) {
  /**
   * Interval tasks transport
   */
  return function (_ref) {
    (0, _inherits3.default)(TaskInterval, _ref);

    function TaskInterval() {
      (0, _classCallCheck3.default)(this, TaskInterval);
      return (0, _possibleConstructorReturn3.default)(this, (TaskInterval.__proto__ || (0, _getPrototypeOf2.default)(TaskInterval)).apply(this, arguments));
    }

    (0, _createClass3.default)(TaskInterval, [{
      key: 'add',

      /**
       * @see Task.prototype.add
       */
      value: function () {
        var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(name, interval, fn, options) {
          return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt('return', (0, _get3.default)(TaskInterval.prototype.__proto__ || (0, _getPrototypeOf2.default)(TaskInterval.prototype), 'add', this).call(this, name, utils.getMs(interval), fn, options));

                case 1:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function add(_x, _x2, _x3, _x4) {
          return _ref2.apply(this, arguments);
        }

        return add;
      }()

      /**
       * @see Task.prototype.start
       */

    }, {
      key: 'start',
      value: function () {
        var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(task) {
          var _this2 = this;

          var obj;
          return _regenerator2.default.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return (0, _get3.default)(TaskInterval.prototype.__proto__ || (0, _getPrototypeOf2.default)(TaskInterval.prototype), 'start', this).call(this, task);

                case 2:
                  obj = setInterval(function () {
                    return _this2.run(task);
                  }, task.interval);

                  task.intervalObject = obj;

                case 4:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function start(_x5) {
          return _ref3.apply(this, arguments);
        }

        return start;
      }()

      /**
       * @see Task.prototype.stop
       */

    }, {
      key: 'stop',
      value: function () {
        var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(task) {
          return _regenerator2.default.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  clearInterval(task.intervalObject);
                  _context3.next = 3;
                  return (0, _get3.default)(TaskInterval.prototype.__proto__ || (0, _getPrototypeOf2.default)(TaskInterval.prototype), 'stop', this).call(this, task);

                case 3:
                case 'end':
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function stop(_x6) {
          return _ref4.apply(this, arguments);
        }

        return stop;
      }()
    }]);
    return TaskInterval;
  }(Parent || Task);
};

/***/ }),

/***/ "./src/task/transports/task/index.js":
/*!*******************************************!*\
  !*** ./src/task/transports/task/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _regenerator = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = __webpack_require__(/*! babel-runtime/core-js/object/get-prototype-of */ "./node_modules/babel-runtime/core-js/object/get-prototype-of.js");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = __webpack_require__(/*! babel-runtime/helpers/possibleConstructorReturn */ "./node_modules/babel-runtime/helpers/possibleConstructorReturn.js");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = __webpack_require__(/*! babel-runtime/helpers/get */ "./node_modules/babel-runtime/helpers/get.js");

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = __webpack_require__(/*! babel-runtime/helpers/inherits */ "./node_modules/babel-runtime/helpers/inherits.js");

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var merge = __webpack_require__(/*! lodash/merge */ "./node_modules/lodash/merge.js");
var Service = __webpack_require__(/*! ../../../service */ "./src/service.js")();

module.exports = function (Parent) {
  /**
   * Tasks transport
   */
  return function (_ref) {
    (0, _inherits3.default)(Task, _ref);

    /**
     * @param {Node} node 
     * @param {object} options
     */
    function Task(node) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      (0, _classCallCheck3.default)(this, Task);

      var _this = (0, _possibleConstructorReturn3.default)(this, (Task.__proto__ || (0, _getPrototypeOf2.default)(Task)).apply(this, arguments));

      _this.node = node;

      _this.options = merge({
        showCompletionLogs: true,
        showFailLogs: true
      }, options);

      _this.tasks = {};
      return _this;
    }

    /**
     * Add the task
     */


    (0, _createClass3.default)(Task, [{
      key: 'add',
      value: function () {
        var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(name, interval, fn, options) {
          var task;
          return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  task = merge({
                    interval: interval,
                    fn: fn,
                    name: name
                  }, options);


                  task.isStopped === undefined && (task.isStopped = true);
                  this.tasks[name] = task;

                  if (task.isStopped) {
                    _context.next = 8;
                    break;
                  }

                  _context.next = 6;
                  return this.stop(task);

                case 6:
                  _context.next = 8;
                  return this.start(task);

                case 8:
                  return _context.abrupt('return', task);

                case 9:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function add(_x2, _x3, _x4, _x5) {
          return _ref2.apply(this, arguments);
        }

        return add;
      }()

      /**
       * Get the task
       * 
       * @returns {object} 
       */

    }, {
      key: 'get',
      value: function () {
        var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(name) {
          return _regenerator2.default.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  return _context2.abrupt('return', this.tasks[name] || null);

                case 1:
                case 'end':
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function get(_x6) {
          return _ref3.apply(this, arguments);
        }

        return get;
      }()

      /**
       * Remove the task
       */

    }, {
      key: 'remove',
      value: function () {
        var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(name) {
          var task;
          return _regenerator2.default.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  task = this.tasks[name];

                  if (task) {
                    _context3.next = 3;
                    break;
                  }

                  return _context3.abrupt('return');

                case 3:
                  _context3.t0 = !task.isStopped;

                  if (!_context3.t0) {
                    _context3.next = 7;
                    break;
                  }

                  _context3.next = 7;
                  return this.stop(task);

                case 7:
                  delete this.tasks[name];

                case 8:
                case 'end':
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function remove(_x7) {
          return _ref4.apply(this, arguments);
        }

        return remove;
      }()

      /**
       * Initialize the tasks
       * 
       * @async
       */

    }, {
      key: 'init',
      value: function () {
        var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
          var _args4 = arguments;
          return _regenerator2.default.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  this.startAll();
                  _context4.next = 3;
                  return (0, _get3.default)(Task.prototype.__proto__ || (0, _getPrototypeOf2.default)(Task.prototype), 'init', this).apply(this, _args4);

                case 3:
                case 'end':
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function init() {
          return _ref5.apply(this, arguments);
        }

        return init;
      }()

      /**
       * Deinitialize the tasks
       * 
       * @async
       */

    }, {
      key: 'deinit',
      value: function () {
        var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {
          var _args5 = arguments;
          return _regenerator2.default.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  this.stopAll();
                  _context5.next = 3;
                  return (0, _get3.default)(Task.prototype.__proto__ || (0, _getPrototypeOf2.default)(Task.prototype), 'deinit', this).apply(this, _args5);

                case 3:
                case 'end':
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function deinit() {
          return _ref6.apply(this, arguments);
        }

        return deinit;
      }()

      /**
       * Start all tasks
       */

    }, {
      key: 'startAll',
      value: function () {
        var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
          var key;
          return _regenerator2.default.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.t0 = _regenerator2.default.keys(this.tasks);

                case 1:
                  if ((_context6.t1 = _context6.t0()).done) {
                    _context6.next = 7;
                    break;
                  }

                  key = _context6.t1.value;
                  _context6.next = 5;
                  return this.start(this.tasks[key]);

                case 5:
                  _context6.next = 1;
                  break;

                case 7:
                case 'end':
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function startAll() {
          return _ref7.apply(this, arguments);
        }

        return startAll;
      }()

      /**
       * Stop all tasks
       * 
       * @async
       */

    }, {
      key: 'stopAll',
      value: function () {
        var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7() {
          var key;
          return _regenerator2.default.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.t0 = _regenerator2.default.keys(this.tasks);

                case 1:
                  if ((_context7.t1 = _context7.t0()).done) {
                    _context7.next = 7;
                    break;
                  }

                  key = _context7.t1.value;
                  _context7.next = 5;
                  return this.stop(this.tasks[key]);

                case 5:
                  _context7.next = 1;
                  break;

                case 7:
                case 'end':
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        function stopAll() {
          return _ref8.apply(this, arguments);
        }

        return stopAll;
      }()

      /**
       * Run the task callback
       * 
       * @async
       * @param {object} task
       * @param {number} task.interval
       * @param {function} task.fn
       */

    }, {
      key: 'run',
      value: function () {
        var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(task) {
          return _regenerator2.default.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  if (!task.isStopped) {
                    _context8.next = 3;
                    break;
                  }

                  this.options.showFailLogs && this.node.logger.warn('Task "' + task.name + '" should be started at first');
                  return _context8.abrupt('return');

                case 3:
                  if (!task.isRun) {
                    _context8.next = 6;
                    break;
                  }

                  this.options.showFailLogs && this.node.logger.warn('Task "' + task.name + '" has blocking operations');
                  return _context8.abrupt('return');

                case 6:

                  task.isRun = true;

                  _context8.prev = 7;
                  _context8.next = 10;
                  return task.fn();

                case 10:
                  this.options.showCompletionLogs && this.node.logger.info('Task "' + task.name + '" has been completed');
                  _context8.next = 16;
                  break;

                case 13:
                  _context8.prev = 13;
                  _context8.t0 = _context8['catch'](7);

                  this.options.showFailLogs && this.node.logger.error('Task "' + task.name + '",', _context8.t0.stack);

                case 16:

                  task.isRun = false;

                case 17:
                case 'end':
                  return _context8.stop();
              }
            }
          }, _callee8, this, [[7, 13]]);
        }));

        function run(_x8) {
          return _ref9.apply(this, arguments);
        }

        return run;
      }()

      /**
       * Start the task
       * 
       * @async
       * @param {object} task
       * @param {number} task.interval
       * @param {function} task.fn
       */

    }, {
      key: 'start',
      value: function () {
        var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9(task) {
          return _regenerator2.default.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  task.isStopped = false;

                case 1:
                case 'end':
                  return _context9.stop();
              }
            }
          }, _callee9, this);
        }));

        function start(_x9) {
          return _ref10.apply(this, arguments);
        }

        return start;
      }()

      /**
       * Stop the task
       * 
       * @async
       * @param {object} task
       */

    }, {
      key: 'stop',
      value: function () {
        var _ref11 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee10(task) {
          return _regenerator2.default.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  task.isStopped = true;

                case 1:
                case 'end':
                  return _context10.stop();
              }
            }
          }, _callee10, this);
        }));

        function stop(_x10) {
          return _ref11.apply(this, arguments);
        }

        return stop;
      }()
    }]);
    return Task;
  }(Parent || Service);
};

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _regenerator = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = __webpack_require__(/*! babel-runtime/core-js/promise */ "./node_modules/babel-runtime/core-js/promise.js");

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = __webpack_require__(/*! babel-runtime/helpers/asyncToGenerator */ "./node_modules/babel-runtime/helpers/asyncToGenerator.js");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _keys = __webpack_require__(/*! babel-runtime/core-js/object/keys */ "./node_modules/babel-runtime/core-js/object/keys.js");

var _keys2 = _interopRequireDefault(_keys);

var _stringify = __webpack_require__(/*! babel-runtime/core-js/json/stringify */ "./node_modules/babel-runtime/core-js/json/stringify.js");

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = __webpack_require__(/*! babel-runtime/helpers/typeof */ "./node_modules/babel-runtime/helpers/typeof.js");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var validateIP = __webpack_require__(/*! validate-ip-node */ "./src/browser/client/mock/index.js");
var bytes = __webpack_require__(/*! bytes */ "./node_modules/bytes/index.js");
var ms = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
var lookup = __webpack_require__(/*! lookup-dns-cache */ "./src/browser/client/mock/index.js").lookup;
var tcpPortUsed = __webpack_require__(/*! tcp-port-used */ "./src/browser/client/mock/index.js");
var ip6addr = __webpack_require__(/*! ip6addr */ "./node_modules/ip6addr/ip6addr.js");
var errors = __webpack_require__(/*! ./errors */ "./src/errors.js");

var utils = {
  hostValidationRegex: /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9-]*[A-Za-z0-9])$/
};

/**
 * Validate the schema
 * 
 * @param {object|array|string} schema
 * @param {*} data
 */
utils.validateSchema = function (schema, data) {
  var _this = this;

  if (Array.isArray(schema) || (typeof schema === 'undefined' ? 'undefined' : (0, _typeof3.default)(schema)) != 'object') {
    schema = { type: schema };
  }

  var getHumanData = function getHumanData() {
    return (0, _stringify2.default)(data, null, 2);
  };
  var getHumanSchema = function getHumanSchema() {
    return (0, _stringify2.default)(schema, null, 2);
  };
  var schemaType = Array.isArray(schema.type) ? schema.type : [schema.type];
  var dataType = Array.isArray(data) ? 'array' : typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data);

  if (schemaType.indexOf(dataType) == -1) {
    var msg = 'Wrong data type "' + dataType + '" instead of "' + schemaType + '" ' + getHumanData() + ' for ' + getHumanSchema();
    throw new errors.WorkError(msg, 'ERR_STORACLE_VALIDATE_SCHEMA_WRONG_DATA_TYPE');
  }

  if (dataType == 'array') {
    var minLength = typeof schema.minLength == 'function' ? minLength(data) : schema.minLength;
    var maxLength = typeof schema.maxLength == 'function' ? maxLength(data) : schema.maxLength;

    if (minLength && data.length < minLength) {
      var _msg = 'Wrong array min length ' + getHumanData() + ' for ' + getHumanSchema();
      throw new errors.WorkError(_msg, 'ERR_STORACLE_VALIDATE_SCHEMA_WRONG_ARRAY_MIN_LENGTH');
    }

    if (maxLength && data.length > maxLength) {
      var _msg2 = 'Wrong array max length ' + getHumanData() + ' for ' + getHumanSchema();
      throw new errors.WorkError(_msg2, 'ERR_STORACLE_VALIDATE_SCHEMA_WRONG_ARRAY_MAX_LENGTH');
    }

    if (schema.items) {
      data.forEach(function (item) {
        return _this.validateSchema(schema.items, item);
      });
    }
  } else if (dataType == 'object') {
    var props = schema.props || {};
    var required = schema.required;

    if (required && !Array.isArray(required)) {
      throw new Error('Option "required" for ' + getHumanSchema() + ' must be an array');
    }

    if (schema.canBeNull && data === null) {
      return;
    }

    if (schema.canBeNull === false && data === null) {
      var _msg3 = 'Data for ' + getHumanSchema() + ' can\'t be null';
      throw new errors.WorkError(_msg3, 'ERR_STORACLE_VALIDATE_SCHEMA_NULL');
    }

    if (schema.strict) {
      var schemaKeys = (0, _keys2.default)(props).sort();
      var dataKeys = (0, _keys2.default)(data).sort();

      if (schemaKeys.toString() != dataKeys.toString()) {
        var _msg4 = 'Wrong strict object structure ' + getHumanData() + ' for ' + getHumanSchema();
        throw new errors.WorkError(_msg4, 'ERR_STORACLE_VALIDATE_SCHEMA_STRICT');
      }
    }

    if (schema.expected) {
      for (var key in data) {
        if (!props.hasOwnProperty(key)) {
          var _msg5 = 'Wrong expected object structure ' + getHumanData() + ' for ' + getHumanSchema();
          throw new errors.WorkError(_msg5, 'ERR_STORACLE_VALIDATE_SCHEMA_EXPECTED');
        }
      }
    }

    var requiredKeys = {};
    required && required.forEach(function (item) {
      return requiredKeys[item] = true;
    });

    for (var prop in props) {
      if (!data.hasOwnProperty(prop)) {
        if (required && requiredKeys[prop]) {
          var _msg6 = 'Property "' + prop + '" is required in ' + getHumanData() + ' for ' + getHumanSchema();
          throw new errors.WorkError(_msg6, 'ERR_STORACLE_VALIDATE_SCHEMA_REQUIRED_PROPS');
        }

        continue;
      }

      this.validateSchema(props[prop], data[prop]);
    }
  }

  if (!schema.hasOwnProperty('value')) {
    return;
  }

  var valid = void 0;

  if (typeof schema.value == 'function') {
    valid = schema.value(data);
  } else if (schema.value instanceof RegExp) {
    valid = String(data).match(schema.value);
  } else {
    var value = Array.isArray(schema.value) ? schema.value : [schema.value];
    valid = value.indexOf(data) != -1;
  }

  if (!valid) {
    var _msg7 = 'Validation is failed for ' + getHumanData();
    throw new errors.WorkError(_msg7, 'ERR_STORACLE_VALIDATE_SCHEMA_VALUE');
  }
};

/**
 * Check it is the browser environment here
 * 
 * @returns {boolean}
 */
utils.isBrowserEnv = function () {
  return (typeof window === 'undefined' ? 'undefined' : (0, _typeof3.default)(window)) == 'object';
};

/**
 * Get a random element from the array
 * 
 * @param {array} arr
 * @returns {*}
 */
utils.getRandomElement = function (arr) {
  return arr[Math.floor(Math.random() * arr.length)];
};

/**
 * Convert the string to milliseconds
 * 
 * @param {string|integer} val
 * @returns {integer}
 */
utils.getMs = function (val) {
  if (typeof val != 'string' || val == 'auto') {
    return val;
  }

  return ms(val);
};

/**
 * Convert the string to bytes
 * 
 * @param {string|integer} val
 * @returns {integer|string}
 */
utils.getBytes = function (val) {
  if (typeof val != 'string' || val.match('%') || val == 'auto') {
    return val;
  }

  return bytes(val);
};

/**
 * Get the cpu usage percent
 * 
 * @async
 * @param {object} options
 * @returns {float}
 */
utils.getCpuUsage = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return _regenerator2.default.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return new _promise2.default(function (resolve, reject) {
            var startUsage = process.cpuUsage();
            var startTime = process.hrtime();

            setTimeout(function () {
              try {
                var info = process.cpuUsage(startUsage);
                var elapTime = process.hrtime(startTime);
                var elapTimeUs = elapTime[0] * 1000000 + elapTime[1] / 1000;
                var cpuPercent = 100 * (info.user + info.system) / elapTimeUs;
                resolve(cpuPercent);
              } catch (err) {
                reject(err);
              }
            }, options.timeout || 1000);
          });

        case 2:
          return _context.abrupt('return', _context.sent);

        case 3:
        case 'end':
          return _context.stop();
      }
    }
  }, _callee, this);
}));

/**
 * Check the port is used
 * 
 * @async
 * @param {integer} port
 * @returns {boolean}
 */
utils.isPortUsed = function () {
  var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(port) {
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return tcpPortUsed.check(+port, 'localhost');

          case 2:
            return _context2.abrupt('return', _context2.sent);

          case 3:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function (_x2) {
    return _ref2.apply(this, arguments);
  };
}();

/**
 * Get an ip address of the hostname
 * 
 * @async
 * @param {string} hostname
 * @returns {string}
 */
utils.getHostIp = function () {
  var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(hostname) {
    return _regenerator2.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!(hostname == 'localhost')) {
              _context3.next = 2;
              break;
            }

            return _context3.abrupt('return', '127.0.0.1');

          case 2:
            if (!this.isValidIp(hostname)) {
              _context3.next = 4;
              break;
            }

            return _context3.abrupt('return', hostname);

          case 4:
            _context3.next = 6;
            return new _promise2.default(function (resolve, reject) {
              lookup(hostname, function (err, ip) {
                if (err) {
                  if (err.code == 'ENOTFOUND') {
                    return resolve(null);
                  }

                  return reject(err);
                }

                return resolve(ip);
              });
            });

          case 6:
            return _context3.abrupt('return', _context3.sent);

          case 7:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  return function (_x3) {
    return _ref3.apply(this, arguments);
  };
}();

/**
 * Get the address ip
 * 
 * @see utils.getHostIp
 * @param {string} address
 */
utils.getAddressIp = function () {
  var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(address) {
    return _regenerator2.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return this.getHostIp(this.splitAddress(address)[0]);

          case 2:
            return _context4.abrupt('return', _context4.sent);

          case 3:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));

  return function (_x4) {
    return _ref4.apply(this, arguments);
  };
}();

/**
 * Create a requests timer
 * 
 * @async
 * @param {number} timeout 
 * @param {function} fn 
 */
utils.getRequestTimer = function (timeout) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var last = Date.now();

  return function (fixArr) {
    if (timeout === undefined) {
      return;
    }

    var now = Date.now();
    timeout -= now - last;
    last = now;

    if (fixArr && !Array.isArray(fixArr)) {
      fixArr = [fixArr];
    }

    if (fixArr) {
      var dev = fixArr.reduce(function (a, b) {
        return a + b;
      }) / timeout;
      var res = dev > 1 ? fixArr[0] / dev : fixArr[0];
      var min = options.min > timeout ? timeout : options.min;
      min && res < min && (res = min);
      return res > 0 ? res : 0;
    }

    return timeout;
  };
};

/**
 * Get the client remote ip address
 * 
 * @param {http.ClientRequest} req 
 * @returns {string}
 */
utils.getRemoteIp = function (req) {
  var ip = (req.headers['x-forwarded-for'] || req.connection.remoteAddress || '').split(',')[0].trim();

  if (ip.match(':')) {
    ip = ip.replace('::1', '127.0.0.1');
    ip.match('.') && (ip = ip.replace(/^::ffff:/, ''));
    this.isIpv6(ip) && (ip = this.getFullIpv6(ip));
  }

  return ip;
};

/**
 * Get the ip address (v6) in the full format
 * 
 * @param {string} ip
 * @returns {string}
 */
utils.getFullIpv6 = function (ip) {
  return ip6addr.parse(ip).toString({ format: 'v6', zeroElide: false, zeroPad: true });
};

/**
 * Check the ip address is v6
 * 
 * @param {string} ip
 * @returns {boolean}
 */
utils.isIpv6 = function (ip) {
  return !!(typeof ip == 'string' && ip.match(':') && validateIP(ip));
};

/**
 * Convert ipv4 to ipv6 format
 * 
 * @param {string} ip
 * @returns {string}
 */
utils.ipv4Tov6 = function (ip) {
  return this.getFullIpv6('::ffff:' + ip);
};

/**
 * Check the two ip addresses are equal
 * 
 * @param {string} a
 * @param {string} b
 * @returns {boolean}
 */
utils.isIpEqual = function (a, b) {
  return ip6addr.compare(ip6addr.parse(a), ip6addr.parse(b)) == 0;
};

/**
 * Create an address from the hostname and port
 * 
 * @param {string} hostname
 * @param {integer} port
 * @returns {string}
 */
utils.createAddress = function (hostname, port) {
  if (this.isIpv6(hostname)) {
    return '[' + this.getFullIpv6(hostname) + ']:' + port;
  }

  return hostname + ':' + port;
};

/**
 * Check the port is valid
 * 
 * @param {string} port
 * @returns {boolean}
 */
utils.isValidPort = function (port) {
  return +port > 0 && +port <= 65535;
};

/**
 * Check the ip address is valid
 * 
 * @param {string} ip
 * @returns {boolean}
 */
utils.isValidIp = function (ip) {
  return validateIP(ip);
};

/**
 * Check the hostname is valid
 * 
 * @param {string} hostname
 * @returns {boolean}
 */
utils.isValidHostname = function (hostname) {
  if (typeof hostname != 'string') {
    return false;
  }

  return this.hostValidationRegex.test(hostname) || this.isValidIp(hostname);
};

/**
 * Check the address is valid
 * 
 * @param {string} address - address as "ip:port"
 * @returns {boolean}
 */
utils.isValidAddress = function (address) {
  if (!address || typeof address != 'string') {
    return false;
  }

  var parts = this.splitAddress(address);
  var host = parts[0];
  var port = parts[1];
  return this.isValidHostname(host) && this.isValidPort(port);
};

/**
 * Split the address to a hostname and port
 * 
 * @param {string} address
 * @returns {string[]}
 */
utils.splitAddress = function (address) {
  var sp = void 0;

  if (!address || typeof address != 'string') {
    return [];
  }

  if (address.match(']')) {
    sp = address.split(']:');
    return [this.getFullIpv6(sp[0].slice(1)), +sp[1]];
  }

  sp = address.split(':');
  return [sp[0], +sp[1]];
};

/**
 * Create a request timeout error
 * 
 * @returns {Error}
 */
utils.createRequestTimeoutError = function () {
  var err = new Error('Request timed out');
  err.code = 'ERR_SPREADABLE_REQUEST_TIMEDOUT';
  return err;
};

/**
 * Check the error is the request timeout error
 * 
 * @param {Error} err
 * @returns {boolean}
 */
utils.isRequestTimeoutError = function (err) {
  return ['ESOCKETTIMEDOUT', 'ETIMEDOUT'].indexOf(err.code) != -1 || err.type == 'request-timeout';
};

module.exports = utils;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ 0:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYXNzZXJ0LXBsdXMvYXNzZXJ0LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL251bWJlci9pcy1maW5pdGUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbnVtYmVyL2lzLW5hbi5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9udW1iZXIvbWF4LXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9udW1iZXIvbWluLXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9pcy1leHRlbnNpYmxlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXQtaW1tZWRpYXRlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaGFzLWluc3RhbmNlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvc3BlY2llcy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2dldC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9idWlsdGluLXN0YXR1cy1jb2Rlcy9icm93c2VyLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvYnl0ZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vYXJyYXkvZnJvbS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9udW1iZXIvaXMtZmluaXRlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9pcy1uYW4uanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbnVtYmVyL21heC1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vbnVtYmVyL21pbi1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbi5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktc3ltYm9scy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvaXMtZXh0ZW5zaWJsZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5cy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvcHJldmVudC1leHRlbnNpb25zLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LWltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaGFzLWluc3RhbmNlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL3NwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Zvci1vZi5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pbnZva2UuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWljcm90YXNrLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wZXJmb3JtLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb21pc2UtcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VzZXItYWdlbnQuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4uanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnByb21pc2UudHJ5LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2V4dHNwcmludGYvbGliL2V4dHNwcmludGYuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbGliL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9odHRwcy1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9pcDZhZGRyL2lwNmFkZHIuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEvbGliL3ZhbGlkYXRlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvanNwcmltL2xpYi9qc3ByaW0uanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnbk1lcmdlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYXRpdmUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNZXJnZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlRGVlcC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weU9iamVjdC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQXNzaWduZXIuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5c0luLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zYWZlR2V0LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2hvcnRPdXQuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0dldC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlT2JqZWN0LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZXJnZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9QbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9icm93c2VyLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy9zdHJlYW0taHR0cC9saWIvY2FwYWJpbGl0eS5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL3N0cmVhbS1odHRwL2xpYi9yZXF1ZXN0LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL3Jlc3BvbnNlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvdG8tYXJyYXlidWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL25vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vbm9kZV9tb2R1bGVzL3ZlcnJvci9saWIvdmVycm9yLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9ub2RlX21vZHVsZXMveHRlbmQvaW1tdXRhYmxlLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9zcmMvYnJvd3Nlci9jbGllbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL3NyYy9icm93c2VyL2NsaWVudC9tb2NrL2luZGV4LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9zcmMvY2xpZW50LmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9zcmMvZXJyb3JzLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvLi9zcmMvbG9nZ2VyL3RyYW5zcG9ydHMvY29uc29sZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vc3JjL2xvZ2dlci90cmFuc3BvcnRzL2xvZ2dlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vc3JjL3NlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL3NyYy90YXNrL3RyYW5zcG9ydHMvaW50ZXJ2YWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS8uL3NyYy90YXNrL3RyYW5zcG9ydHMvdGFzay9pbmRleC5qcyIsIndlYnBhY2s6Ly9DbGllbnRTcHJlYWRhYmxlLy4vc3JjL3V0aWxzLmpzIiwid2VicGFjazovL0NsaWVudFNwcmVhZGFibGUvdXRpbCAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vQ2xpZW50U3ByZWFkYWJsZS91dGlsIChpZ25vcmVkKT80NjY5Il0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJTdHJlYW0iLCJ1dGlsIiwiVVVJRF9SRUdFWFAiLCJfY2FwaXRhbGl6ZSIsInN0ciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJfdG9zcyIsIm5hbWUiLCJleHBlY3RlZCIsIm9wZXIiLCJhcmciLCJhY3R1YWwiLCJBc3NlcnRpb25FcnJvciIsIm1lc3NhZ2UiLCJmb3JtYXQiLCJ1bmRlZmluZWQiLCJvcGVyYXRvciIsInN0YWNrU3RhcnRGdW5jdGlvbiIsImNhbGxlciIsIl9nZXRDbGFzcyIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsIm5vb3AiLCJ0eXBlcyIsImJvb2wiLCJjaGVjayIsImZ1bmMiLCJzdHJpbmciLCJvYmplY3QiLCJudW1iZXIiLCJpc05hTiIsImZpbml0ZSIsImlzRmluaXRlIiwiYnVmZmVyIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJhcnJheSIsIkFycmF5IiwiaXNBcnJheSIsInN0cmVhbSIsImRhdGUiLCJEYXRlIiwicmVnZXhwIiwiUmVnRXhwIiwidXVpZCIsInRlc3QiLCJfc2V0RXhwb3J0cyIsIm5kZWJ1ZyIsImtleXMiLCJvdXQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9OREVCVUciLCJtc2ciLCJmb3JFYWNoIiwiayIsInR5cGUiLCJpIiwibGVuZ3RoIiwibW9kdWxlIiwiZXhwb3J0cyIsIm9iamVjdEFzc2lnbiIsImNvbXBhcmUiLCJhIiwiYiIsIngiLCJ5IiwibGVuIiwiTWF0aCIsIm1pbiIsImdsb2JhbCIsIl9pc0J1ZmZlciIsImhhc093biIsImhhc093blByb3BlcnR5IiwicFNsaWNlIiwiZnVuY3Rpb25zSGF2ZU5hbWVzIiwiZm9vIiwicFRvU3RyaW5nIiwib2JqIiwiaXNWaWV3IiwiYXJyYnVmIiwiQXJyYXlCdWZmZXIiLCJEYXRhVmlldyIsIm9rIiwicmVnZXgiLCJnZXROYW1lIiwiaXNGdW5jdGlvbiIsIm1hdGNoIiwib3B0aW9ucyIsImdlbmVyYXRlZE1lc3NhZ2UiLCJnZXRNZXNzYWdlIiwiZmFpbCIsIkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJlcnIiLCJzdGFjayIsImZuX25hbWUiLCJpZHgiLCJpbmRleE9mIiwibmV4dF9saW5lIiwic3Vic3RyaW5nIiwiaW5oZXJpdHMiLCJ0cnVuY2F0ZSIsInMiLCJuIiwiaW5zcGVjdCIsInNvbWV0aGluZyIsInJhd25hbWUiLCJzZWxmIiwidmFsdWUiLCJlcXVhbCIsIm5vdEVxdWFsIiwiZGVlcEVxdWFsIiwiX2RlZXBFcXVhbCIsImRlZXBTdHJpY3RFcXVhbCIsInN0cmljdCIsIm1lbW9zIiwiaXNEYXRlIiwiZ2V0VGltZSIsImlzUmVnRXhwIiwic291cmNlIiwibXVsdGlsaW5lIiwibGFzdEluZGV4IiwiaWdub3JlQ2FzZSIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIlVpbnQ4QXJyYXkiLCJhY3R1YWxJbmRleCIsInB1c2giLCJvYmpFcXVpdiIsImlzQXJndW1lbnRzIiwiYWN0dWFsVmlzaXRlZE9iamVjdHMiLCJpc1ByaW1pdGl2ZSIsImFJc0FyZ3MiLCJiSXNBcmdzIiwia2EiLCJvYmplY3RLZXlzIiwia2IiLCJrZXkiLCJzb3J0Iiwibm90RGVlcEVxdWFsIiwibm90RGVlcFN0cmljdEVxdWFsIiwic3RyaWN0RXF1YWwiLCJub3RTdHJpY3RFcXVhbCIsImV4cGVjdGVkRXhjZXB0aW9uIiwiZSIsImlzUHJvdG90eXBlT2YiLCJfdHJ5QmxvY2siLCJibG9jayIsImVycm9yIiwiX3Rocm93cyIsInNob3VsZFRocm93IiwiVHlwZUVycm9yIiwidXNlclByb3ZpZGVkTWVzc2FnZSIsImlzVW53YW50ZWRFeGNlcHRpb24iLCJpc0Vycm9yIiwiaXNVbmV4cGVjdGVkRXhjZXB0aW9uIiwidGhyb3dzIiwiZG9lc05vdFRocm93IiwiaWZFcnJvciIsIl9fZXNNb2R1bGUiLCJfcHJvbWlzZSIsIl9wcm9taXNlMiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJkZWZhdWx0IiwiZm4iLCJnZW4iLCJhcHBseSIsImFyZ3VtZW50cyIsInJlc29sdmUiLCJyZWplY3QiLCJzdGVwIiwiaW5mbyIsImRvbmUiLCJ0aGVuIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9kZWZpbmVQcm9wZXJ0eSIsIl9kZWZpbmVQcm9wZXJ0eTIiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2dldFByb3RvdHlwZU9mIiwiX2dldFByb3RvdHlwZU9mMiIsIl9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yMiIsImdldCIsInByb3BlcnR5IiwicmVjZWl2ZXIiLCJGdW5jdGlvbiIsImRlc2MiLCJwYXJlbnQiLCJnZXR0ZXIiLCJfc2V0UHJvdG90eXBlT2YiLCJfc2V0UHJvdG90eXBlT2YyIiwiX2NyZWF0ZSIsIl9jcmVhdGUyIiwiX3R5cGVvZjIiLCJfdHlwZW9mMyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNvbnN0cnVjdG9yIiwiX19wcm90b19fIiwiUmVmZXJlbmNlRXJyb3IiLCJfZnJvbSIsIl9mcm9tMiIsImFyciIsImFycjIiLCJfaXRlcmF0b3IiLCJfaXRlcmF0b3IyIiwiX3N5bWJvbCIsIl9zeW1ib2wyIiwiX3R5cGVvZiIsImJ5dGVMZW5ndGgiLCJ0b0J5dGVBcnJheSIsImZyb21CeXRlQXJyYXkiLCJsb29rdXAiLCJyZXZMb29rdXAiLCJBcnIiLCJjb2RlIiwiY2hhckNvZGVBdCIsImdldExlbnMiLCJiNjQiLCJ2YWxpZExlbiIsInBsYWNlSG9sZGVyc0xlbiIsImxlbnMiLCJfYnl0ZUxlbmd0aCIsInRtcCIsImN1ckJ5dGUiLCJ0cmlwbGV0VG9CYXNlNjQiLCJudW0iLCJlbmNvZGVDaHVuayIsInVpbnQ4Iiwic3RhcnQiLCJlbmQiLCJvdXRwdXQiLCJqb2luIiwiZXh0cmFCeXRlcyIsInBhcnRzIiwibWF4Q2h1bmtMZW5ndGgiLCJsZW4yIiwiYmFzZTY0IiwiaWVlZTc1NCIsIlNsb3dCdWZmZXIiLCJJTlNQRUNUX01BWF9CWVRFUyIsIlRZUEVEX0FSUkFZX1NVUFBPUlQiLCJ0eXBlZEFycmF5U3VwcG9ydCIsImtNYXhMZW5ndGgiLCJzdWJhcnJheSIsImNyZWF0ZUJ1ZmZlciIsInRoYXQiLCJSYW5nZUVycm9yIiwiZW5jb2RpbmdPck9mZnNldCIsImFsbG9jVW5zYWZlIiwiZnJvbSIsInBvb2xTaXplIiwiX2F1Z21lbnQiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tU3RyaW5nIiwiZnJvbU9iamVjdCIsImFzc2VydFNpemUiLCJzaXplIiwiYWxsb2MiLCJmaWxsIiwiZW5jb2RpbmciLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93IiwiaXNFbmNvZGluZyIsIndyaXRlIiwiZnJvbUFycmF5TGlrZSIsImJ5dGVPZmZzZXQiLCJjb3B5IiwiaXNuYW4iLCJkYXRhIiwiU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJjb25jYXQiLCJsaXN0IiwicG9zIiwiYnVmIiwibG93ZXJlZENhc2UiLCJ1dGY4VG9CeXRlcyIsImJhc2U2NFRvQnl0ZXMiLCJzbG93VG9TdHJpbmciLCJoZXhTbGljZSIsInV0ZjhTbGljZSIsImFzY2lpU2xpY2UiLCJsYXRpbjFTbGljZSIsImJhc2U2NFNsaWNlIiwidXRmMTZsZVNsaWNlIiwic3dhcCIsIm0iLCJzd2FwMTYiLCJzd2FwMzIiLCJzd2FwNjQiLCJlcXVhbHMiLCJtYXgiLCJ0aGlzU3RhcnQiLCJ0aGlzRW5kIiwidGhpc0NvcHkiLCJ0YXJnZXRDb3B5IiwiYmlkaXJlY3Rpb25hbEluZGV4T2YiLCJ2YWwiLCJkaXIiLCJhcnJheUluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJqIiwiaW5jbHVkZXMiLCJoZXhXcml0ZSIsIm9mZnNldCIsIk51bWJlciIsInJlbWFpbmluZyIsInN0ckxlbiIsInBhcnNlZCIsInBhcnNlSW50Iiwic3Vic3RyIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJ0b0pTT04iLCJfYXJyIiwicmVzIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsImZyb21DaGFyQ29kZSIsInJldCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4IiwiZmxvb3IiLCJvYmplY3RXcml0ZVVJbnQxNiIsImxpdHRsZUVuZGlhbiIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwib2JqZWN0V3JpdGVVSW50MzIiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsInN1YiIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0Iiwic2V0IiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInN0cmluZ3RyaW0iLCJyZXBsYWNlIiwidHJpbSIsInVuaXRzIiwiSW5maW5pdHkiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiYyIsImhpIiwibG8iLCJzcmMiLCJkc3QiLCJwYXJzZSIsImZvcm1hdFRob3VzYW5kc1JlZ0V4cCIsImZvcm1hdERlY2ltYWxzUmVnRXhwIiwibWFwIiwibWIiLCJnYiIsInRiIiwicGIiLCJwYXJzZVJlZ0V4cCIsIm1hZyIsImFicyIsInRob3VzYW5kc1NlcGFyYXRvciIsInVuaXRTZXBhcmF0b3IiLCJkZWNpbWFsUGxhY2VzIiwiZml4ZWREZWNpbWFscyIsIkJvb2xlYW4iLCJ1bml0IiwidG9GaXhlZCIsInJlc3VsdHMiLCJleGVjIiwiZmxvYXRWYWx1ZSIsInBhcnNlRmxvYXQiLCJjb3JlIiwiJEpTT04iLCJKU09OIiwic3RyaW5naWZ5IiwiaXQiLCJhc3NpZ24iLCIkT2JqZWN0IiwiY3JlYXRlIiwiUCIsIkQiLCJUIiwiZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldFByb3RvdHlwZU9mIiwiaXNFeHRlbnNpYmxlIiwicHJldmVudEV4dGVuc2lvbnMiLCJzZXRQcm90b3R5cGVPZiIsIlByb21pc2UiLCJzZXRJbW1lZGlhdGUiLCJmIiwiU3ltYm9sIiwiZm9yYmlkZGVuRmllbGQiLCJpc09iamVjdCIsInRvSU9iamVjdCIsInRvTGVuZ3RoIiwidG9BYnNvbHV0ZUluZGV4IiwiSVNfSU5DTFVERVMiLCIkdGhpcyIsImVsIiwiZnJvbUluZGV4IiwiTyIsImluZGV4IiwiY29mIiwiVEFHIiwiQVJHIiwidHJ5R2V0IiwiQiIsImNhbGxlZSIsInZlcnNpb24iLCJfX2UiLCIkZGVmaW5lUHJvcGVydHkiLCJjcmVhdGVEZXNjIiwiYUZ1bmN0aW9uIiwiZG9jdW1lbnQiLCJpcyIsImNyZWF0ZUVsZW1lbnQiLCJzcGxpdCIsImdldEtleXMiLCJnT1BTIiwicElFIiwicmVzdWx0IiwiZ2V0U3ltYm9scyIsInN5bWJvbHMiLCJpc0VudW0iLCJjdHgiLCJoaWRlIiwiaGFzIiwiUFJPVE9UWVBFIiwiJGV4cG9ydCIsIklTX0ZPUkNFRCIsIkYiLCJJU19HTE9CQUwiLCJHIiwiSVNfU1RBVElDIiwiUyIsIklTX1BST1RPIiwiSVNfQklORCIsIklTX1dSQVAiLCJXIiwiZXhwUHJvdG8iLCJvd24iLCJDIiwidmlydHVhbCIsIlIiLCJVIiwiaXNBcnJheUl0ZXIiLCJhbk9iamVjdCIsImdldEl0ZXJGbiIsIkJSRUFLIiwiUkVUVVJOIiwiaXRlcmFibGUiLCJlbnRyaWVzIiwiSVRFUkFUT1IiLCJpdGVyRm4iLCJpdGVyYXRvciIsIm5leHQiLCJ3aW5kb3ciLCJfX2ciLCJkUCIsImRvY3VtZW50RWxlbWVudCIsImFyZ3MiLCJ1biIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiSXRlcmF0b3JzIiwiQXJyYXlQcm90byIsInNldFRvU3RyaW5nVGFnIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJOQU1FIiwiTElCUkFSWSIsInJlZGVmaW5lIiwiJGl0ZXJDcmVhdGUiLCJCVUdHWSIsIkZGX0lURVJBVE9SIiwiS0VZUyIsIlZBTFVFUyIsInJldHVyblRoaXMiLCJCYXNlIiwiREVGQVVMVCIsIklTX1NFVCIsIkZPUkNFRCIsImdldE1ldGhvZCIsImtpbmQiLCJwcm90byIsInZhbHVlcyIsIkRFRl9WQUxVRVMiLCJWQUxVRVNfQlVHIiwiJG5hdGl2ZSIsIiRkZWZhdWx0IiwiJGVudHJpZXMiLCIkYW55TmF0aXZlIiwibWV0aG9kcyIsIlNBRkVfQ0xPU0lORyIsInJpdGVyIiwic2tpcENsb3NpbmciLCJzYWZlIiwiaXRlciIsIk1FVEEiLCJzZXREZXNjIiwiaWQiLCJGUkVFWkUiLCJzZXRNZXRhIiwidyIsImZhc3RLZXkiLCJnZXRXZWFrIiwib25GcmVlemUiLCJtZXRhIiwiTkVFRCIsIktFWSIsIm1hY3JvdGFzayIsIk9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIldlYktpdE11dGF0aW9uT2JzZXJ2ZXIiLCJpc05vZGUiLCJoZWFkIiwibGFzdCIsIm5vdGlmeSIsImZsdXNoIiwiZG9tYWluIiwiZXhpdCIsImVudGVyIiwibmV4dFRpY2siLCJuYXZpZ2F0b3IiLCJzdGFuZGFsb25lIiwidG9nZ2xlIiwibm9kZSIsImNyZWF0ZVRleHROb2RlIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJwcm9taXNlIiwidGFzayIsIlByb21pc2VDYXBhYmlsaXR5IiwiJCRyZXNvbHZlIiwiJCRyZWplY3QiLCJ0b09iamVjdCIsIklPYmplY3QiLCIkYXNzaWduIiwiQSIsIksiLCJhTGVuIiwiZFBzIiwiZW51bUJ1Z0tleXMiLCJJRV9QUk9UTyIsIkVtcHR5IiwiY3JlYXRlRGljdCIsImlmcmFtZSIsImx0IiwiZ3QiLCJpZnJhbWVEb2N1bWVudCIsInN0eWxlIiwiZGlzcGxheSIsImFwcGVuZENoaWxkIiwiY29udGVudFdpbmRvdyIsIm9wZW4iLCJjbG9zZSIsIlByb3BlcnRpZXMiLCJJRThfRE9NX0RFRklORSIsInRvUHJpbWl0aXZlIiwiQXR0cmlidXRlcyIsImdPUEQiLCJnT1BOIiwid2luZG93TmFtZXMiLCJnZXRXaW5kb3dOYW1lcyIsIiRrZXlzIiwiaGlkZGVuS2V5cyIsIk9iamVjdFByb3RvIiwibmFtZXMiLCJmYWlscyIsImV4cCIsIlJlZmxlY3QiLCJvd25LZXlzIiwidiIsIm5ld1Byb21pc2VDYXBhYmlsaXR5IiwicHJvbWlzZUNhcGFiaWxpdHkiLCJiaXRtYXAiLCJidWdneSIsIkRFU0NSSVBUT1JTIiwiU1BFQ0lFUyIsImRlZiIsInRhZyIsInN0YXQiLCJzaGFyZWQiLCJ1aWQiLCJTSEFSRUQiLCJzdG9yZSIsIm1vZGUiLCJjb3B5cmlnaHQiLCJ0b0ludGVnZXIiLCJkZWZpbmVkIiwiVE9fU1RSSU5HIiwibCIsImludm9rZSIsImh0bWwiLCJjZWwiLCJzZXRUYXNrIiwiY2xlYXJUYXNrIiwiY2xlYXJJbW1lZGlhdGUiLCJNZXNzYWdlQ2hhbm5lbCIsIkRpc3BhdGNoIiwiY291bnRlciIsInF1ZXVlIiwiT05SRUFEWVNUQVRFQ0hBTkdFIiwiZGVmZXIiLCJjaGFubmVsIiwicG9ydCIsInJ1biIsImxpc3RlbmVyIiwiZXZlbnQiLCJub3ciLCJwb3J0MiIsInBvcnQxIiwib25tZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwiaW1wb3J0U2NyaXB0cyIsInJlbW92ZUNoaWxkIiwic2V0VGltZW91dCIsImNsZWFyIiwiY2VpbCIsInZhbHVlT2YiLCJweCIsInJhbmRvbSIsInVzZXJBZ2VudCIsIndrc0V4dCIsIiRTeW1ib2wiLCJVU0VfU1lNQk9MIiwiJGV4cG9ydHMiLCJjbGFzc29mIiwiZ2V0SXRlcmF0b3JNZXRob2QiLCJjcmVhdGVQcm9wZXJ0eSIsImFycmF5TGlrZSIsIm1hcGZuIiwibWFwcGluZyIsImFkZFRvVW5zY29wYWJsZXMiLCJpdGVyYXRlZCIsIl90IiwiX2kiLCJfayIsIkFyZ3VtZW50cyIsIkhBU19JTlNUQU5DRSIsIkZ1bmN0aW9uUHJvdG8iLCJfaXNGaW5pdGUiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUlOX1NBRkVfSU5URUdFUiIsIiRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCIkZ2V0UHJvdG90eXBlT2YiLCIkaXNFeHRlbnNpYmxlIiwiJHByZXZlbnRFeHRlbnNpb25zIiwiYW5JbnN0YW5jZSIsImZvck9mIiwic3BlY2llc0NvbnN0cnVjdG9yIiwibWljcm90YXNrIiwibmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUiLCJwZXJmb3JtIiwicHJvbWlzZVJlc29sdmUiLCJQUk9NSVNFIiwidmVyc2lvbnMiLCJ2OCIsIiRQcm9taXNlIiwiZW1wdHkiLCJJbnRlcm5hbCIsIm5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSIsIk93blByb21pc2VDYXBhYmlsaXR5IiwiV3JhcHBlciIsIlVTRV9OQVRJVkUiLCJGYWtlUHJvbWlzZSIsIlByb21pc2VSZWplY3Rpb25FdmVudCIsImlzVGhlbmFibGUiLCJpc1JlamVjdCIsIl9uIiwiY2hhaW4iLCJfYyIsIl92IiwiX3MiLCJyZWFjdGlvbiIsImhhbmRsZXIiLCJleGl0ZWQiLCJfaCIsIm9uSGFuZGxlVW5oYW5kbGVkIiwib25VbmhhbmRsZWQiLCJ1bmhhbmRsZWQiLCJpc1VuaGFuZGxlZCIsImNvbnNvbGUiLCJlbWl0Iiwib251bmhhbmRsZWRyZWplY3Rpb24iLCJyZWFzb24iLCJfYSIsIm9ucmVqZWN0aW9uaGFuZGxlZCIsIiRyZWplY3QiLCJfZCIsIl93IiwiJHJlc29sdmUiLCJ3cmFwcGVyIiwiZXhlY3V0b3IiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJyIiwiY2FwYWJpbGl0eSIsImFsbCIsIiRpbmRleCIsImFscmVhZHlDYWxsZWQiLCJyYWNlIiwiJGF0IiwicG9pbnQiLCIkZmFpbHMiLCJ3a3MiLCJ3a3NEZWZpbmUiLCJlbnVtS2V5cyIsImdPUE5FeHQiLCIkR09QRCIsIiREUCIsIl9zdHJpbmdpZnkiLCJISURERU4iLCJUT19QUklNSVRJVkUiLCJTeW1ib2xSZWdpc3RyeSIsIkFsbFN5bWJvbHMiLCJPUFN5bWJvbHMiLCJRT2JqZWN0Iiwic2V0dGVyIiwiZmluZENoaWxkIiwic2V0U3ltYm9sRGVzYyIsInByb3RvRGVzYyIsIndyYXAiLCJzeW0iLCJpc1N5bWJvbCIsIiRkZWZpbmVQcm9wZXJ0aWVzIiwiJGNyZWF0ZSIsIiRwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIkUiLCIkZ2V0T3duUHJvcGVydHlOYW1lcyIsIiRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJJU19PUCIsIiRzZXQiLCJlczZTeW1ib2xzIiwid2VsbEtub3duU3ltYm9scyIsImtleUZvciIsInVzZVNldHRlciIsInVzZVNpbXBsZSIsInJlcGxhY2VyIiwiJHJlcGxhY2VyIiwiZ2V0RGVzYyIsIm9uRmluYWxseSIsImNhbGxiYWNrZm4iLCJUT19TVFJJTkdfVEFHIiwiRE9NSXRlcmFibGVzIiwiQ29sbGVjdGlvbiIsIiR0YXNrIiwib2JqZWN0VG9TdHJpbmciLCJpc0Jvb2xlYW4iLCJpc051bGwiLCJpc051bGxPclVuZGVmaW5lZCIsImlzTnVtYmVyIiwiaXNTdHJpbmciLCJpc1VuZGVmaW5lZCIsInJlIiwiZCIsIm8iLCJSZWZsZWN0QXBwbHkiLCJSZWZsZWN0T3duS2V5cyIsIlByb2Nlc3NFbWl0V2FybmluZyIsIndhcm5pbmciLCJ3YXJuIiwiTnVtYmVySXNOYU4iLCJFdmVudEVtaXR0ZXIiLCJpbml0IiwiX2V2ZW50cyIsIl9ldmVudHNDb3VudCIsIl9tYXhMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwic2V0TWF4TGlzdGVuZXJzIiwiJGdldE1heExpc3RlbmVycyIsImdldE1heExpc3RlbmVycyIsImRvRXJyb3IiLCJldmVudHMiLCJlciIsImNvbnRleHQiLCJsaXN0ZW5lcnMiLCJhcnJheUNsb25lIiwiX2FkZExpc3RlbmVyIiwicHJlcGVuZCIsImV4aXN0aW5nIiwibmV3TGlzdGVuZXIiLCJ1bnNoaWZ0Iiwid2FybmVkIiwiZW1pdHRlciIsImNvdW50IiwiYWRkTGlzdGVuZXIiLCJvbiIsInByZXBlbmRMaXN0ZW5lciIsIm9uY2VXcmFwcGVyIiwiZmlyZWQiLCJyZW1vdmVMaXN0ZW5lciIsIndyYXBGbiIsIl9vbmNlV3JhcCIsInN0YXRlIiwid3JhcHBlZCIsImJpbmQiLCJvbmNlIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsInBvc2l0aW9uIiwib3JpZ2luYWxMaXN0ZW5lciIsInNoaWZ0Iiwic3BsaWNlT25lIiwib2ZmIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiX2xpc3RlbmVycyIsInVud3JhcCIsImV2bGlzdGVuZXIiLCJ1bndyYXBMaXN0ZW5lcnMiLCJyYXdMaXN0ZW5lcnMiLCJsaXN0ZW5lckNvdW50IiwiZXZlbnROYW1lcyIsInBvcCIsIm1vZF9hc3NlcnQiLCJtb2RfdXRpbCIsInNwcmludGYiLCJqc1NwcmludGYiLCJwcmludGYiLCJqc1ByaW50ZiIsImZwcmludGYiLCJqc0ZwcmludGYiLCJmbXQiLCJmbGFncyIsIndpZHRoIiwicHJlY2lzaW9uIiwiY29udmVyc2lvbiIsImxlZnQiLCJwYWQiLCJzaWduIiwiYXJnbiIsImRvUGFkIiwiZHVtcEV4Y2VwdGlvbiIsInN0ZG91dCIsImNociIsImV4IiwiY2F1c2UiLCJjZXgiLCJGb3JtRGF0YSIsImh0dHAiLCJ1cmwiLCJodHRwcyIsInJlcXVlc3QiLCJwYXJhbXMiLCJjYiIsInZhbGlkYXRlUGFyYW1zIiwicHJvdG9jb2wiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsIk5hTiIsInJ0IiwibG9nIiwiTE4yIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsIlRlbXBDdG9yIiwianNwcmltIiwiUGFyc2VFcnJvciIsImlucHV0IiwibW9kdWxvIiwiX2FycmF5VG9PY3RldFN0cmluZyIsIl9pc0FkZHIiLCJhZGRyIiwiX2ZpZWxkcyIsIl9hdHRycyIsIl90b0FkZHIiLCJpcDZhZGRyUGFyc2UiLCJfYXJyYXlUb0hleCIsInplcm9FbGlkZSIsInplcm9QYWQiLCJlbFN0YXJ0IiwiZWxMZW4iLCJfaXB2NE1hcHBlZCIsImNvbXAiLCJfcHJlZml4VG9BZGRyIiwiQWRkciIsIl90b0NJRFIiLCJDSURSIiwic3RyRGVmYXVsdHMiLCJnZXRTdHJPcHQiLCJvcHRzIiwiZ2V0S2luZCIsInY0c3VibmV0IiwiY29udGFpbnMiLCJvcHRpb25hbE9iamVjdCIsImlwdjRCYXJlIiwiaXB2NE1hcHBlZCIsInRvQnVmZmVyIiwidG9Mb25nIiwiY2xvbmUiLCJjbG9uZUFkZHIiLCJtb3ZlZCIsImFuZCIsImFkZHJBbmQiLCJvciIsImFkZHJPciIsIm5vdCIsImFkZHJOb3QiLCJjb21wYXJlTWVtYmVyIiwiaXA2YWRkckNvbXBhcmUiLCJwcmVmaXhMZW4iLCJmaWVsZHMiLCJfcHJlZml4IiwiX21hc2siLCJfYWRkciIsImNpZHJDb250YWlucyIsImZpcnN0IiwiY2lkckZpcnN0IiwiY2lkckxhc3QiLCJlbmRpbmciLCJicm9hZGNhc3QiLCJnZXRCcm9hZGNhc3QiLCJjb21wYXJlQ0lEUiIsImNpZHIiLCJpcDZjaWRyQ29tcGFyZSIsInByZWZpeExlbmd0aCIsImdldFByZWZpeExlbmd0aCIsIm9wdGlvbmFsU3RyaW5nIiwiYWRkcmVzcyIsImdldEFkZHJlc3NDb21wb25lbnQiLCJjaWRyU3RyaW5nIiwiY21wIiwiQWRkclJhbmdlIiwiYmVnaW4iLCJfYmVnaW4iLCJfZW5kIiwiYWRkclJhbmdlQ29udGFpbnMiLCJhZGRyUmFuZ2VGaXJzdCIsImFkZHJSYW5nZUxhc3QiLCJwYXJzZVN0cmluZyIsInBhcnNlTG9uZyIsImlwNkZpZWxkcyIsImlwNEZpZWxkcyIsImV4cEluZGV4IiwiZmllbGQiLCJwYXJzZUludGVnZXIiLCJiYXNlIiwiYWxsb3dTaWduIiwiZmlsbGVyIiwiY3JlYXRlQ0lEUiIsImNyZWF0ZUFkZHJSYW5nZSIsInJvb3QiLCJmYWN0b3J5IiwiZGVmaW5lIiwidmFsaWRhdGUiLCJJbnRlZ2VyIiwicHJpbWl0aXZlQ29uc3RydWN0b3JzIiwic2NoZW1hIiwiY2hhbmdpbmciLCJjaGVja1Byb3BlcnR5Q2hhbmdlIiwiX3ZhbGlkYXRlIiwiX2NoYW5naW5nIiwiZ2V0VHlwZSIsImVycm9ycyIsImNoZWNrUHJvcCIsInBhdGgiLCJhZGRFcnJvciIsInJlYWRvbmx5IiwiY2hlY2tUeXBlIiwidW5pb25FcnJvcnMiLCJwcmlvckVycm9ycyIsInRoZXNlRXJyb3JzIiwicmVxdWlyZWQiLCJkaXNhbGxvdyIsIml0ZW1zIiwiaXRlbXNJc0FycmF5IiwicHJvcERlZiIsImNvZXJjZSIsIm1pbkl0ZW1zIiwibWF4SXRlbXMiLCJwcm9wZXJ0aWVzIiwiYWRkaXRpb25hbFByb3BlcnRpZXMiLCJjaGVja09iaiIsInBhdHRlcm4iLCJtYXhMZW5ndGgiLCJtaW5MZW5ndGgiLCJtaW5pbXVtIiwibWF4aW11bSIsImVudW1lciIsIm1heERlY2ltYWwiLCJvYmpUeXBlRGVmIiwiYWRkaXRpb25hbFByb3AiLCJleGlzdGluZ09ubHkiLCJmaWx0ZXIiLCJyZXF1aXJlcyIsIiRzY2hlbWEiLCJ2YWxpZCIsIm11c3RCZVZhbGlkIiwibW9kX2V4dHNwcmludGYiLCJtb2RfdmVycm9yIiwibW9kX2pzb25zY2hlbWEiLCJkZWVwQ29weSIsImlzRW1wdHkiLCJoYXNLZXkiLCJmb3JFYWNoS2V5IiwicGx1Y2siLCJmbGF0dGVuT2JqZWN0IiwiZmxhdHRlbkl0ZXIiLCJ2YWxpZGF0ZUpzb25PYmplY3QiLCJ2YWxpZGF0ZUpzb25PYmplY3RKUyIsInJhbmRFbHQiLCJleHRyYVByb3BlcnRpZXMiLCJtZXJnZU9iamVjdHMiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJpc284NjAxIiwicmZjMTEyMyIsInBhcnNlRGF0ZVRpbWUiLCJocnRpbWVkaWZmIiwiaHJ0aW1lRGlmZiIsImhydGltZUFjY3VtIiwiaHJ0aW1lQWRkIiwiaHJ0aW1lTmFub3NlYyIsImhydGltZU1pY3Jvc2VjIiwiaHJ0aW1lTWlsbGlzZWMiLCJtYXJrZXIiLCJvYmoxIiwib2JqMiIsImNhbGxiYWNrIiwicGx1Y2t2Iiwia2V5MSIsImRlcHRoIiwiZG9GbGF0dGVuSXRlciIsImFjY3VtIiwiZWFjaCIsInJ2IiwicCIsInByZWZpeCIsInN1ZmZpeCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsImdldFVUQ01pbGxpc2Vjb25kcyIsIlJGQzExMjNfTU9OVEhTIiwiUkZDMTEyM19EQVlTIiwiZ2V0VVRDRGF5IiwibnVtZXJpYyIsIlBJX0RFRkFVTFRTIiwiYWxsb3dQcmVmaXgiLCJhbGxvd1RyYWlsaW5nIiwiYWxsb3dJbXByZWNpc2UiLCJ0cmltV2hpdGVzcGFjZSIsImxlYWRpbmdaZXJvSXNPY3RhbCIsIkNQXzAiLCJDUF85IiwiQ1BfQSIsIkNQX0IiLCJDUF9PIiwiQ1BfVCIsIkNQX1giLCJDUF9aIiwiQ1BfYSIsIkNQX2IiLCJDUF9vIiwiQ1BfdCIsIkNQX3giLCJDUF96IiwiUElfQ09OVl9ERUMiLCJQSV9DT05WX1VDIiwiUElfQ09OVl9MQyIsInVvcHRzIiwiYmFzZU92ZXJyaWRlIiwicGJhc2UiLCJtdWx0IiwiaXNTcGFjZSIsInByZWZpeFRvQmFzZSIsInRyYW5zbGF0ZURpZ2l0IiwicmVwb3J0IiwicHJvcG5hbWUiLCJWRXJyb3IiLCJqc3ZfZGV0YWlscyIsImFzc2VydEhydGltZSIsImFsbG93ZWQiLCJwcm92aWRlZCIsIm92ZXJyaWRlcyIsImRlZmF1bHRzIiwiaCIsImxvbmciLCJmbXRMb25nIiwiZm10U2hvcnQiLCJtcyIsIm1zQWJzIiwicm91bmQiLCJwbHVyYWwiLCJpc1BsdXJhbCIsImdldEdsb2JhbCIsImZldGNoIiwiSGVhZGVycyIsIlJlcXVlc3QiLCJSZXNwb25zZSIsInByb3BJc0VudW1lcmFibGUiLCJzaG91bGRVc2VOYXRpdmUiLCJ0ZXN0MSIsInRlc3QyIiwib3JkZXIyIiwidGVzdDMiLCJsZXR0ZXIiLCJ0byIsImFyZzEiLCJhcmcyIiwiYXJnMyIsImFmdGVyVGlja09uZSIsImFmdGVyVGlja1R3byIsImFmdGVyVGlja1RocmVlIiwiYWZ0ZXJUaWNrIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwiSXRlbSIsInRpdGxlIiwiYnJvd3NlciIsImFyZ3YiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJ1bWFzayIsInByb3AiLCJxcyIsInNlcCIsImVxIiwibWF4S2V5cyIsImtzdHIiLCJ2c3RyIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwieHMiLCJzdHJpbmdpZnlQcmltaXRpdmUiLCJrcyIsImVuY29kZVVSSUNvbXBvbmVudCIsImRlY29kZSIsImVuY29kZSIsInBuYSIsIkR1cGxleCIsIlJlYWRhYmxlIiwiV3JpdGFibGUiLCJtZXRob2QiLCJyZWFkYWJsZSIsImFsbG93SGFsZk9wZW4iLCJvbmVuZCIsIl93cml0YWJsZVN0YXRlIiwiaGlnaFdhdGVyTWFyayIsImVuZGVkIiwib25FbmROVCIsIl9yZWFkYWJsZVN0YXRlIiwiZGVzdHJveWVkIiwiX2Rlc3Ryb3kiLCJQYXNzVGhyb3VnaCIsIlRyYW5zZm9ybSIsIl90cmFuc2Zvcm0iLCJjaHVuayIsIlJlYWRhYmxlU3RhdGUiLCJFRSIsIkVFbGlzdGVuZXJDb3VudCIsIk91clVpbnQ4QXJyYXkiLCJfdWludDhBcnJheVRvQnVmZmVyIiwiX2lzVWludDhBcnJheSIsImRlYnVnVXRpbCIsImRlYnVnIiwiZGVidWdsb2ciLCJCdWZmZXJMaXN0IiwiZGVzdHJveUltcGwiLCJTdHJpbmdEZWNvZGVyIiwia1Byb3h5RXZlbnRzIiwiaXNEdXBsZXgiLCJvYmplY3RNb2RlIiwicmVhZGFibGVPYmplY3RNb2RlIiwiaHdtIiwicmVhZGFibGVId20iLCJyZWFkYWJsZUhpZ2hXYXRlck1hcmsiLCJkZWZhdWx0SHdtIiwicGlwZXMiLCJwaXBlc0NvdW50IiwiZmxvd2luZyIsImVuZEVtaXR0ZWQiLCJyZWFkaW5nIiwic3luYyIsIm5lZWRSZWFkYWJsZSIsImVtaXR0ZWRSZWFkYWJsZSIsInJlYWRhYmxlTGlzdGVuaW5nIiwicmVzdW1lU2NoZWR1bGVkIiwiZGVmYXVsdEVuY29kaW5nIiwiYXdhaXREcmFpbiIsInJlYWRpbmdNb3JlIiwiZGVjb2RlciIsIl9yZWFkIiwiZGVzdHJveSIsIl91bmRlc3Ryb3kiLCJ1bmRlc3Ryb3kiLCJza2lwQ2h1bmtDaGVjayIsInJlYWRhYmxlQWRkQ2h1bmsiLCJhZGRUb0Zyb250Iiwib25Fb2ZDaHVuayIsImNodW5rSW52YWxpZCIsImFkZENodW5rIiwibWF5YmVSZWFkTW9yZSIsIm5lZWRNb3JlRGF0YSIsImVtaXRSZWFkYWJsZSIsImlzUGF1c2VkIiwic2V0RW5jb2RpbmciLCJlbmMiLCJNQVhfSFdNIiwiY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsiLCJob3dNdWNoVG9SZWFkIiwibk9yaWciLCJlbmRSZWFkYWJsZSIsImRvUmVhZCIsImZyb21MaXN0IiwiZW1pdFJlYWRhYmxlXyIsImZsb3ciLCJtYXliZVJlYWRNb3JlXyIsInBpcGUiLCJkZXN0IiwicGlwZU9wdHMiLCJkb0VuZCIsInN0ZGVyciIsImVuZEZuIiwidW5waXBlIiwib251bnBpcGUiLCJ1bnBpcGVJbmZvIiwiaGFzVW5waXBlZCIsImNsZWFudXAiLCJvbmRyYWluIiwicGlwZU9uRHJhaW4iLCJjbGVhbmVkVXAiLCJvbmNsb3NlIiwib25maW5pc2giLCJvbmVycm9yIiwib25kYXRhIiwibmVlZERyYWluIiwiaW5jcmVhc2VkQXdhaXREcmFpbiIsInBhdXNlIiwicmVzdW1lIiwiZGVzdHMiLCJzcGxpY2UiLCJldiIsIm5SZWFkaW5nTmV4dFRpY2siLCJyZXN1bWVfIiwiX3RoaXMiLCJwYXVzZWQiLCJfZnJvbUxpc3QiLCJmcm9tTGlzdFBhcnRpYWwiLCJoYXNTdHJpbmdzIiwiY29weUZyb21CdWZmZXJTdHJpbmciLCJjb3B5RnJvbUJ1ZmZlciIsIm5iIiwidGFpbCIsImVuZFJlYWRhYmxlTlQiLCJhZnRlclRyYW5zZm9ybSIsInRzIiwiX3RyYW5zZm9ybVN0YXRlIiwidHJhbnNmb3JtaW5nIiwid3JpdGVjYiIsIndyaXRlY2h1bmsiLCJycyIsIm5lZWRUcmFuc2Zvcm0iLCJ3cml0ZWVuY29kaW5nIiwidHJhbnNmb3JtIiwiX2ZsdXNoIiwicHJlZmluaXNoIiwiX3dyaXRlIiwiX3RoaXMyIiwiZXJyMiIsIldyaXRlUmVxIiwiQ29ya2VkUmVxdWVzdCIsImVudHJ5IiwiZmluaXNoIiwib25Db3JrZWRGaW5pc2giLCJhc3luY1dyaXRlIiwiV3JpdGFibGVTdGF0ZSIsImludGVybmFsVXRpbCIsImRlcHJlY2F0ZSIsIm5vcCIsIndyaXRhYmxlT2JqZWN0TW9kZSIsIndyaXRhYmxlSHdtIiwid3JpdGFibGVIaWdoV2F0ZXJNYXJrIiwiZmluYWxDYWxsZWQiLCJmaW5pc2hlZCIsIm5vRGVjb2RlIiwiZGVjb2RlU3RyaW5ncyIsIndyaXRpbmciLCJjb3JrZWQiLCJidWZmZXJQcm9jZXNzaW5nIiwib253cml0ZSIsIndyaXRlbGVuIiwiYnVmZmVyZWRSZXF1ZXN0IiwibGFzdEJ1ZmZlcmVkUmVxdWVzdCIsInBlbmRpbmdjYiIsInByZWZpbmlzaGVkIiwiZXJyb3JFbWl0dGVkIiwiYnVmZmVyZWRSZXF1ZXN0Q291bnQiLCJjb3JrZWRSZXF1ZXN0c0ZyZWUiLCJnZXRCdWZmZXIiLCJjdXJyZW50IiwiXyIsInJlYWxIYXNJbnN0YW5jZSIsIndyaXRldiIsIl93cml0ZXYiLCJmaW5hbCIsIl9maW5hbCIsIndyaXRlQWZ0ZXJFbmQiLCJ2YWxpZENodW5rIiwiaXNCdWYiLCJ3cml0ZU9yQnVmZmVyIiwiY29yayIsInVuY29yayIsImNsZWFyQnVmZmVyIiwic2V0RGVmYXVsdEVuY29kaW5nIiwiZGVjb2RlQ2h1bmsiLCJuZXdDaHVuayIsImRvV3JpdGUiLCJvbndyaXRlRXJyb3IiLCJmaW5pc2hNYXliZSIsIm9ud3JpdGVTdGF0ZVVwZGF0ZSIsIm5lZWRGaW5pc2giLCJhZnRlcldyaXRlIiwib253cml0ZURyYWluIiwiaG9sZGVyIiwiYWxsQnVmZmVycyIsImVuZFdyaXRhYmxlIiwiY2FsbEZpbmFsIiwibmVlZCIsImNvcmtSZXEiLCJfY2xhc3NDYWxsQ2hlY2siLCJjb3B5QnVmZmVyIiwiY3VzdG9tIiwicmVhZGFibGVEZXN0cm95ZWQiLCJ3cml0YWJsZURlc3Ryb3llZCIsImVtaXRFcnJvck5UIiwiZyIsImhhZFJ1bnRpbWUiLCJyZWdlbmVyYXRvclJ1bnRpbWUiLCJvbGRSdW50aW1lIiwiT3AiLCJpdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwidG9TdHJpbmdUYWdTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImluTW9kdWxlIiwicnVudGltZSIsImlubmVyRm4iLCJvdXRlckZuIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsIkNvbnRleHQiLCJfaW52b2tlIiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiR2VuU3RhdGVTdXNwZW5kZWRTdGFydCIsIkdlblN0YXRlU3VzcGVuZGVkWWllbGQiLCJHZW5TdGF0ZUV4ZWN1dGluZyIsIkdlblN0YXRlQ29tcGxldGVkIiwiQ29udGludWVTZW50aW5lbCIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUiLCJnZXRQcm90byIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwiR3AiLCJkaXNwbGF5TmFtZSIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5GdW4iLCJtYXJrIiwiYXdyYXAiLCJfX2F3YWl0IiwiQXN5bmNJdGVyYXRvciIsInJlY29yZCIsInVud3JhcHBlZCIsInByZXZpb3VzUHJvbWlzZSIsImVucXVldWUiLCJjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyIsImFzeW5jIiwiZG9uZVJlc3VsdCIsImRlbGVnYXRlIiwiZGVsZWdhdGVSZXN1bHQiLCJtYXliZUludm9rZURlbGVnYXRlIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJhYnJ1cHQiLCJyZXR1cm4iLCJyZXN1bHROYW1lIiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsImxvY3MiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwicmV2ZXJzZSIsIml0ZXJhdG9yTWV0aG9kIiwic2tpcFRlbXBSZXNldCIsInByZXYiLCJzdG9wIiwicm9vdEVudHJ5Iiwicm9vdFJlY29yZCIsInJ2YWwiLCJleGNlcHRpb24iLCJoYW5kbGUiLCJsb2MiLCJjYXVnaHQiLCJoYXNDYXRjaCIsImhhc0ZpbmFsbHkiLCJmaW5hbGx5RW50cnkiLCJjb21wbGV0ZSIsInRocm93biIsImRlbGVnYXRlWWllbGQiLCJjb3B5UHJvcHMiLCJTYWZlQnVmZmVyIiwiX2lzU3RkaW8iLCJkaWRPbkVuZCIsIkNsaWVudFJlcXVlc3QiLCJyZXNwb25zZSIsImV4dGVuZCIsInN0YXR1c0NvZGVzIiwiZGVmYXVsdFByb3RvY29sIiwibG9jYXRpb24iLCJzZWFyY2giLCJob3N0IiwiaG9zdG5hbWUiLCJoZWFkZXJzIiwicmVxIiwiSW5jb21pbmdNZXNzYWdlIiwiQWdlbnQiLCJkZWZhdWx0TWF4U29ja2V0cyIsImdsb2JhbEFnZW50IiwiU1RBVFVTX0NPREVTIiwiTUVUSE9EUyIsIlJlYWRhYmxlU3RyZWFtIiwid3JpdGFibGVTdHJlYW0iLCJXcml0YWJsZVN0cmVhbSIsImFib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsImJsb2JDb25zdHJ1Y3RvciIsIkJsb2IiLCJ4aHIiLCJnZXRYSFIiLCJYTUxIdHRwUmVxdWVzdCIsIlhEb21haW5SZXF1ZXN0IiwiY2hlY2tUeXBlU3VwcG9ydCIsInJlc3BvbnNlVHlwZSIsImhhdmVBcnJheUJ1ZmZlciIsImhhdmVTbGljZSIsImFycmF5YnVmZmVyIiwibXNzdHJlYW0iLCJtb3pjaHVua2VkYXJyYXlidWZmZXIiLCJvdmVycmlkZU1pbWVUeXBlIiwidmJBcnJheSIsIlZCQXJyYXkiLCJ0b0FycmF5QnVmZmVyIiwiclN0YXRlcyIsInJlYWR5U3RhdGVzIiwiZGVjaWRlTW9kZSIsInByZWZlckJpbmFyeSIsInVzZUZldGNoIiwiX29wdHMiLCJfYm9keSIsIl9oZWFkZXJzIiwiYXV0aCIsInNldEhlYWRlciIsIl9tb2RlIiwiX2ZldGNoVGltZXIiLCJfb25GaW5pc2giLCJsb3dlck5hbWUiLCJ1bnNhZmVIZWFkZXJzIiwiZ2V0SGVhZGVyIiwiaGVhZGVyIiwicmVtb3ZlSGVhZGVyIiwiX2Rlc3Ryb3llZCIsImhlYWRlcnNPYmoiLCJib2R5IiwiaGVhZGVyc0xpc3QiLCJrZXlOYW1lIiwic2lnbmFsIiwiZmV0Y2hUaW1lciIsImNvbnRyb2xsZXIiLCJfZmV0Y2hBYm9ydENvbnRyb2xsZXIiLCJyZXF1ZXN0VGltZW91dCIsImFib3J0IiwiY3JlZGVudGlhbHMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJfZmV0Y2hSZXNwb25zZSIsIl9jb25uZWN0IiwiX3hociIsIm9udGltZW91dCIsInNldFJlcXVlc3RIZWFkZXIiLCJfcmVzcG9uc2UiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwiTE9BRElORyIsIkRPTkUiLCJfb25YSFJQcm9ncmVzcyIsIm9ucHJvZ3Jlc3MiLCJzZW5kIiwic3RhdHVzVmFsaWQiLCJzdGF0dXMiLCJmbHVzaEhlYWRlcnMiLCJzZXROb0RlbGF5Iiwic2V0U29ja2V0S2VlcEFsaXZlIiwiVU5TRU5UIiwiT1BFTkVEIiwiSEVBREVSU19SRUNFSVZFRCIsInJhd0hlYWRlcnMiLCJ0cmFpbGVycyIsInJhd1RyYWlsZXJzIiwicmVhZGVyIiwiY2F0Y2giLCJzdGF0dXNDb2RlIiwic3RhdHVzTWVzc2FnZSIsInN0YXR1c1RleHQiLCJfcmVzdW1lRmV0Y2giLCJwaXBlVG8iLCJnZXRSZWFkZXIiLCJfcG9zIiwicmVzcG9uc2VVUkwiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJtYXRjaGVzIiwiX2NoYXJzZXQiLCJtaW1lVHlwZSIsImNoYXJzZXRNYXRjaCIsInJlc3BvbnNlQm9keSIsInRvQXJyYXkiLCJyZXNwb25zZVRleHQiLCJuZXdEYXRhIiwiTVNTdHJlYW1SZWFkZXIiLCJvbmxvYWQiLCJyZWFkQXNBcnJheUJ1ZmZlciIsIl9ub3JtYWxpemVFbmNvZGluZyIsInJldHJpZWQiLCJub3JtYWxpemVFbmNvZGluZyIsIm5lbmMiLCJ0ZXh0IiwidXRmMTZUZXh0IiwidXRmMTZFbmQiLCJmaWxsTGFzdCIsInV0ZjhGaWxsTGFzdCIsImJhc2U2NFRleHQiLCJiYXNlNjRFbmQiLCJzaW1wbGVXcml0ZSIsInNpbXBsZUVuZCIsImxhc3ROZWVkIiwibGFzdFRvdGFsIiwibGFzdENoYXIiLCJ1dGY4RW5kIiwidXRmOFRleHQiLCJ1dGY4Q2hlY2tCeXRlIiwiYnl0ZSIsInV0ZjhDaGVja0luY29tcGxldGUiLCJ1dGY4Q2hlY2tFeHRyYUJ5dGVzIiwidG90YWwiLCJhcnJheUNvcHkiLCJjb25maWciLCJkZXByZWNhdGVkIiwidHJhY2UiLCJsb2NhbFN0b3JhZ2UiLCJkZXNjcmlwdG9ycyIsImZvcm1hdFJlZ0V4cCIsIm9iamVjdHMiLCJub0RlcHJlY2F0aW9uIiwidGhyb3dEZXByZWNhdGlvbiIsInRyYWNlRGVwcmVjYXRpb24iLCJkZWJ1Z3MiLCJkZWJ1Z0Vudmlyb24iLCJOT0RFX0RFQlVHIiwicGlkIiwic2VlbiIsInN0eWxpemUiLCJzdHlsaXplTm9Db2xvciIsImNvbG9ycyIsInNob3dIaWRkZW4iLCJfZXh0ZW5kIiwiY3VzdG9tSW5zcGVjdCIsInN0eWxpemVXaXRoQ29sb3IiLCJmb3JtYXRWYWx1ZSIsInN0eWxlcyIsInN0eWxlVHlwZSIsImFycmF5VG9IYXNoIiwiaGFzaCIsInJlY3Vyc2VUaW1lcyIsInByaW1pdGl2ZSIsImZvcm1hdFByaW1pdGl2ZSIsInZpc2libGVLZXlzIiwiZm9ybWF0RXJyb3IiLCJicmFjZXMiLCJ0b1VUQ1N0cmluZyIsImZvcm1hdEFycmF5IiwiZm9ybWF0UHJvcGVydHkiLCJyZWR1Y2VUb1NpbmdsZVN0cmluZyIsInNpbXBsZSIsImxpbmUiLCJudW1MaW5lc0VzdCIsInJlZHVjZSIsImN1ciIsImFyIiwibW9udGhzIiwidGltZXN0YW1wIiwidGltZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJvcmlnaW4iLCJhZGQiLCJrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wiLCJwcm9taXNpZnkiLCJvcmlnaW5hbCIsInByb21pc2VSZWplY3QiLCJjYWxsYmFja2lmeU9uUmVqZWN0ZWQiLCJuZXdSZWFzb24iLCJjYWxsYmFja2lmeSIsImNhbGxiYWNraWZpZWQiLCJtYXliZUNiIiwicmVqIiwibW9kX2Fzc2VydHBsdXMiLCJtb2RfaXNFcnJvciIsIlNFcnJvciIsIldFcnJvciIsIk11bHRpRXJyb3IiLCJwYXJzZUNvbnN0cnVjdG9yQXJndW1lbnRzIiwic3ByaW50Zl9hcmdzIiwic2hvcnRtZXNzYWdlIiwianNlX3Nob3J0bXNnIiwianNlX2NhdXNlIiwic2tpcENhdXNlTWVzc2FnZSIsImpzZV9pbmZvIiwiY29uc3RydWN0b3JPcHQiLCJ2ZV90b1N0cmluZyIsInZlX2NhdXNlIiwiZmluZENhdXNlQnlOYW1lIiwiaGFzQ2F1c2VXaXRoTmFtZSIsImZ1bGxTdGFjayIsImVycm9yRnJvbUxpc3QiLCJhcnJheU9mT2JqZWN0IiwiZXJyb3JGb3JFYWNoIiwiaXRlckVycm9yIiwiYXNlX2Vycm9ycyIsIm1lX2Vycm9ycyIsIndlX3RvU3RyaW5nIiwid2VfY2F1c2UiLCJ3ZWJwYWNrUG9seWZpbGwiLCJwYXRocyIsImNoaWxkcmVuIiwibWVyZ2UiLCJ1dGlscyIsIkxvZ2dlckNvbnNvbGUiLCJUYXNrSW50ZXJ2YWwiLCJTZXJ2aWNlIiwiUGFyZW50IiwicGluZ1RpbWVvdXQiLCJjbGllbnRUaW1lb3V0Iiwic2VjcmV0S2V5IiwibG9nZ2VyIiwibGV2ZWwiLCJ3b3JrZXJDaGFuZ2VJbnRlcnZhbCIsIkxvZ2dlclRyYW5zcG9ydCIsIlRhc2tUcmFuc3BvcnQiLCJwcmVwYXJlT3B0aW9ucyIsInByZXBhcmVTZXJ2aWNlcyIsImluaXRTZXJ2aWNlcyIsImFkZHJlc3NlcyIsImdldEF2YWlsYWJsZUFkZHJlc3MiLCJhdmFpbGFibGVBZGRyZXNzIiwid29ya2VyQWRkcmVzcyIsImNoYW5nZVdvcmtlciIsImRlaW5pdFNlcnZpY2VzIiwiZGVpbml0IiwiZ2V0UmVxdWVzdFByb3RvY29sIiwiY3JlYXRlRGVmYXVsdFJlcXVlc3RPcHRpb25zIiwibGFzdEFkZHJlc3MiLCJ1c2VJbml0aWFsQWRkcmVzcyIsImVuZHBvaW50IiwiZm9ybURhdGEiLCJmb3JtIiwiYXBwZW5kIiwiY3JlYXRlUmVxdWVzdFVybCIsImpzb24iLCJXb3JrRXJyb3IiLCJpc1JlcXVlc3RUaW1lb3V0RXJyb3IiLCJjcmVhdGVSZXF1ZXN0VGltZW91dEVycm9yIiwicmVxdWVzdE9wdGlvbnMiLCJxdWVyeSIsImdldE1zIiwiY2EiLCJhZ2VudCIsImdldFJlcXVlc3RUaW1lciIsImlzQnJvd3NlciIsImlzQnJvd3NlckVudiIsIkFjY2Vzc0Vycm9yIiwiTm90Rm91bmRFcnJvciIsIkxvZ2dlciIsImNoYWxrIiwiaXNMZXZlbEFjdGl2ZSIsImxldmVscyIsImRlZmF1bHRMZXZlbCIsInNldExldmVsIiwiX19pbml0aWFsaXplZCIsIl9fZGVzdHJveWluZyIsIlRhc2siLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiaW50ZXJ2YWxPYmplY3QiLCJjbGVhckludGVydmFsIiwic2hvd0NvbXBsZXRpb25Mb2dzIiwic2hvd0ZhaWxMb2dzIiwidGFza3MiLCJpc1N0b3BwZWQiLCJzdGFydEFsbCIsInN0b3BBbGwiLCJpc1J1biIsInZhbGlkYXRlSVAiLCJ0Y3BQb3J0VXNlZCIsImlwNmFkZHIiLCJob3N0VmFsaWRhdGlvblJlZ2V4IiwidmFsaWRhdGVTY2hlbWEiLCJnZXRIdW1hbkRhdGEiLCJnZXRIdW1hblNjaGVtYSIsInNjaGVtYVR5cGUiLCJkYXRhVHlwZSIsIml0ZW0iLCJjYW5CZU51bGwiLCJzY2hlbWFLZXlzIiwiZGF0YUtleXMiLCJyZXF1aXJlZEtleXMiLCJnZXRSYW5kb21FbGVtZW50IiwiZ2V0Qnl0ZXMiLCJnZXRDcHVVc2FnZSIsInN0YXJ0VXNhZ2UiLCJjcHVVc2FnZSIsInN0YXJ0VGltZSIsImhydGltZSIsImVsYXBUaW1lIiwiZWxhcFRpbWVVcyIsImNwdVBlcmNlbnQiLCJ1c2VyIiwic3lzdGVtIiwiaXNQb3J0VXNlZCIsImdldEhvc3RJcCIsImlzVmFsaWRJcCIsImlwIiwiZ2V0QWRkcmVzc0lwIiwic3BsaXRBZGRyZXNzIiwiZml4QXJyIiwiZGV2IiwiZ2V0UmVtb3RlSXAiLCJjb25uZWN0aW9uIiwicmVtb3RlQWRkcmVzcyIsImlzSXB2NiIsImdldEZ1bGxJcHY2IiwiaXB2NFRvdjYiLCJpc0lwRXF1YWwiLCJjcmVhdGVBZGRyZXNzIiwiaXNWYWxpZFBvcnQiLCJpc1ZhbGlkSG9zdG5hbWUiLCJpc1ZhbGlkQWRkcmVzcyIsInNwIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO1FDVkE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtR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RUFBTTd6RCxLQUFOLENBQVksQ0FBWixDQUFqQixDQUFELEVBQW1DLENBQUM2ekQsR0FBRyxDQUFILENBQXBDLENBQVA7QUFDRDs7QUFFREEsT0FBS3gxQixRQUFRMWYsS0FBUixDQUFjLEdBQWQsQ0FBTDtBQUNBLFNBQU8sQ0FBQ2sxQyxHQUFHLENBQUgsQ0FBRCxFQUFRLENBQUNBLEdBQUcsQ0FBSCxDQUFULENBQVA7QUFDRCxDQWREOztBQWdCQTs7Ozs7QUFLQS9HLE1BQU1tQyx5QkFBTixHQUFrQyxZQUFZO0FBQzVDLE1BQU10cEQsTUFBTSxJQUFJRixLQUFKLENBQVUsbUJBQVYsQ0FBWjtBQUNBRSxNQUFJbUksSUFBSixHQUFXLGlDQUFYO0FBQ0EsU0FBT25JLEdBQVA7QUFDRCxDQUpEOztBQU1BOzs7Ozs7QUFNQW1uRCxNQUFNa0MscUJBQU4sR0FBOEIsVUFBVXJwRCxHQUFWLEVBQWU7QUFDM0MsU0FBUSxDQUFDLGlCQUFELEVBQW9CLFdBQXBCLEVBQWlDSSxPQUFqQyxDQUF5Q0osSUFBSW1JLElBQTdDLEtBQXNELENBQUMsQ0FBeEQsSUFBOERuSSxJQUFJdEMsSUFBSixJQUFZLGlCQUFqRjtBQUNELENBRkQ7O0FBSUFHLE9BQU9DLE9BQVAsR0FBaUJxcEQsS0FBakIsQzs7Ozs7Ozs7Ozs7O0FDeGNBLGU7Ozs7Ozs7Ozs7O0FDQUEsZSIsImZpbGUiOiJzcHJlYWRhYmxlLmNsaWVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkNsaWVudFNwcmVhZGFibGVcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiQ2xpZW50U3ByZWFkYWJsZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvYnJvd3Nlci9jbGllbnQvaW5kZXguanNcIik7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTIsIE1hcmsgQ2F2YWdlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW07XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuXG4vLy8tLS0gR2xvYmFsc1xuXG4vKiBKU1NUWUxFRCAqL1xudmFyIFVVSURfUkVHRVhQID0gL15bYS1mQS1GMC05XXs4fS1bYS1mQS1GMC05XXs0fS1bYS1mQS1GMC05XXs0fS1bYS1mQS1GMC05XXs0fS1bYS1mQS1GMC05XXsxMn0kLztcblxuXG4vLy8tLS0gSW50ZXJuYWxcblxuZnVuY3Rpb24gX2NhcGl0YWxpemUoc3RyKSB7XG4gICAgcmV0dXJuIChzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSkpO1xufVxuXG5mdW5jdGlvbiBfdG9zcyhuYW1lLCBleHBlY3RlZCwgb3BlciwgYXJnLCBhY3R1YWwpIHtcbiAgICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogdXRpbC5mb3JtYXQoJyVzICglcykgaXMgcmVxdWlyZWQnLCBuYW1lLCBleHBlY3RlZCksXG4gICAgICAgIGFjdHVhbDogKGFjdHVhbCA9PT0gdW5kZWZpbmVkKSA/IHR5cGVvZiAoYXJnKSA6IGFjdHVhbChhcmcpLFxuICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgIG9wZXJhdG9yOiBvcGVyIHx8ICc9PT0nLFxuICAgICAgICBzdGFja1N0YXJ0RnVuY3Rpb246IF90b3NzLmNhbGxlclxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBfZ2V0Q2xhc3MoYXJnKSB7XG4gICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKS5zbGljZSg4LCAtMSkpO1xufVxuXG5mdW5jdGlvbiBub29wKCkge1xuICAgIC8vIFdoeSBldmVuIGJvdGhlciB3aXRoIGFzc2VydHM/XG59XG5cblxuLy8vLS0tIEV4cG9ydHNcblxudmFyIHR5cGVzID0ge1xuICAgIGJvb2w6IHtcbiAgICAgICAgY2hlY2s6IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHR5cGVvZiAoYXJnKSA9PT0gJ2Jvb2xlYW4nOyB9XG4gICAgfSxcbiAgICBmdW5jOiB7XG4gICAgICAgIGNoZWNrOiBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0eXBlb2YgKGFyZykgPT09ICdmdW5jdGlvbic7IH1cbiAgICB9LFxuICAgIHN0cmluZzoge1xuICAgICAgICBjaGVjazogZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gdHlwZW9mIChhcmcpID09PSAnc3RyaW5nJzsgfVxuICAgIH0sXG4gICAgb2JqZWN0OiB7XG4gICAgICAgIGNoZWNrOiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIChhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG51bWJlcjoge1xuICAgICAgICBjaGVjazogZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiAoYXJnKSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGFyZyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZpbml0ZToge1xuICAgICAgICBjaGVjazogZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiAoYXJnKSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGFyZykgJiYgaXNGaW5pdGUoYXJnKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYnVmZmVyOiB7XG4gICAgICAgIGNoZWNrOiBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYXJnKTsgfSxcbiAgICAgICAgb3BlcmF0b3I6ICdCdWZmZXIuaXNCdWZmZXInXG4gICAgfSxcbiAgICBhcnJheToge1xuICAgICAgICBjaGVjazogZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpOyB9LFxuICAgICAgICBvcGVyYXRvcjogJ0FycmF5LmlzQXJyYXknXG4gICAgfSxcbiAgICBzdHJlYW06IHtcbiAgICAgICAgY2hlY2s6IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIFN0cmVhbTsgfSxcbiAgICAgICAgb3BlcmF0b3I6ICdpbnN0YW5jZW9mJyxcbiAgICAgICAgYWN0dWFsOiBfZ2V0Q2xhc3NcbiAgICB9LFxuICAgIGRhdGU6IHtcbiAgICAgICAgY2hlY2s6IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIERhdGU7IH0sXG4gICAgICAgIG9wZXJhdG9yOiAnaW5zdGFuY2VvZicsXG4gICAgICAgIGFjdHVhbDogX2dldENsYXNzXG4gICAgfSxcbiAgICByZWdleHA6IHtcbiAgICAgICAgY2hlY2s6IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIFJlZ0V4cDsgfSxcbiAgICAgICAgb3BlcmF0b3I6ICdpbnN0YW5jZW9mJyxcbiAgICAgICAgYWN0dWFsOiBfZ2V0Q2xhc3NcbiAgICB9LFxuICAgIHV1aWQ6IHtcbiAgICAgICAgY2hlY2s6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgKGFyZykgPT09ICdzdHJpbmcnICYmIFVVSURfUkVHRVhQLnRlc3QoYXJnKTtcbiAgICAgICAgfSxcbiAgICAgICAgb3BlcmF0b3I6ICdpc1VVSUQnXG4gICAgfVxufTtcblxuZnVuY3Rpb24gX3NldEV4cG9ydHMobmRlYnVnKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0eXBlcyk7XG4gICAgdmFyIG91dDtcblxuICAgIC8qIHJlLWV4cG9ydCBzdGFuZGFyZCBhc3NlcnQgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9OREVCVUcpIHtcbiAgICAgICAgb3V0ID0gbm9vcDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgPSBmdW5jdGlvbiAoYXJnLCBtc2cpIHtcbiAgICAgICAgICAgIGlmICghYXJnKSB7XG4gICAgICAgICAgICAgICAgX3Rvc3MobXNnLCAndHJ1ZScsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyogc3RhbmRhcmQgY2hlY2tzICovXG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmIChuZGVidWcpIHtcbiAgICAgICAgICAgIG91dFtrXSA9IG5vb3A7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1trXTtcbiAgICAgICAgb3V0W2tdID0gZnVuY3Rpb24gKGFyZywgbXNnKSB7XG4gICAgICAgICAgICBpZiAoIXR5cGUuY2hlY2soYXJnKSkge1xuICAgICAgICAgICAgICAgIF90b3NzKG1zZywgaywgdHlwZS5vcGVyYXRvciwgYXJnLCB0eXBlLmFjdHVhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKiBvcHRpb25hbCBjaGVja3MgKi9cbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgdmFyIG5hbWUgPSAnb3B0aW9uYWwnICsgX2NhcGl0YWxpemUoayk7XG4gICAgICAgIGlmIChuZGVidWcpIHtcbiAgICAgICAgICAgIG91dFtuYW1lXSA9IG5vb3A7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1trXTtcbiAgICAgICAgb3V0W25hbWVdID0gZnVuY3Rpb24gKGFyZywgbXNnKSB7XG4gICAgICAgICAgICBpZiAoYXJnID09PSB1bmRlZmluZWQgfHwgYXJnID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0eXBlLmNoZWNrKGFyZykpIHtcbiAgICAgICAgICAgICAgICBfdG9zcyhtc2csIGssIHR5cGUub3BlcmF0b3IsIGFyZywgdHlwZS5hY3R1YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyogYXJyYXlPZiBjaGVja3MgKi9cbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgdmFyIG5hbWUgPSAnYXJyYXlPZicgKyBfY2FwaXRhbGl6ZShrKTtcbiAgICAgICAgaWYgKG5kZWJ1Zykge1xuICAgICAgICAgICAgb3V0W25hbWVdID0gbm9vcDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2tdO1xuICAgICAgICB2YXIgZXhwZWN0ZWQgPSAnWycgKyBrICsgJ10nO1xuICAgICAgICBvdXRbbmFtZV0gPSBmdW5jdGlvbiAoYXJnLCBtc2cpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICAgICAgX3Rvc3MobXNnLCBleHBlY3RlZCwgdHlwZS5vcGVyYXRvciwgYXJnLCB0eXBlLmFjdHVhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuY2hlY2soYXJnW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBfdG9zcyhtc2csIGV4cGVjdGVkLCB0eXBlLm9wZXJhdG9yLCBhcmcsIHR5cGUuYWN0dWFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKiBvcHRpb25hbEFycmF5T2YgY2hlY2tzICovXG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHZhciBuYW1lID0gJ29wdGlvbmFsQXJyYXlPZicgKyBfY2FwaXRhbGl6ZShrKTtcbiAgICAgICAgaWYgKG5kZWJ1Zykge1xuICAgICAgICAgICAgb3V0W25hbWVdID0gbm9vcDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2tdO1xuICAgICAgICB2YXIgZXhwZWN0ZWQgPSAnWycgKyBrICsgJ10nO1xuICAgICAgICBvdXRbbmFtZV0gPSBmdW5jdGlvbiAoYXJnLCBtc2cpIHtcbiAgICAgICAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCB8fCBhcmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgICAgIF90b3NzKG1zZywgZXhwZWN0ZWQsIHR5cGUub3BlcmF0b3IsIGFyZywgdHlwZS5hY3R1YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlLmNoZWNrKGFyZ1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3Rvc3MobXNnLCBleHBlY3RlZCwgdHlwZS5vcGVyYXRvciwgYXJnLCB0eXBlLmFjdHVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyogcmUtZXhwb3J0IGJ1aWx0LWluIGFzc2VydGlvbnMgKi9cbiAgICBPYmplY3Qua2V5cyhhc3NlcnQpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgaWYgKGsgPT09ICdBc3NlcnRpb25FcnJvcicpIHtcbiAgICAgICAgICAgIG91dFtrXSA9IGFzc2VydFtrXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmRlYnVnKSB7XG4gICAgICAgICAgICBvdXRba10gPSBub29wO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG91dFtrXSA9IGFzc2VydFtrXTtcbiAgICB9KTtcblxuICAgIC8qIGV4cG9ydCBvdXJzZWx2ZXMgKGZvciB1bml0IHRlc3RzIF9vbmx5XykgKi9cbiAgICBvdXQuX3NldEV4cG9ydHMgPSBfc2V0RXhwb3J0cztcblxuICAgIHJldHVybiBvdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldEV4cG9ydHMocHJvY2Vzcy5lbnYuTk9ERV9OREVCVUcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBjb21wYXJlIGFuZCBpc0J1ZmZlciB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvNjgwZTllNWU0ODhmMjJhYWMyNzU5OWE1N2RjODQ0YTYzMTU5MjhkZC9pbmRleC5qc1xuLy8gb3JpZ2luYWwgbm90aWNlOlxuXG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgaWYgKGdsb2JhbC5CdWZmZXIgJiYgdHlwZW9mIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihiKTtcbiAgfVxuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKTtcbn1cblxuLy8gYmFzZWQgb24gbm9kZSBhc3NlcnQsIG9yaWdpbmFsIG5vdGljZTpcbi8vIE5COiBUaGUgVVJMIHRvIHRoZSBDb21tb25KUyBzcGVjIGlzIGtlcHQganVzdCBmb3IgdHJhZGl0aW9uLlxuLy8gICAgIG5vZGUtYXNzZXJ0IGhhcyBldm9sdmVkIGEgbG90IHNpbmNlIHRoZW4sIGJvdGggaW4gQVBJIGFuZCBiZWhhdmlvci5cblxuLy8gaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvVW5pdF9UZXN0aW5nLzEuMFxuLy9cbi8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcbi8vXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbC8nKTtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBmdW5jdGlvbnNIYXZlTmFtZXMgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9vKCkge30ubmFtZSA9PT0gJ2Zvbyc7XG59KCkpO1xuZnVuY3Rpb24gcFRvU3RyaW5nIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xufVxuZnVuY3Rpb24gaXNWaWV3KGFycmJ1Zikge1xuICBpZiAoaXNCdWZmZXIoYXJyYnVmKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYnVmKTtcbiAgfVxuICBpZiAoIWFycmJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYXJyYnVmIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYXJyYnVmLmJ1ZmZlciAmJiBhcnJidWYuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG52YXIgcmVnZXggPSAvXFxzKmZ1bmN0aW9uXFxzKyhbXlxcKFxcc10qKVxccyovO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS9ibG9iL2FkZWVlZWM4YmZjYzYwNjhiMTg3ZDdkOWZiM2Q1YmIxZDNhMzA4OTkvaW1wbGVtZW50YXRpb24uanNcbmZ1bmN0aW9uIGdldE5hbWUoZnVuYykge1xuICBpZiAoIXV0aWwuaXNGdW5jdGlvbihmdW5jKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzKSB7XG4gICAgcmV0dXJuIGZ1bmMubmFtZTtcbiAgfVxuICB2YXIgc3RyID0gZnVuYy50b1N0cmluZygpO1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmVnZXgpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59XG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNZXNzYWdlKHRoaXMpO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gZ2V0TmFtZShzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBpbnNwZWN0KHNvbWV0aGluZykge1xuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzIHx8ICF1dGlsLmlzRnVuY3Rpb24oc29tZXRoaW5nKSkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3Qoc29tZXRoaW5nKTtcbiAgfVxuICB2YXIgcmF3bmFtZSA9IGdldE5hbWUoc29tZXRoaW5nKTtcbiAgdmFyIG5hbWUgPSByYXduYW1lID8gJzogJyArIHJhd25hbWUgOiAnJztcbiAgcmV0dXJuICdbRnVuY3Rpb24nICsgIG5hbWUgKyAnXSc7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlKHNlbGYpIHtcbiAgcmV0dXJuIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5hY3R1YWwpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmV4cGVjdGVkKSwgMTI4KTtcbn1cblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsICEhZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwU3RyaWN0RXF1YWwnLCBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgJiYgaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYWN0dWFsLCBleHBlY3RlZCkgPT09IDA7XG5cbiAgLy8gNy4yLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBEYXRlIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBEYXRlIG9iamVjdCB0aGF0IHJlZmVycyB0byB0aGUgc2FtZSB0aW1lLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNEYXRlKGFjdHVhbCkgJiYgdXRpbC5pc0RhdGUoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMgSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBSZWdFeHAgb2JqZWN0IHdpdGggdGhlIHNhbWUgc291cmNlIGFuZFxuICAvLyBwcm9wZXJ0aWVzIChgZ2xvYmFsYCwgYG11bHRpbGluZWAsIGBsYXN0SW5kZXhgLCBgaWdub3JlQ2FzZWApLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNSZWdFeHAoYWN0dWFsKSAmJiB1dGlsLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcbiAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmXG4gICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJlxuICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcbiAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7XG5cbiAgLy8gNy40LiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKChhY3R1YWwgPT09IG51bGwgfHwgdHlwZW9mIGFjdHVhbCAhPT0gJ29iamVjdCcpICYmXG4gICAgICAgICAgICAgKGV4cGVjdGVkID09PSBudWxsIHx8IHR5cGVvZiBleHBlY3RlZCAhPT0gJ29iamVjdCcpKSB7XG4gICAgcmV0dXJuIHN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gSWYgYm90aCB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiB0eXBlZCBhcnJheXMsIHdyYXAgdGhlaXIgdW5kZXJseWluZ1xuICAvLyBBcnJheUJ1ZmZlcnMgaW4gYSBCdWZmZXIgZWFjaCB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZVxuICAvLyBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGUgYXJyYXlzIHRvIGhhdmUgdGhlIHNhbWUgdHlwZSBhcyBjaGVja2VkIGJ5XG4gIC8vIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgKGFrYSBwVG9TdHJpbmcpLiBOZXZlciBwZXJmb3JtIGJpbmFyeVxuICAvLyBjb21wYXJpc29ucyBmb3IgRmxvYXQqQXJyYXlzLCB0aG91Z2gsIHNpbmNlIGUuZy4gKzAgPT09IC0wIGJ1dCB0aGVpclxuICAvLyBiaXQgcGF0dGVybnMgYXJlIG5vdCBpZGVudGljYWwuXG4gIH0gZWxzZSBpZiAoaXNWaWV3KGFjdHVhbCkgJiYgaXNWaWV3KGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgIHBUb1N0cmluZyhhY3R1YWwpID09PSBwVG9TdHJpbmcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgIShhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcbiAgICAgICAgICAgICAgIGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkpIHtcbiAgICByZXR1cm4gY29tcGFyZShuZXcgVWludDhBcnJheShhY3R1YWwuYnVmZmVyKSxcbiAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShleHBlY3RlZC5idWZmZXIpKSA9PT0gMDtcblxuICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgIT09IGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBtZW1vcyA9IG1lbW9zIHx8IHthY3R1YWw6IFtdLCBleHBlY3RlZDogW119O1xuXG4gICAgdmFyIGFjdHVhbEluZGV4ID0gbWVtb3MuYWN0dWFsLmluZGV4T2YoYWN0dWFsKTtcbiAgICBpZiAoYWN0dWFsSW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoYWN0dWFsSW5kZXggPT09IG1lbW9zLmV4cGVjdGVkLmluZGV4T2YoZXhwZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9zLmFjdHVhbC5wdXNoKGFjdHVhbCk7XG4gICAgbWVtb3MuZXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG5cbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykge1xuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBpZiBvbmUgaXMgYSBwcmltaXRpdmUsIHRoZSBvdGhlciBtdXN0IGJlIHNhbWVcbiAgaWYgKHV0aWwuaXNQcmltaXRpdmUoYSkgfHwgdXRpbC5pc1ByaW1pdGl2ZShiKSlcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgaWYgKHN0cmljdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYSkgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHZhciBhSXNBcmdzID0gaXNBcmd1bWVudHMoYSk7XG4gIHZhciBiSXNBcmdzID0gaXNBcmd1bWVudHMoYik7XG4gIGlmICgoYUlzQXJncyAmJiAhYklzQXJncykgfHwgKCFhSXNBcmdzICYmIGJJc0FyZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGFJc0FyZ3MpIHtcbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIsIHN0cmljdCk7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKTtcbiAgdmFyIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgdmFyIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT09IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFfZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwU3RyaWN0RXF1YWwnLCBub3REZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59XG5cblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBhc3NlcnQuc3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG4vLyAxMC4gVGhlIHN0cmljdCBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciBzdHJpY3QgaW5lcXVhbGl0eSwgYXNcbi8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIGFzc2VydC5ub3RTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElnbm9yZS4gIFRoZSBpbnN0YW5jZW9mIGNoZWNrIGRvZXNuJ3Qgd29yayBmb3IgYXJyb3cgZnVuY3Rpb25zLlxuICB9XG5cbiAgaWYgKEVycm9yLmlzUHJvdG90eXBlT2YoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIF90cnlCbG9jayhibG9jaykge1xuICB2YXIgZXJyb3I7XG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yID0gZTtcbiAgfVxuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh0eXBlb2YgYmxvY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJsb2NrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICBhY3R1YWwgPSBfdHJ5QmxvY2soYmxvY2spO1xuXG4gIG1lc3NhZ2UgPSAoZXhwZWN0ZWQgJiYgZXhwZWN0ZWQubmFtZSA/ICcgKCcgKyBleHBlY3RlZC5uYW1lICsgJykuJyA6ICcuJykgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgPyAnICcgKyBtZXNzYWdlIDogJy4nKTtcblxuICBpZiAoc2hvdWxkVGhyb3cgJiYgIWFjdHVhbCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgdmFyIHVzZXJQcm92aWRlZE1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZyc7XG4gIHZhciBpc1Vud2FudGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIHV0aWwuaXNFcnJvcihhY3R1YWwpO1xuICB2YXIgaXNVbmV4cGVjdGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIGFjdHVhbCAmJiAhZXhwZWN0ZWQ7XG5cbiAgaWYgKChpc1Vud2FudGVkRXhjZXB0aW9uICYmXG4gICAgICB1c2VyUHJvdmlkZWRNZXNzYWdlICYmXG4gICAgICBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHxcbiAgICAgIGlzVW5leHBlY3RlZEV4Y2VwdGlvbikge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoKHNob3VsZFRocm93ICYmIGFjdHVhbCAmJiBleHBlY3RlZCAmJlxuICAgICAgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fCAoIXNob3VsZFRocm93ICYmIGFjdHVhbCkpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuLy8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuLy8gYXNzZXJ0LnRocm93cyhibG9jaywgRXJyb3Jfb3B0LCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyh0cnVlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MoZmFsc2UsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB0aHJvdyBlcnI7IH07XG5cbi8vIEV4cG9zZSBhIHN0cmljdCBvbmx5IHZhcmlhbnQgb2YgYXNzZXJ0XG5mdW5jdGlvbiBzdHJpY3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09Jywgc3RyaWN0KTtcbn1cbmFzc2VydC5zdHJpY3QgPSBvYmplY3RBc3NpZ24oc3RyaWN0LCBhc3NlcnQsIHtcbiAgZXF1YWw6IGFzc2VydC5zdHJpY3RFcXVhbCxcbiAgZGVlcEVxdWFsOiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsLFxuICBub3RFcXVhbDogYXNzZXJ0Lm5vdFN0cmljdEVxdWFsLFxuICBub3REZWVwRXF1YWw6IGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWxcbn0pO1xuYXNzZXJ0LnN0cmljdC5zdHJpY3QgPSBhc3NlcnQuc3RyaWN0O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9pcy1maW5pdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vbnVtYmVyL2lzLW5hblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9udW1iZXIvbWF4LXNhZmUtaW50ZWdlclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9udW1iZXIvbWluLXNhZmUtaW50ZWdlclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0aWVzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yc1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1uYW1lc1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9pcy1leHRlbnNpYmxlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9rZXlzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9wcmV2ZW50LWV4dGVuc2lvbnNcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zZXQtaW1tZWRpYXRlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaGFzLWluc3RhbmNlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvc3BlY2llc1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3Byb21pc2UgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9wcm9taXNlXCIpO1xuXG52YXIgX3Byb21pc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvbWlzZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBuZXcgX3Byb21pc2UyLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gc3RlcChrZXksIGFyZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfcHJvbWlzZTIuZGVmYXVsdC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgc3RlcChcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHN0ZXAoXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGVwKFwibmV4dFwiKTtcbiAgICB9KTtcbiAgfTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIik7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2dldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIik7XG5cbnZhciBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldE93blByb3BlcnR5RGVzY3JpcHRvcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gIHZhciBkZXNjID0gKDAsIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IyLmRlZmF1bHQpKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcGFyZW50ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkob2JqZWN0KTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykge1xuICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcblxuICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3NldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIik7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9jcmVhdGVcIik7XG5cbnZhciBfY3JlYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZSk7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyAodHlwZW9mIHN1cGVyQ2xhc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKHN1cGVyQ2xhc3MpKSk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCA/ICgwLCBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAoKHR5cGVvZiBjYWxsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShjYWxsKSkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZnJvbSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL2FycmF5L2Zyb21cIik7XG5cbnZhciBfZnJvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mcm9tKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9mcm9tMi5kZWZhdWx0KShhcnIpO1xuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2l0ZXJhdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yXCIpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2xcIik7XG5cbnZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBcIjEwMFwiOiBcIkNvbnRpbnVlXCIsXG4gIFwiMTAxXCI6IFwiU3dpdGNoaW5nIFByb3RvY29sc1wiLFxuICBcIjEwMlwiOiBcIlByb2Nlc3NpbmdcIixcbiAgXCIyMDBcIjogXCJPS1wiLFxuICBcIjIwMVwiOiBcIkNyZWF0ZWRcIixcbiAgXCIyMDJcIjogXCJBY2NlcHRlZFwiLFxuICBcIjIwM1wiOiBcIk5vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uXCIsXG4gIFwiMjA0XCI6IFwiTm8gQ29udGVudFwiLFxuICBcIjIwNVwiOiBcIlJlc2V0IENvbnRlbnRcIixcbiAgXCIyMDZcIjogXCJQYXJ0aWFsIENvbnRlbnRcIixcbiAgXCIyMDdcIjogXCJNdWx0aS1TdGF0dXNcIixcbiAgXCIyMDhcIjogXCJBbHJlYWR5IFJlcG9ydGVkXCIsXG4gIFwiMjI2XCI6IFwiSU0gVXNlZFwiLFxuICBcIjMwMFwiOiBcIk11bHRpcGxlIENob2ljZXNcIixcbiAgXCIzMDFcIjogXCJNb3ZlZCBQZXJtYW5lbnRseVwiLFxuICBcIjMwMlwiOiBcIkZvdW5kXCIsXG4gIFwiMzAzXCI6IFwiU2VlIE90aGVyXCIsXG4gIFwiMzA0XCI6IFwiTm90IE1vZGlmaWVkXCIsXG4gIFwiMzA1XCI6IFwiVXNlIFByb3h5XCIsXG4gIFwiMzA3XCI6IFwiVGVtcG9yYXJ5IFJlZGlyZWN0XCIsXG4gIFwiMzA4XCI6IFwiUGVybWFuZW50IFJlZGlyZWN0XCIsXG4gIFwiNDAwXCI6IFwiQmFkIFJlcXVlc3RcIixcbiAgXCI0MDFcIjogXCJVbmF1dGhvcml6ZWRcIixcbiAgXCI0MDJcIjogXCJQYXltZW50IFJlcXVpcmVkXCIsXG4gIFwiNDAzXCI6IFwiRm9yYmlkZGVuXCIsXG4gIFwiNDA0XCI6IFwiTm90IEZvdW5kXCIsXG4gIFwiNDA1XCI6IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsXG4gIFwiNDA2XCI6IFwiTm90IEFjY2VwdGFibGVcIixcbiAgXCI0MDdcIjogXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQwOFwiOiBcIlJlcXVlc3QgVGltZW91dFwiLFxuICBcIjQwOVwiOiBcIkNvbmZsaWN0XCIsXG4gIFwiNDEwXCI6IFwiR29uZVwiLFxuICBcIjQxMVwiOiBcIkxlbmd0aCBSZXF1aXJlZFwiLFxuICBcIjQxMlwiOiBcIlByZWNvbmRpdGlvbiBGYWlsZWRcIixcbiAgXCI0MTNcIjogXCJQYXlsb2FkIFRvbyBMYXJnZVwiLFxuICBcIjQxNFwiOiBcIlVSSSBUb28gTG9uZ1wiLFxuICBcIjQxNVwiOiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgXCI0MTZcIjogXCJSYW5nZSBOb3QgU2F0aXNmaWFibGVcIixcbiAgXCI0MTdcIjogXCJFeHBlY3RhdGlvbiBGYWlsZWRcIixcbiAgXCI0MThcIjogXCJJJ20gYSB0ZWFwb3RcIixcbiAgXCI0MjFcIjogXCJNaXNkaXJlY3RlZCBSZXF1ZXN0XCIsXG4gIFwiNDIyXCI6IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIixcbiAgXCI0MjNcIjogXCJMb2NrZWRcIixcbiAgXCI0MjRcIjogXCJGYWlsZWQgRGVwZW5kZW5jeVwiLFxuICBcIjQyNVwiOiBcIlVub3JkZXJlZCBDb2xsZWN0aW9uXCIsXG4gIFwiNDI2XCI6IFwiVXBncmFkZSBSZXF1aXJlZFwiLFxuICBcIjQyOFwiOiBcIlByZWNvbmRpdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQyOVwiOiBcIlRvbyBNYW55IFJlcXVlc3RzXCIsXG4gIFwiNDMxXCI6IFwiUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZVwiLFxuICBcIjQ1MVwiOiBcIlVuYXZhaWxhYmxlIEZvciBMZWdhbCBSZWFzb25zXCIsXG4gIFwiNTAwXCI6IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIsXG4gIFwiNTAxXCI6IFwiTm90IEltcGxlbWVudGVkXCIsXG4gIFwiNTAyXCI6IFwiQmFkIEdhdGV3YXlcIixcbiAgXCI1MDNcIjogXCJTZXJ2aWNlIFVuYXZhaWxhYmxlXCIsXG4gIFwiNTA0XCI6IFwiR2F0ZXdheSBUaW1lb3V0XCIsXG4gIFwiNTA1XCI6IFwiSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWRcIixcbiAgXCI1MDZcIjogXCJWYXJpYW50IEFsc28gTmVnb3RpYXRlc1wiLFxuICBcIjUwN1wiOiBcIkluc3VmZmljaWVudCBTdG9yYWdlXCIsXG4gIFwiNTA4XCI6IFwiTG9vcCBEZXRlY3RlZFwiLFxuICBcIjUwOVwiOiBcIkJhbmR3aWR0aCBMaW1pdCBFeGNlZWRlZFwiLFxuICBcIjUxMFwiOiBcIk5vdCBFeHRlbmRlZFwiLFxuICBcIjUxMVwiOiBcIk5ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIlxufVxuIiwiLyohXG4gKiBieXRlc1xuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0KGMpIDIwMTUgSmVkIFdhdHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXM7XG5tb2R1bGUuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXQ7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBmb3JtYXRUaG91c2FuZHNSZWdFeHAgPSAvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZztcblxudmFyIGZvcm1hdERlY2ltYWxzUmVnRXhwID0gLyg/OlxcLjAqfChcXC5bXjBdKykwKykkLztcblxudmFyIG1hcCA9IHtcbiAgYjogIDEsXG4gIGtiOiAxIDw8IDEwLFxuICBtYjogMSA8PCAyMCxcbiAgZ2I6IDEgPDwgMzAsXG4gIHRiOiBNYXRoLnBvdygxMDI0LCA0KSxcbiAgcGI6IE1hdGgucG93KDEwMjQsIDUpLFxufTtcblxudmFyIHBhcnNlUmVnRXhwID0gL14oKC18XFwrKT8oXFxkKyg/OlxcLlxcZCspPykpICooa2J8bWJ8Z2J8dGJ8cGIpJC9pO1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIHZhbHVlIGluIGJ5dGVzIGludG8gYSBzdHJpbmcgb3IgcGFyc2UgdG8gc3RyaW5nIHRvIGFuIGludGVnZXIgaW4gYnl0ZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHt7XG4gKiAgY2FzZTogW3N0cmluZ10sXG4gKiAgZGVjaW1hbFBsYWNlczogW251bWJlcl1cbiAqICBmaXhlZERlY2ltYWxzOiBbYm9vbGVhbl1cbiAqICB0aG91c2FuZHNTZXBhcmF0b3I6IFtzdHJpbmddXG4gKiAgdW5pdFNlcGFyYXRvcjogW3N0cmluZ11cbiAqICB9fSBbb3B0aW9uc10gYnl0ZXMgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bWJlcnxudWxsfVxuICovXG5cbmZ1bmN0aW9uIGJ5dGVzKHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBGb3JtYXQgdGhlIGdpdmVuIHZhbHVlIGluIGJ5dGVzIGludG8gYSBzdHJpbmcuXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlLCBpdCBpcyBrZXB0IGFzIHN1Y2guIElmIGl0IGlzIGEgZmxvYXQsXG4gKiBpdCBpcyByb3VuZGVkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRlY2ltYWxQbGFjZXM9Ml1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5maXhlZERlY2ltYWxzPWZhbHNlXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRob3VzYW5kc1NlcGFyYXRvcj1dXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudW5pdD1dXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudW5pdFNlcGFyYXRvcj1dXG4gKlxuICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYWcgPSBNYXRoLmFicyh2YWx1ZSk7XG4gIHZhciB0aG91c2FuZHNTZXBhcmF0b3IgPSAob3B0aW9ucyAmJiBvcHRpb25zLnRob3VzYW5kc1NlcGFyYXRvcikgfHwgJyc7XG4gIHZhciB1bml0U2VwYXJhdG9yID0gKG9wdGlvbnMgJiYgb3B0aW9ucy51bml0U2VwYXJhdG9yKSB8fCAnJztcbiAgdmFyIGRlY2ltYWxQbGFjZXMgPSAob3B0aW9ucyAmJiBvcHRpb25zLmRlY2ltYWxQbGFjZXMgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmRlY2ltYWxQbGFjZXMgOiAyO1xuICB2YXIgZml4ZWREZWNpbWFscyA9IEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLmZpeGVkRGVjaW1hbHMpO1xuICB2YXIgdW5pdCA9IChvcHRpb25zICYmIG9wdGlvbnMudW5pdCkgfHwgJyc7XG5cbiAgaWYgKCF1bml0IHx8ICFtYXBbdW5pdC50b0xvd2VyQ2FzZSgpXSkge1xuICAgIGlmIChtYWcgPj0gbWFwLnBiKSB7XG4gICAgICB1bml0ID0gJ1BCJztcbiAgICB9IGVsc2UgaWYgKG1hZyA+PSBtYXAudGIpIHtcbiAgICAgIHVuaXQgPSAnVEInO1xuICAgIH0gZWxzZSBpZiAobWFnID49IG1hcC5nYikge1xuICAgICAgdW5pdCA9ICdHQic7XG4gICAgfSBlbHNlIGlmIChtYWcgPj0gbWFwLm1iKSB7XG4gICAgICB1bml0ID0gJ01CJztcbiAgICB9IGVsc2UgaWYgKG1hZyA+PSBtYXAua2IpIHtcbiAgICAgIHVuaXQgPSAnS0InO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0ID0gJ0InO1xuICAgIH1cbiAgfVxuXG4gIHZhciB2YWwgPSB2YWx1ZSAvIG1hcFt1bml0LnRvTG93ZXJDYXNlKCldO1xuICB2YXIgc3RyID0gdmFsLnRvRml4ZWQoZGVjaW1hbFBsYWNlcyk7XG5cbiAgaWYgKCFmaXhlZERlY2ltYWxzKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoZm9ybWF0RGVjaW1hbHNSZWdFeHAsICckMScpO1xuICB9XG5cbiAgaWYgKHRob3VzYW5kc1NlcGFyYXRvcikge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKGZvcm1hdFRob3VzYW5kc1JlZ0V4cCwgdGhvdXNhbmRzU2VwYXJhdG9yKTtcbiAgfVxuXG4gIHJldHVybiBzdHIgKyB1bml0U2VwYXJhdG9yICsgdW5pdDtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgc3RyaW5nIHZhbHVlIGludG8gYW4gaW50ZWdlciBpbiBieXRlcy5cbiAqXG4gKiBJZiBubyB1bml0IGlzIGdpdmVuLCBpdCBpcyBhc3N1bWVkIHRoZSB2YWx1ZSBpcyBpbiBieXRlcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbFxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ8bnVsbH1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZSh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gVGVzdCBpZiB0aGUgc3RyaW5nIHBhc3NlZCBpcyB2YWxpZFxuICB2YXIgcmVzdWx0cyA9IHBhcnNlUmVnRXhwLmV4ZWModmFsKTtcbiAgdmFyIGZsb2F0VmFsdWU7XG4gIHZhciB1bml0ID0gJ2InO1xuXG4gIGlmICghcmVzdWx0cykge1xuICAgIC8vIE5vdGhpbmcgY291bGQgYmUgZXh0cmFjdGVkIGZyb20gdGhlIGdpdmVuIHN0cmluZ1xuICAgIGZsb2F0VmFsdWUgPSBwYXJzZUludCh2YWwsIDEwKTtcbiAgICB1bml0ID0gJ2InXG4gIH0gZWxzZSB7XG4gICAgLy8gUmV0cmlldmUgdGhlIHZhbHVlIGFuZCB0aGUgdW5pdFxuICAgIGZsb2F0VmFsdWUgPSBwYXJzZUZsb2F0KHJlc3VsdHNbMV0pO1xuICAgIHVuaXQgPSByZXN1bHRzWzRdLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5mbG9vcihtYXBbdW5pdF0gKiBmbG9hdFZhbHVlKTtcbn1cbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkuZnJvbTtcbiIsInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpO1xudmFyICRKU09OID0gY29yZS5KU09OIHx8IChjb3JlLkpTT04gPSB7IHN0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnkgfSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJldHVybiAkSlNPTi5zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3VtZW50cyk7XG59O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuTnVtYmVyLmlzRmluaXRlO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuTnVtYmVyLmlzTmFOO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXInKTtcbm1vZHVsZS5leHBvcnRzID0gMHgxZmZmZmZmZmZmZmZmZjtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyJyk7XG5tb2R1bGUuZXhwb3J0cyA9IC0weDFmZmZmZmZmZmZmZmZmO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpIHtcbiAgcmV0dXJuICRPYmplY3QuY3JlYXRlKFAsIEQpO1xufTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcycpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKFQsIEQpIHtcbiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhULCBEKTtcbn07XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpIHtcbiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7XG59O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICByZXR1cm4gJE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG59O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gJE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcbn07XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5pc0V4dGVuc2libGU7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmtleXM7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QucHJldmVudEV4dGVuc2lvbnM7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcucHJvbWlzZS50cnknKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlByb21pc2U7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5pbW1lZGlhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLnNldEltbWVkaWF0ZTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaGFzSW5zdGFuY2UnKTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuU3ltYm9sO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fd2tzLWV4dCcpLmYoJ2l0ZXJhdG9yJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdzcGVjaWVzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi42LjMnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgSVNfV1JBUCA9IHR5cGUgJiAkZXhwb3J0Llc7XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXTtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBrZXksIG93biwgb3V0O1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChvd24gJiYgaGFzKGV4cG9ydHMsIGtleSkpIGNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24gKEMpIHtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDKSB7XG4gICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQygpO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZiAoSVNfUFJPVE8pIHtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZiAodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSkgaGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBhcmdzLCB0aGF0KSB7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG4iLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuIiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmIChpc05vZGUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgU2FmYXJpIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuICB9IGVsc2UgaWYgKE9ic2VydmVyICYmICEoZ2xvYmFsLm5hdmlnYXRvciAmJiBnbG9iYWwubmF2aWdhdG9yLnN0YW5kYWxvbmUpKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgICBpZiAobGFzdCkgbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZiAoIWhlYWQpIHtcbiAgICAgIGhlYWQgPSB0YXNrO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfSBsYXN0ID0gdGFzaztcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyNS40LjEuNSBOZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcblxuZnVuY3Rpb24gUHJvbWlzZUNhcGFiaWxpdHkoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFGdW5jdGlvbihyZWplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIFMgPSBTeW1ib2woKTtcbiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xuICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIGlmIChpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKSBUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcbiIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZFBzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG4iLCIvLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBSZWZsZWN0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdDtcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdCAmJiBSZWZsZWN0Lm93bktleXMgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdPUE4uZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlOiBmYWxzZSwgdjogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBlOiB0cnVlLCB2OiBlIH07XG4gIH1cbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiIsInZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIHNhZmUpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGlmIChzYWZlICYmIHRhcmdldFtrZXldKSB0YXJnZXRba2V5XSA9IHNyY1trZXldO1xuICAgIGVsc2UgaGlkZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9IHJldHVybiB0YXJnZXQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19oaWRlJyk7XG4iLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBpZiAoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkgdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24gKHRlc3QsIGJ1Z2d5LCBzZXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoIChlKSB7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYgKGJ1Z2d5KSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gdHlwZW9mIGNvcmVbS0VZXSA9PSAnZnVuY3Rpb24nID8gY29yZVtLRVldIDogZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcbiIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246IGNvcmUudmVyc2lvbixcbiAgbW9kZTogcmVxdWlyZSgnLi9fbGlicmFyeScpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcbiIsIi8vIDcuMy4yMCBTcGVjaWVzQ29uc3RydWN0b3IoTywgZGVmYXVsdENvbnN0cnVjdG9yKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgRCkge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaW52b2tlID0gcmVxdWlyZSgnLi9faW52b2tlJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4vX2h0bWwnKTtcbnZhciBjZWwgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHNldFRhc2sgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyVGFzayA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spIHtcbiAgc2V0VGFzayA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gU3BoZXJlIChKUyBnYW1lIGVuZ2luZSkgRGlzcGF0Y2ggQVBJXG4gIH0gZWxzZSBpZiAoRGlzcGF0Y2ggJiYgRGlzcGF0Y2gubm93KSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIERpc3BhdGNoLm5vdyhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldFRhc2ssXG4gIGNsZWFyOiBjbGVhclRhc2tcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBuYXZpZ2F0b3IgPSBnbG9iYWwubmF2aWdhdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7XG59O1xuIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG4iLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSAvKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmIChtYXBwaW5nKSBtYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcihpdGVyRm4pKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQygpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IgKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSEFTX0lOU1RBTkNFID0gcmVxdWlyZSgnLi9fd2tzJykoJ2hhc0luc3RhbmNlJyk7XG52YXIgRnVuY3Rpb25Qcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIDE5LjIuMy42IEZ1bmN0aW9uLnByb3RvdHlwZVtAQGhhc0luc3RhbmNlXShWKVxuaWYgKCEoSEFTX0lOU1RBTkNFIGluIEZ1bmN0aW9uUHJvdG8pKSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKEZ1bmN0aW9uUHJvdG8sIEhBU19JTlNUQU5DRSwgeyB2YWx1ZTogZnVuY3Rpb24gKE8pIHtcbiAgaWYgKHR5cGVvZiB0aGlzICE9ICdmdW5jdGlvbicgfHwgIWlzT2JqZWN0KE8pKSByZXR1cm4gZmFsc2U7XG4gIGlmICghaXNPYmplY3QodGhpcy5wcm90b3R5cGUpKSByZXR1cm4gTyBpbnN0YW5jZW9mIHRoaXM7XG4gIC8vIGZvciBlbnZpcm9ubWVudCB3L28gbmF0aXZlIGBAQGhhc0luc3RhbmNlYCBsb2dpYyBlbm91Z2ggYGluc3RhbmNlb2ZgLCBidXQgYWRkIHRoaXM6XG4gIHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpIGlmICh0aGlzLnByb3RvdHlwZSA9PT0gTykgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn0gfSk7XG4iLCIvLyAyMC4xLjIuMiBOdW1iZXIuaXNGaW5pdGUobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBfaXNGaW5pdGUgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5pc0Zpbml0ZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzRmluaXRlOiBmdW5jdGlvbiBpc0Zpbml0ZShpdCkge1xuICAgIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgX2lzRmluaXRlKGl0KTtcbiAgfVxufSk7XG4iLCIvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjYgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBNQVhfU0FGRV9JTlRFR0VSOiAweDFmZmZmZmZmZmZmZmZmIH0pO1xuIiwiLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHsgTUlOX1NBRkVfSU5URUdFUjogLTB4MWZmZmZmZmZmZmZmZmYgfSk7XG4iLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7IGFzc2lnbjogcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGNyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4zIC8gMTUuMi4zLjcgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKSB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYgfSk7XG4iLCIvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0lPYmplY3QoaXQpLCBrZXkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JykuZjtcbn0pO1xuIiwiLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciAkZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCkge1xuICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4yLjExIE9iamVjdC5pc0V4dGVuc2libGUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRXh0ZW5zaWJsZScsIGZ1bmN0aW9uICgkaXNFeHRlbnNpYmxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpIHtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZSA6IGZhbHNlO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuMTUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3ByZXZlbnRFeHRlbnNpb25zJywgZnVuY3Rpb24gKCRwcmV2ZW50RXh0ZW5zaW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoaXQpIHtcbiAgICByZXR1cm4gJHByZXZlbnRFeHRlbnNpb25zICYmIGlzT2JqZWN0KGl0KSA/ICRwcmV2ZW50RXh0ZW5zaW9ucyhtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgc2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldCB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIHRhc2sgPSByZXF1aXJlKCcuL190YXNrJykuc2V0O1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKCk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG52YXIgcGVyZm9ybSA9IHJlcXVpcmUoJy4vX3BlcmZvcm0nKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuL191c2VyLWFnZW50Jyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjggfHwgJyc7XG52YXIgJFByb21pc2UgPSBnbG9iYWxbUFJPTUlTRV07XG52YXIgaXNOb2RlID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgZW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgSW50ZXJuYWwsIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlID0gJFByb21pc2UucmVzb2x2ZSgxKTtcbiAgICB2YXIgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgICBleGVjKGVtcHR5LCBlbXB0eSk7XG4gICAgfTtcbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKVxuICAgICAgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlXG4gICAgICAvLyB2OCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgICAgIC8vIHdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG4gICAgICAmJiB2OC5pbmRleE9mKCc2LjYnKSAhPT0gMFxuICAgICAgJiYgdXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZS82NicpID09PSAtMTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faCA9PSAyKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBtYXkgdGhyb3dcbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhcHJvbWlzZS5faCkgb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciB1bmhhbmRsZWQgPSBpc1VuaGFuZGxlZChwcm9taXNlKTtcbiAgICB2YXIgcmVzdWx0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmICh1bmhhbmRsZWQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbikge1xuICAgICAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHVuaGFuZGxlZCAmJiByZXN1bHQuZSkgdGhyb3cgcmVzdWx0LnY7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHJldHVybiBwcm9taXNlLl9oICE9PSAxICYmIChwcm9taXNlLl9hIHx8IHByb21pc2UuX2MpLmxlbmd0aCA9PT0gMDtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdiB9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgdGhlbjtcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoeyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgUHJvbWlzZTogJFByb21pc2UgfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShMSUJSQVJZICYmIHRoaXMgPT09IFdyYXBwZXIgPyAkUHJvbWlzZSA6IHRoaXMsIHgpO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgJGluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGluZGV4ID0gdGhpcy5faTtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgTUVUQSA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVk7XG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIHdrc0RlZmluZSA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QRCA9ICRHT1BELmY7XG52YXIgZFAgPSAkRFAuZjtcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyICRKU09OID0gZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4vX293bi1rZXlzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gICAgdmFyIGdldERlc2MgPSBnT1BELmY7XG4gICAgdmFyIGtleXMgPSBvd25LZXlzKE8pO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleSwgZGVzYztcbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpKSB7XG4gICAgICBkZXNjID0gZ2V0RGVzYyhPLCBrZXkgPSBrZXlzW2krK10pO1xuICAgICAgaWYgKGRlc2MgIT09IHVuZGVmaW5lZCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBrZXksIGRlc2MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtZmluYWxseVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4vX3Byb21pc2UtcmVzb2x2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1Byb21pc2UnLCB7ICdmaW5hbGx5JzogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpO1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBvbkZpbmFsbHkgPT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHRoaXMudGhlbihcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcbiAgICB9IDogb25GaW5hbGx5LFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgdGhyb3cgZTsgfSk7XG4gICAgfSA6IG9uRmluYWxseVxuICApO1xufSB9KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtdHJ5XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9fbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xudmFyIHBlcmZvcm0gPSByZXF1aXJlKCcuL19wZXJmb3JtJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUHJvbWlzZScsIHsgJ3RyeSc6IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYodGhpcyk7XG4gIHZhciByZXN1bHQgPSBwZXJmb3JtKGNhbGxiYWNrZm4pO1xuICAocmVzdWx0LmUgPyBwcm9taXNlQ2FwYWJpbGl0eS5yZWplY3QgOiBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlKShyZXN1bHQudik7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufSB9KTtcbiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7XG4iLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgRE9NSXRlcmFibGVzID0gKCdDU1NSdWxlTGlzdCxDU1NTdHlsZURlY2xhcmF0aW9uLENTU1ZhbHVlTGlzdCxDbGllbnRSZWN0TGlzdCxET01SZWN0TGlzdCxET01TdHJpbmdMaXN0LCcgK1xuICAnRE9NVG9rZW5MaXN0LERhdGFUcmFuc2Zlckl0ZW1MaXN0LEZpbGVMaXN0LEhUTUxBbGxDb2xsZWN0aW9uLEhUTUxDb2xsZWN0aW9uLEhUTUxGb3JtRWxlbWVudCxIVE1MU2VsZWN0RWxlbWVudCwnICtcbiAgJ01lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsJyArXG4gICdTVkdQYXRoU2VnTGlzdCxTVkdQb2ludExpc3QsU1ZHU3RyaW5nTGlzdCxTVkdUcmFuc2Zvcm1MaXN0LFNvdXJjZUJ1ZmZlckxpc3QsU3R5bGVTaGVldExpc3QsVGV4dFRyYWNrQ3VlTGlzdCwnICtcbiAgJ1RleHRUcmFja0xpc3QsVG91Y2hMaXN0Jykuc3BsaXQoJywnKTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBET01JdGVyYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBET01JdGVyYWJsZXNbaV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZiAocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CLCB7XG4gIHNldEltbWVkaWF0ZTogJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgUmVmbGVjdEFwcGx5KHRoaXMubGlzdGVuZXIsIHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iLCIvKlxuICogZXh0c3ByaW50Zi5qczogZXh0ZW5kZWQgUE9TSVgtc3R5bGUgc3ByaW50ZlxuICovXG5cbnZhciBtb2RfYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgbW9kX3V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qXG4gKiBQdWJsaWMgaW50ZXJmYWNlXG4gKi9cbmV4cG9ydHMuc3ByaW50ZiA9IGpzU3ByaW50ZjtcbmV4cG9ydHMucHJpbnRmID0ganNQcmludGY7XG5leHBvcnRzLmZwcmludGYgPSBqc0ZwcmludGY7XG5cbi8qXG4gKiBTdHJpcHBlZCBkb3duIHZlcnNpb24gb2Ygc1tuXXByaW50ZigzYykuICBXZSBtYWtlIGEgYmVzdCBlZmZvcnQgdG8gdGhyb3cgYW5cbiAqIGV4Y2VwdGlvbiB3aGVuIGdpdmVuIGEgZm9ybWF0IHN0cmluZyB3ZSBkb24ndCB1bmRlcnN0YW5kLCByYXRoZXIgdGhhblxuICogaWdub3JpbmcgaXQsIHNvIHRoYXQgd2Ugd29uJ3QgYnJlYWsgZXhpc3RpbmcgcHJvZ3JhbXMgaWYvd2hlbiB3ZSBnbyBpbXBsZW1lbnRcbiAqIHRoZSByZXN0IG9mIHRoaXMuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBjdXJyZW50bHkgc3VwcG9ydHMgc3BlY2lmeWluZ1xuICpcdC0gZmllbGQgYWxpZ25tZW50ICgnLScgZmxhZyksXG4gKiBcdC0gemVyby1wYWQgKCcwJyBmbGFnKVxuICpcdC0gYWx3YXlzIHNob3cgbnVtZXJpYyBzaWduICgnKycgZmxhZyksXG4gKlx0LSBmaWVsZCB3aWR0aFxuICpcdC0gY29udmVyc2lvbnMgZm9yIHN0cmluZ3MsIGRlY2ltYWwgaW50ZWdlcnMsIGFuZCBmbG9hdHMgKG51bWJlcnMpLlxuICpcdC0gYXJndW1lbnQgc2l6ZSBzcGVjaWZpZXJzLiAgVGhlc2UgYXJlIGFsbCBhY2NlcHRlZCBidXQgaWdub3JlZCwgc2luY2VcbiAqXHQgIEphdmFzY3JpcHQgaGFzIG5vIG5vdGlvbiBvZiB0aGUgcGh5c2ljYWwgc2l6ZSBvZiBhbiBhcmd1bWVudC5cbiAqXG4gKiBFdmVyeXRoaW5nIGVsc2UgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLCBtb3N0IG5vdGFibHkgcHJlY2lzaW9uLCB1bnNpZ25lZFxuICogbnVtYmVycywgbm9uLWRlY2ltYWwgbnVtYmVycywgYW5kIGNoYXJhY3RlcnMuXG4gKi9cbmZ1bmN0aW9uIGpzU3ByaW50ZihmbXQpXG57XG5cdHZhciByZWdleCA9IFtcblx0ICAgICcoW14lXSopJyxcdFx0XHRcdC8qIG5vcm1hbCB0ZXh0ICovXG5cdCAgICAnJScsXHRcdFx0XHQvKiBzdGFydCBvZiBmb3JtYXQgKi9cblx0ICAgICcoW1xcJ1xcXFwtKyAjMF0qPyknLFx0XHRcdC8qIGZsYWdzIChvcHRpb25hbCkgKi9cblx0ICAgICcoWzEtOV1cXFxcZCopPycsXHRcdFx0Lyogd2lkdGggKG9wdGlvbmFsKSAqL1xuXHQgICAgJyhcXFxcLihbMS05XVxcXFxkKikpPycsXHRcdC8qIHByZWNpc2lvbiAob3B0aW9uYWwpICovXG5cdCAgICAnW2xoanp0TF0qPycsXHRcdFx0LyogbGVuZ3RoIG1vZHMgKGlnbm9yZWQpICovXG5cdCAgICAnKFtkaW91eFhmRmVFZ0dhQWNDc1NwJWpyXSknXHQvKiBjb252ZXJzaW9uICovXG5cdF0uam9pbignJyk7XG5cblx0dmFyIHJlID0gbmV3IFJlZ0V4cChyZWdleCk7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0dmFyIGZsYWdzLCB3aWR0aCwgcHJlY2lzaW9uLCBjb252ZXJzaW9uO1xuXHR2YXIgbGVmdCwgcGFkLCBzaWduLCBhcmcsIG1hdGNoO1xuXHR2YXIgcmV0ID0gJyc7XG5cdHZhciBhcmduID0gMTtcblxuXHRtb2RfYXNzZXJ0LmVxdWFsKCdzdHJpbmcnLCB0eXBlb2YgKGZtdCkpO1xuXG5cdHdoaWxlICgobWF0Y2ggPSByZS5leGVjKGZtdCkpICE9PSBudWxsKSB7XG5cdFx0cmV0ICs9IG1hdGNoWzFdO1xuXHRcdGZtdCA9IGZtdC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcblxuXHRcdGZsYWdzID0gbWF0Y2hbMl0gfHwgJyc7XG5cdFx0d2lkdGggPSBtYXRjaFszXSB8fCAwO1xuXHRcdHByZWNpc2lvbiA9IG1hdGNoWzRdIHx8ICcnO1xuXHRcdGNvbnZlcnNpb24gPSBtYXRjaFs2XTtcblx0XHRsZWZ0ID0gZmFsc2U7XG5cdFx0c2lnbiA9IGZhbHNlO1xuXHRcdHBhZCA9ICcgJztcblxuXHRcdGlmIChjb252ZXJzaW9uID09ICclJykge1xuXHRcdFx0cmV0ICs9ICclJztcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmIChhcmdzLmxlbmd0aCA9PT0gMClcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ3RvbyBmZXcgYXJncyB0byBzcHJpbnRmJykpO1xuXG5cdFx0YXJnID0gYXJncy5zaGlmdCgpO1xuXHRcdGFyZ24rKztcblxuXHRcdGlmIChmbGFncy5tYXRjaCgvW1xcJyAjXS8pKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcihcblx0XHRcdCAgICAndW5zdXBwb3J0ZWQgZmxhZ3M6ICcgKyBmbGFncykpO1xuXG5cdFx0aWYgKHByZWNpc2lvbi5sZW5ndGggPiAwKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcihcblx0XHRcdCAgICAnbm9uLXplcm8gcHJlY2lzaW9uIG5vdCBzdXBwb3J0ZWQnKSk7XG5cblx0XHRpZiAoZmxhZ3MubWF0Y2goLy0vKSlcblx0XHRcdGxlZnQgPSB0cnVlO1xuXG5cdFx0aWYgKGZsYWdzLm1hdGNoKC8wLykpXG5cdFx0XHRwYWQgPSAnMCc7XG5cblx0XHRpZiAoZmxhZ3MubWF0Y2goL1xcKy8pKVxuXHRcdFx0c2lnbiA9IHRydWU7XG5cblx0XHRzd2l0Y2ggKGNvbnZlcnNpb24pIHtcblx0XHRjYXNlICdzJzpcblx0XHRcdGlmIChhcmcgPT09IHVuZGVmaW5lZCB8fCBhcmcgPT09IG51bGwpXG5cdFx0XHRcdHRocm93IChuZXcgRXJyb3IoJ2FyZ3VtZW50ICcgKyBhcmduICtcblx0XHRcdFx0ICAgICc6IGF0dGVtcHRlZCB0byBwcmludCB1bmRlZmluZWQgb3IgbnVsbCAnICtcblx0XHRcdFx0ICAgICdhcyBhIHN0cmluZycpKTtcblx0XHRcdHJldCArPSBkb1BhZChwYWQsIHdpZHRoLCBsZWZ0LCBhcmcudG9TdHJpbmcoKSk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ2QnOlxuXHRcdFx0YXJnID0gTWF0aC5mbG9vcihhcmcpO1xuXHRcdFx0Lypqc2w6ZmFsbHRocnUqL1xuXHRcdGNhc2UgJ2YnOlxuXHRcdFx0c2lnbiA9IHNpZ24gJiYgYXJnID4gMCA/ICcrJyA6ICcnO1xuXHRcdFx0cmV0ICs9IHNpZ24gKyBkb1BhZChwYWQsIHdpZHRoLCBsZWZ0LFxuXHRcdFx0ICAgIGFyZy50b1N0cmluZygpKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAneCc6XG5cdFx0XHRyZXQgKz0gZG9QYWQocGFkLCB3aWR0aCwgbGVmdCwgYXJnLnRvU3RyaW5nKDE2KSk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ2onOiAvKiBub24tc3RhbmRhcmQgKi9cblx0XHRcdGlmICh3aWR0aCA9PT0gMClcblx0XHRcdFx0d2lkdGggPSAxMDtcblx0XHRcdHJldCArPSBtb2RfdXRpbC5pbnNwZWN0KGFyZywgZmFsc2UsIHdpZHRoKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAncic6IC8qIG5vbi1zdGFuZGFyZCAqL1xuXHRcdFx0cmV0ICs9IGR1bXBFeGNlcHRpb24oYXJnKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIGNvbnZlcnNpb246ICcgK1xuXHRcdFx0ICAgIGNvbnZlcnNpb24pKTtcblx0XHR9XG5cdH1cblxuXHRyZXQgKz0gZm10O1xuXHRyZXR1cm4gKHJldCk7XG59XG5cbmZ1bmN0aW9uIGpzUHJpbnRmKCkge1xuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdGFyZ3MudW5zaGlmdChwcm9jZXNzLnN0ZG91dCk7XG5cdGpzRnByaW50Zi5hcHBseShudWxsLCBhcmdzKTtcbn1cblxuZnVuY3Rpb24ganNGcHJpbnRmKHN0cmVhbSkge1xuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdHJldHVybiAoc3RyZWFtLndyaXRlKGpzU3ByaW50Zi5hcHBseSh0aGlzLCBhcmdzKSkpO1xufVxuXG5mdW5jdGlvbiBkb1BhZChjaHIsIHdpZHRoLCBsZWZ0LCBzdHIpXG57XG5cdHZhciByZXQgPSBzdHI7XG5cblx0d2hpbGUgKHJldC5sZW5ndGggPCB3aWR0aCkge1xuXHRcdGlmIChsZWZ0KVxuXHRcdFx0cmV0ICs9IGNocjtcblx0XHRlbHNlXG5cdFx0XHRyZXQgPSBjaHIgKyByZXQ7XG5cdH1cblxuXHRyZXR1cm4gKHJldCk7XG59XG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIGR1bXBzIGxvbmcgc3RhY2sgdHJhY2VzIGZvciBleGNlcHRpb25zIGhhdmluZyBhIGNhdXNlKCkgbWV0aG9kLlxuICogU2VlIG5vZGUtdmVycm9yIGZvciBhbiBleGFtcGxlLlxuICovXG5mdW5jdGlvbiBkdW1wRXhjZXB0aW9uKGV4KVxue1xuXHR2YXIgcmV0O1xuXG5cdGlmICghKGV4IGluc3RhbmNlb2YgRXJyb3IpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoanNTcHJpbnRmKCdpbnZhbGlkIHR5cGUgZm9yICUlcjogJWonLCBleCkpKTtcblxuXHQvKiBOb3RlIHRoYXQgVjggcHJlcGVuZHMgXCJleC5zdGFja1wiIHdpdGggZXgudG9TdHJpbmcoKS4gKi9cblx0cmV0ID0gJ0VYQ0VQVElPTjogJyArIGV4LmNvbnN0cnVjdG9yLm5hbWUgKyAnOiAnICsgZXguc3RhY2s7XG5cblx0aWYgKGV4LmNhdXNlICYmIHR5cGVvZiAoZXguY2F1c2UpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGNleCA9IGV4LmNhdXNlKCk7XG5cdFx0aWYgKGNleCkge1xuXHRcdFx0cmV0ICs9ICdcXG5DYXVzZWQgYnk6ICcgKyBkdW1wRXhjZXB0aW9uKGNleCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIChyZXQpO1xufVxuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnID8gc2VsZi5Gb3JtRGF0YSA6IHdpbmRvdy5Gb3JtRGF0YTtcbiIsInZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcblxudmFyIGh0dHBzID0gbW9kdWxlLmV4cG9ydHNcblxuZm9yICh2YXIga2V5IGluIGh0dHApIHtcbiAgaWYgKGh0dHAuaGFzT3duUHJvcGVydHkoa2V5KSkgaHR0cHNba2V5XSA9IGh0dHBba2V5XVxufVxuXG5odHRwcy5yZXF1ZXN0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgcGFyYW1zID0gdmFsaWRhdGVQYXJhbXMocGFyYW1zKVxuICByZXR1cm4gaHR0cC5yZXF1ZXN0LmNhbGwodGhpcywgcGFyYW1zLCBjYilcbn1cblxuaHR0cHMuZ2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgcGFyYW1zID0gdmFsaWRhdGVQYXJhbXMocGFyYW1zKVxuICByZXR1cm4gaHR0cC5nZXQuY2FsbCh0aGlzLCBwYXJhbXMsIGNiKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVBhcmFtcyAocGFyYW1zKSB7XG4gIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgIHBhcmFtcyA9IHVybC5wYXJzZShwYXJhbXMpXG4gIH1cbiAgaWYgKCFwYXJhbXMucHJvdG9jb2wpIHtcbiAgICBwYXJhbXMucHJvdG9jb2wgPSAnaHR0cHM6J1xuICB9XG4gIGlmIChwYXJhbXMucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQcm90b2NvbCBcIicgKyBwYXJhbXMucHJvdG9jb2wgKyAnXCIgbm90IHN1cHBvcnRlZC4gRXhwZWN0ZWQgXCJodHRwczpcIicpXG4gIH1cbiAgcmV0dXJuIHBhcmFtc1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKlxuICogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqL1xuXG4vKlxuICogQ29weXJpZ2h0IDIwMTYsIEpveWVudCwgSW5jLlxuICovXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGpzcHJpbSA9IHJlcXVpcmUoJ2pzcHJpbScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cblxuLy8vLS0tIEhlbHBlcnNcblxuZnVuY3Rpb24gUGFyc2VFcnJvcihpbnB1dCwgbWVzc2FnZSwgaW5kZXgpIHtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFBhcnNlRXJyb3IpO1xuXG4gIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLm1lc3NhZ2UgKz0gJyBhdCBpbmRleCAnICsgaW5kZXg7XG4gIH1cbn1cbnV0aWwuaW5oZXJpdHMoUGFyc2VFcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiBtb2R1bG8oYSwgbikge1xuICByZXR1cm4gKG4gKyAoYSAlIG4pKSAlIG47XG59XG5cbmZ1bmN0aW9uIF9hcnJheVRvT2N0ZXRTdHJpbmcoaW5wdXQpIHtcbiAgdmFyIG91dDtcbiAgb3V0ID0gKGlucHV0WzBdID4+IDgpICsgJy4nICsgKGlucHV0WzBdICYgMHhmZikgKyAnLic7XG4gIG91dCArPSAoaW5wdXRbMV0gPj4gOCkgKyAnLicgKyAoaW5wdXRbMV0gJiAweGZmKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gX2lzQWRkcihhZGRyKSB7XG4gIGlmICh0eXBlb2YgKGFkZHIpID09PSAnb2JqZWN0Jykge1xuICAgIC8qIEl0IG11c3QgcmVzZW1ibGUgYW4gQWRkciBvYmplY3QgKi9cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhZGRyLl9maWVsZHMpICYmIHR5cGVvZiAoYWRkci5fYXR0cnMpID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3RvQWRkcihpbnB1dCkge1xuICBpZiAodHlwZW9mIChpbnB1dCkgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGlwNmFkZHJQYXJzZShpbnB1dCk7XG4gIH0gZWxzZSBpZiAoX2lzQWRkcihpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50OiBBZGRyIG9yIHBhcnNhYmxlIHN0cmluZyBleHBlY3RlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hcnJheVRvSGV4KGlucHV0LCB6ZXJvRWxpZGUsIHplcm9QYWQpIHtcbiAgdmFyIGk7XG4gIHZhciBlbFN0YXJ0ID0gbnVsbDtcbiAgdmFyIGVsTGVuID0gMDtcbiAgaWYgKHplcm9FbGlkZSkge1xuICAgIC8qIGZpbmQgbG9uZ2VzdCBydW4gb2YgemVyb2VzIHRvIHBvdGVudGlhbGx5IGVsaWRlICovXG4gICAgdmFyIHN0YXJ0ID0gbnVsbDtcbiAgICB2YXIgbGVuID0gbnVsbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpbnB1dFtpXSA9PT0gMCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgbGVuID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobGVuID4gZWxMZW4pIHtcbiAgICAgICAgICBlbFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgZWxMZW4gPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBjYXB0dXJpbmcgbGFzdCBwb3RlbnRpYWwgemVybyAqL1xuICAgIGlmIChzdGFydCAhPT0gbnVsbCAmJiBsZW4gPiBlbExlbikge1xuICAgICAgZWxTdGFydCA9IHN0YXJ0O1xuICAgICAgZWxMZW4gPSBsZW47XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dCA9IFtdO1xuICB2YXIgbnVtO1xuICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZWxTdGFydCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGkgPT09IGVsU3RhcnQpIHtcbiAgICAgICAgaWYgKGVsTGVuID09PSA4KSB7XG4gICAgICAgICAgLyogYWxsLXplcm9lcyBpcyBqdXN0ICc6OicgKi9cbiAgICAgICAgICByZXR1cm4gWyc6OiddO1xuICAgICAgICB9IGVsc2UgaWYgKGVsU3RhcnQgPT09IDAgfHwgZWxTdGFydCArIGVsTGVuID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIEZvciBlbGlkZWQgemVyb2VzIGF0IHRoZSBiZWdpbm5pbmcvZW5kIG9mIHRoZSBhZGRyZXNzLCBhbiBleHRyYVxuICAgICAgICAgICAqICc6JyBpcyBuZWVkZWQgZHVyaW5nIHRoZSBqb2luIHN0ZXAuXG4gICAgICAgICAgICovXG4gICAgICAgICAgb3V0cHV0LnB1c2goJzonKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID49IGVsU3RhcnQgJiYgaSA8IGVsU3RhcnQgKyBlbExlbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbnVtID0gaW5wdXRbaV0udG9TdHJpbmcoMTYpO1xuICAgIGlmICh6ZXJvUGFkICYmIG51bS5sZW5ndGggIT0gNCkge1xuICAgICAgbnVtID0gJzAwMDAnLnNsaWNlKG51bS5sZW5ndGgpICsgbnVtO1xuICAgIH1cbiAgICBvdXRwdXQucHVzaChudW0pO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIF9pcHY0TWFwcGVkKGlucHV0KSB7XG4gIHZhciBjb21wID0gWzAsIDAsIDAsIDAsIDAsIDB4ZmZmZl07XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgaWYgKGlucHV0W2ldICE9IGNvbXBbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIF9wcmVmaXhUb0FkZHIobGVuKSB7XG4gIGFzc2VydC5udW1iZXIobGVuKTtcbiAgbGVuID0gbGVuIHwgMDtcbiAgYXNzZXJ0Lm9rKGxlbiA8PSAxMjgpO1xuICBhc3NlcnQub2sobGVuID49IDApO1xuXG4gIHZhciBvdXRwdXQgPSBuZXcgQWRkcigpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgbGVuID4gMTY7IGkrKywgbGVuIC09IDE2KSB7XG4gICAgb3V0cHV0Ll9maWVsZHNbaV0gPSAweGZmZmY7XG4gIH1cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBvdXRwdXQuX2ZpZWxkc1tpXSA9IDB4ZmZmZiAtICgoMSA8PCAoMTYgLSBsZW4pKSAtIDEpO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIF90b0NJRFIoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiAoaW5wdXQpID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgQ0lEUihpbnB1dCk7XG4gIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDSURSKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudDogQ0lEUiBvciBwYXJzYWJsZSBzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgfVxufVxuXG52YXIgc3RyRGVmYXVsdHMgPSB7XG4gIGZvcm1hdDogJ2F1dG8nLCAvLyBDb250cm9sIGZvcm1hdCBvZiBwcmludGVkIGFkZHJlc3NcbiAgemVyb0VsaWRlOiB0cnVlLCAvLyBFbGlkZSBsb25nZXN0IHJ1biBvZiB6ZXJvc1xuICB6ZXJvUGFkOiBmYWxzZSAvLyBQYWQgd2l0aCB6ZXJvcyB3aGVuIGEgZ3JvdXAgd291bGQgcHJpbnQgYXMgPCA0IGNoYXJzXG59O1xuXG5mdW5jdGlvbiBnZXRTdHJPcHQob3B0cywgbmFtZSkge1xuICBpZiAob3B0cyAmJiBvcHRzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIG9wdHNbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0ckRlZmF1bHRzW25hbWVdO1xuICB9XG59XG5cbi8vLy0tLSBQdWJsaWMgQ2xhc3Nlc1xuXG4vKipcbiAqIElQdjYvSVB2NCBhZGRyZXNzIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEl0IHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5IGJ5IGxpYnJhcnkgY29uc3VtZXJzLlxuICovXG5mdW5jdGlvbiBBZGRyKCkge1xuICB0aGlzLl9maWVsZHMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gIHRoaXMuX2F0dHJzID0ge307XG59XG5cbkFkZHIucHJvdG90eXBlLmtpbmQgPSBmdW5jdGlvbiBnZXRLaW5kKCkge1xuICBpZiAodjRzdWJuZXQuY29udGFpbnModGhpcykpIHtcbiAgICByZXR1cm4gJ2lwdjQnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnaXB2Nic7XG4gIH1cbn07XG5cbkFkZHIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0cykge1xuICBhc3NlcnQub3B0aW9uYWxPYmplY3Qob3B0cywgJ29wdHMnKTtcbiAgdmFyIGZvcm1hdCA9IGdldFN0ck9wdChvcHRzLCAnZm9ybWF0Jyk7XG4gIHZhciB6ZXJvRWxpZGUgPSBnZXRTdHJPcHQob3B0cywgJ3plcm9FbGlkZScpO1xuICB2YXIgemVyb1BhZCA9IGdldFN0ck9wdChvcHRzLCAnemVyb1BhZCcpO1xuXG4gIGFzc2VydC5zdHJpbmcoZm9ybWF0LCAnb3B0cy5mb3JtYXQnKTtcbiAgYXNzZXJ0LmJvb2woemVyb0VsaWRlLCAnb3B0cy56ZXJvRWxpZGUnKTtcbiAgYXNzZXJ0LmJvb2woemVyb1BhZCwgJ29wdHMuemVyb1BhZCcpO1xuXG4gIC8vIFRyeSB0byBwcmludCB0aGUgYWRkcmVzcyB0aGUgd2F5IGl0IHdhcyBvcmlnaW5hbGx5IGZvcm1hdHRlZFxuICBpZiAoZm9ybWF0ID09PSAnYXV0bycpIHtcbiAgICBpZiAodGhpcy5fYXR0cnMuaXB2NEJhcmUpIHtcbiAgICAgIGZvcm1hdCA9ICd2NCc7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9hdHRycy5pcHY0TWFwcGVkKSB7XG4gICAgICBmb3JtYXQgPSAndjQtbWFwcGVkJztcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybWF0ID0gJ3Y2JztcbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAvLyBQcmludCBpbiBkb3R0ZWQtcXVhZCBub3RhdGlvbiAoYnV0IG9ubHkgaWYgdHJ1bHkgSVB2NClcbiAgY2FzZSAndjQnOlxuICAgIGlmICghdjRzdWJuZXQuY29udGFpbnModGhpcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcHJpbnQgbm9uLXY0IGFkZHJlc3MgaW4gZG90dGVkIHF1YWQgbm90YXRpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIF9hcnJheVRvT2N0ZXRTdHJpbmcodGhpcy5fZmllbGRzLnNsaWNlKDYpKTtcblxuICAvLyBQcmludCBhcyBhbiBJUHY0LW1hcHBlZCBJUHY2IGFkZHJlc3NcbiAgY2FzZSAndjQtbWFwcGVkJzpcbiAgICBpZiAoIXY0c3VibmV0LmNvbnRhaW5zKHRoaXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHByaW50IG5vbi12NCBhZGRyZXNzIGFzIGEgdjQtbWFwcGVkIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IF9hcnJheVRvSGV4KHRoaXMuX2ZpZWxkcy5zbGljZSgwLCA2KSwgemVyb0VsaWRlLCB6ZXJvUGFkKTtcbiAgICBvdXRwdXQucHVzaChfYXJyYXlUb09jdGV0U3RyaW5nKHRoaXMuX2ZpZWxkcy5zbGljZSg2KSkpO1xuICAgIHJldHVybiBvdXRwdXQuam9pbignOicpO1xuXG4gIC8vIFByaW50IGFzIGFuIElQdjYgYWRkcmVzc1xuICBjYXNlICd2Nic6XG4gICAgcmV0dXJuIF9hcnJheVRvSGV4KHRoaXMuX2ZpZWxkcywgemVyb0VsaWRlLCB6ZXJvUGFkKS5qb2luKCc6Jyk7XG5cbiAgLy8gVW5yZWNvZ25pemVkIGZvcm1hdHRpbmcgbWV0aG9kXG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgZm9ybWF0IG1ldGhvZCBcIicgKyBmb3JtYXQgKyAnXCInKTtcbiAgfVxufTtcblxuQWRkci5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcihidWYpIHtcbiAgaWYgKGJ1ZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25hbCBhcmcgbXVzdCBiZSBCdWZmZXInKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IEJ1ZmZlcigxNik7XG4gIH1cbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICBidWYud3JpdGVVSW50MTZCRSh0aGlzLl9maWVsZHNbaV0sIGkqMik7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbkFkZHIucHJvdG90eXBlLnRvTG9uZyA9IGZ1bmN0aW9uIHRvTG9uZygpIHtcbiAgaWYgKCF2NHN1Ym5ldC5jb250YWlucyh0aGlzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignb25seSBwb3NzaWJsZSBmb3IgaXB2NC1tYXBwZWQgYWRkcmVzc2VzJyk7XG4gIH1cbiAgcmV0dXJuICgodGhpcy5fZmllbGRzWzZdIDw8IDE2KSA+Pj4gMCkgKyB0aGlzLl9maWVsZHNbN107XG59O1xuXG5BZGRyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lQWRkcigpIHtcbiAgdmFyIG91dCA9IG5ldyBBZGRyKCk7XG4gIG91dC5fZmllbGRzID0gdGhpcy5fZmllbGRzLnNsaWNlKCk7XG4gIGZvciAodmFyIGsgaW4gdGhpcy5fYXR0cnMpIHtcbiAgICAgIG91dC5fYXR0cnNba10gPSB0aGlzLl9hdHRyc1trXTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuQWRkci5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0KG51bSkge1xuICBpZiAobnVtIDwgLTQyOTQ5NjcyOTUgfHwgbnVtID4gNDI5NDk2NzI5NSkge1xuICAgIHRocm93IG5ldyBFcnJvcignb2Zmc2V0cyBzaG91bGQgYmUgYmV0d2VlbiAtNDI5NDk2NzI5NSBhbmQgNDI5NDk2NzI5NScpO1xuICB9XG4gIHZhciBvdXQgPSB0aGlzLmNsb25lKCk7XG4gIHZhciBpLCBtb3ZlZDtcbiAgZm9yIChpID0gNzsgaSA+PSAwOyBpLS0pIHtcbiAgICBtb3ZlZCA9IG91dC5fZmllbGRzW2ldICsgbnVtO1xuICAgIGlmIChtb3ZlZCA+IDY1NTM1KSB7XG4gICAgICBudW0gPSBtb3ZlZCA+Pj4gMTY7XG4gICAgICBtb3ZlZCA9IG1vdmVkICYgMHhmZmZmO1xuICAgIH0gZWxzZSBpZiAobW92ZWQgPCAwKSB7XG4gICAgICBudW0gPSBNYXRoLmZsb29yKG1vdmVkIC8gKDEgPDwgMTYpKTtcbiAgICAgIG1vdmVkID0gbW9kdWxvKG1vdmVkLCAxIDw8IDE2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtID0gMDtcbiAgICB9XG4gICAgb3V0Ll9maWVsZHNbaV0gPSBtb3ZlZDtcblxuICAgIC8qIFByZXZlbnQgd3JhcC1hcm91bmQgZm9yIGJvdGggaXB2NiBhbmQgaXB2NC1tYXBwZWQgYWRkcmVzc2VzICovXG4gICAgaWYgKG51bSAhPT0gMCkge1xuICAgICAgaWYgKChpID09PSAwKSB8fCAoaSA9PT0gNiAmJiB0aGlzLl9hdHRycy5pcHY0TWFwcGVkKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5BZGRyLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhZGRyQW5kKGlucHV0KSB7XG4gIGlucHV0ID0gX3RvQWRkcihpbnB1dCk7XG4gIHZhciBpO1xuICB2YXIgb3V0cHV0ID0gdGhpcy5jbG9uZSgpO1xuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgb3V0cHV0Ll9maWVsZHNbaV0gPSBvdXRwdXQuX2ZpZWxkc1tpXSAmIGlucHV0Ll9maWVsZHNbaV07XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbkFkZHIucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gYWRkck9yKGlucHV0KSB7XG4gIGlucHV0ID0gX3RvQWRkcihpbnB1dCk7XG4gIHZhciBpO1xuICB2YXIgb3V0cHV0ID0gdGhpcy5jbG9uZSgpO1xuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgb3V0cHV0Ll9maWVsZHNbaV0gPSBvdXRwdXQuX2ZpZWxkc1tpXSB8IGlucHV0Ll9maWVsZHNbaV07XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbkFkZHIucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIGFkZHJOb3QoKSB7XG4gIHZhciBpO1xuICB2YXIgb3V0cHV0ID0gdGhpcy5jbG9uZSgpO1xuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgb3V0cHV0Ll9maWVsZHNbaV0gPSAofiBvdXRwdXQuX2ZpZWxkc1tpXSkgJiAweGZmZmY7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbkFkZHIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlTWVtYmVyKGFkZHIpIHtcbiAgcmV0dXJuIGlwNmFkZHJDb21wYXJlKHRoaXMsIGFkZHIpO1xufTtcblxuLyoqXG4gKiBDSURSIEJsb2NrXG4gKiBAcGFyYW0gYWRkciBDSURSIG5ldHdvcmsgYWRkcmVzc1xuICogQHBhcmFtIHByZWZpeExlbiBMZW5ndGggb2YgbmV0d29yayBwcmVmaXhcbiAqXG4gKiBUaGUgYWRkciBwYXJhbWV0ZXIgY2FuIGJlIGFuIEFkZHIgb2JqZWN0IG9yIGEgcGFyc2VhYmxlIHN0cmluZy5cbiAqIElmIHByZWZpeExlbiBpcyBvbWl0dGVkLCB0aGVuIGFkZHIgbXVzdCBjb250YWluIGEgcGFyc2VhYmxlIHN0cmluZyBpbiB0aGVcbiAqIGZvcm0gJzxhZGRyZXNzPi88cHJlZml4PicuXG4gKi9cbmZ1bmN0aW9uIENJRFIoYWRkciwgcHJlZml4TGVuKSB7XG4gIGlmIChwcmVmaXhMZW4gPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIE9LIHRvIHBhc3MgcGFzcyBzdHJpbmcgb2YgXCI8YWRkcj4vPHByZWZpeD5cIiAqL1xuICAgIGFzc2VydC5zdHJpbmcoYWRkcik7XG4gICAgdmFyIGZpZWxkcyA9IGFkZHIubWF0Y2goL14oW2EtZkEtRjAtOTouXSspXFwvKFswLTldKykkLyk7XG4gICAgaWYgKGZpZWxkcyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50OiA8YWRkcj4vPHByZWZpeD4gZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgYWRkciA9IGZpZWxkc1sxXTtcbiAgICBwcmVmaXhMZW4gPSBwYXJzZUludChmaWVsZHNbMl0sIDEwKTtcbiAgfVxuICBhc3NlcnQubnVtYmVyKHByZWZpeExlbik7XG4gIHByZWZpeExlbiA9IHByZWZpeExlbiB8IDA7XG4gIGFkZHIgPSBfdG9BZGRyKGFkZHIpO1xuXG4gIC8qIEV4cGFuZCBwcmVmaXggdG8gaXB2NiBsZW5ndGggb2YgYmFyZSBpcHY0IGFkZHJlc3MgcHJvdmlkZWQgKi9cbiAgaWYgKGFkZHIuX2F0dHJzLmlwdjRCYXJlKSB7XG4gICAgcHJlZml4TGVuICs9IDk2O1xuICB9XG4gIGlmIChwcmVmaXhMZW4gPCAwIHx8IHByZWZpeExlbiA+IDEyOCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmVmaXggbGVuZ3RoJyk7XG4gIH1cbiAgdGhpcy5fcHJlZml4ID0gcHJlZml4TGVuO1xuICB0aGlzLl9tYXNrID0gX3ByZWZpeFRvQWRkcihwcmVmaXhMZW4pO1xuICB0aGlzLl9hZGRyID0gYWRkci5hbmQodGhpcy5fbWFzayk7XG59XG5cbkNJRFIucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gY2lkckNvbnRhaW5zKGlucHV0KSB7XG4gIGlucHV0ID0gX3RvQWRkcihpbnB1dCk7XG4gIHJldHVybiAodGhpcy5fYWRkci5jb21wYXJlKGlucHV0LmFuZCh0aGlzLl9tYXNrKSkgPT09IDApO1xufTtcblxuQ0lEUi5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbiBjaWRyRmlyc3QoKSB7XG4gIGlmICh0aGlzLl9wcmVmaXggPj0gMTI3KSB7XG4gICAgLyogU3VwcG9ydCBzaW5nbGUtYWRkcmVzcyBhbmQgcG9pbnQtdG8tcG9pbnQgbmV0d29ya3MgKi9cbiAgICByZXR1cm4gdGhpcy5fYWRkcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkci5vZmZzZXQoMSk7XG4gIH1cbn07XG5cbkNJRFIucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbiBjaWRyTGFzdCgpIHtcbiAgdmFyIGVuZGluZyA9IHRoaXMuX2FkZHIub3IodGhpcy5fbWFzay5ub3QoKSk7XG4gIGlmICh0aGlzLl9wcmVmaXggPj0gMTI3KSB7XG4gICAgLyogU3VwcG9ydCBzaW5nbGUtYWRkcmVzcyBhbmQgcG9pbnQtdG8tcG9pbnQgbmV0d29ya3MgKi9cbiAgICByZXR1cm4gZW5kaW5nO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLl9hZGRyLl9hdHRycy5pcHY0TWFwcGVkKSB7XG4gICAgICAvKiBkb24ndCBpbmNsdWRlIHRoZSBicm9hZGNhc3QgZm9yIGlwdjQgKi9cbiAgICAgIHJldHVybiBlbmRpbmcub2Zmc2V0KC0xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVuZGluZztcbiAgICB9XG4gIH1cbn07XG5cbkNJRFIucHJvdG90eXBlLmJyb2FkY2FzdCA9IGZ1bmN0aW9uIGdldEJyb2FkY2FzdCgpIHtcbiAgaWYgKCF2NHN1Ym5ldC5jb250YWlucyh0aGlzLl9hZGRyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignT25seSBJUHY0IG5ldHdvcmtzIGhhdmUgYnJvYWRjYXN0IGFkZHJlc3NlcycpO1xuICB9XG4gIHJldHVybiB0aGlzLl9hZGRyLm9yKHRoaXMuX21hc2subm90KCkpO1xufTtcblxuQ0lEUi5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmVDSURSKGNpZHIpIHtcbiAgcmV0dXJuIGlwNmNpZHJDb21wYXJlKHRoaXMsIGNpZHIpO1xufTtcblxuQ0lEUi5wcm90b3R5cGUucHJlZml4TGVuZ3RoID0gZnVuY3Rpb24gZ2V0UHJlZml4TGVuZ3RoKGZvcm1hdCkge1xuICBhc3NlcnQub3B0aW9uYWxTdHJpbmcoZm9ybWF0LCAnZm9ybWF0Jyk7XG4gIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCB8fCBmb3JtYXQgPT09ICdhdXRvJykge1xuICAgIGZvcm1hdCA9IHRoaXMuX2FkZHIuX2F0dHJzLmlwdjRCYXJlID8gJ3Y0JyA6ICd2Nic7XG4gIH1cblxuICBzd2l0Y2ggKGZvcm1hdCkge1xuICBjYXNlICd2NCc6XG4gICAgaWYgKCF2NHN1Ym5ldC5jb250YWlucyh0aGlzLl9hZGRyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZXR1cm4gdjQgcHJlZml4IGxlbmd0aCBmb3Igbm9uLXY0IGFkZHJlc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ByZWZpeCAtIDk2O1xuICBjYXNlICd2Nic6XG4gICAgcmV0dXJuIHRoaXMuX3ByZWZpeDtcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBmb3JtYXQgbWV0aG9kIFwiJyArIGZvcm1hdCArICdcIicpO1xuICB9XG59O1xuXG5DSURSLnByb3RvdHlwZS5hZGRyZXNzID0gZnVuY3Rpb24gZ2V0QWRkcmVzc0NvbXBvbmVudCgpIHtcbiAgcmV0dXJuIHRoaXMuX2FkZHI7XG59O1xuXG5DSURSLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIGNpZHJTdHJpbmcob3B0cykge1xuICBhc3NlcnQub3B0aW9uYWxPYmplY3Qob3B0cywgJ29wdHMnKTtcblxuICB2YXIgZm9ybWF0ID0gZ2V0U3RyT3B0KG9wdHMsICdmb3JtYXQnKTtcbiAgaWYgKGZvcm1hdCA9PT0gJ3Y0LW1hcHBlZCcpIHtcbiAgICBmb3JtYXQgPSAndjYnO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2FkZHIudG9TdHJpbmcob3B0cykgKyAnLycgKyB0aGlzLnByZWZpeExlbmd0aChmb3JtYXQpO1xufTtcblxudmFyIHY0c3VibmV0ID0gbmV3IENJRFIoJzo6ZmZmZjowOjAnLCA5Nik7XG5cbmZ1bmN0aW9uIGlwNmNpZHJDb21wYXJlKGEsIGIpIHtcbiAgYSA9IF90b0NJRFIoYSk7XG4gIGIgPSBfdG9DSURSKGIpO1xuXG4gIC8qXG4gICAqIFdlIGNvbXBhcmUgZmlyc3Qgb24gdGhlIGFkZHJlc3MgY29tcG9uZW50LCBhbmQgdGhlbiBvbiB0aGUgcHJlZml4IGxlbmd0aCxcbiAgICogc3VjaCB0aGF0IHRoZSBuZXR3b3JrIHdpdGggdGhlIHNtYWxsZXIgcHJlZml4IGxlbmd0aCAodGhlIGxhcmdlciBzdWJuZXQpXG4gICAqIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbmV0d29yayB3aXRoIHRoZSBsYXJnZXIgcHJlZml4ICh0aGUgc21hbGxlciBzdWJuZXQpLlxuICAgKiBUaGlzIGlzIHRoZSBzYW1lIG9yZGVyaW5nIHVzZWQgaW4gUG9zdGdyZXMuXG4gICAqL1xuICB2YXIgY21wID0gaXA2YWRkckNvbXBhcmUoYS5fYWRkciwgYi5fYWRkcik7XG4gIHJldHVybiBjbXAgPT09IDAgPyBiLl9wcmVmaXggLSBhLl9wcmVmaXggOiBjbXA7XG59XG5cbi8qKlxuICogUmFuZ2Ugb2YgYWRkcmVzc2VzLlxuICogQHBhcmFtIGJlZ2luIEJlZ2lubmluZyBhZGRyZXNzIG9mIHRoZSByYW5nZVxuICogQHBhcmFtIGVuZCBFbmRpbmcgYWRkcmVzcyBvZiB0aGUgcmFuZ2VcbiAqXG4gKiBQYXJhbWV0ZXJzIGNhbiBiZSBBZGRyIG9iamVjdHMgb3IgcGFyc2FibGUgYWRkcmVzcyBzdHJpbmdzLlxuICovXG5mdW5jdGlvbiBBZGRyUmFuZ2UoYmVnaW4sIGVuZCkge1xuICBiZWdpbiA9IF90b0FkZHIoYmVnaW4pO1xuICBlbmQgPSBfdG9BZGRyKGVuZCk7XG5cbiAgaWYgKGJlZ2luLmNvbXBhcmUoZW5kKSA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JlZ2luIGFkZHJlc3MgbXVzdCBiZSA8PSBlbmQgYWRkcmVzcycpO1xuICB9XG5cbiAgdGhpcy5fYmVnaW4gPSBiZWdpbjtcbiAgdGhpcy5fZW5kID0gZW5kO1xufVxuXG5BZGRyUmFuZ2UucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gYWRkclJhbmdlQ29udGFpbnMoaW5wdXQpIHtcbiAgaW5wdXQgPSBfdG9BZGRyKGlucHV0KTtcbiAgcmV0dXJuICh0aGlzLl9iZWdpbi5jb21wYXJlKGlucHV0KSA8PSAwICYmIHRoaXMuX2VuZC5jb21wYXJlKGlucHV0KSA+PSAwKTtcbn07XG5cbkFkZHJSYW5nZS5wcm90b3R5cGUuZmlyc3QgPSBmdW5jdGlvbiBhZGRyUmFuZ2VGaXJzdCgpIHtcbiAgcmV0dXJuIHRoaXMuX2JlZ2luO1xufTtcblxuQWRkclJhbmdlLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24gYWRkclJhbmdlTGFzdCgpIHtcbiAgcmV0dXJuIHRoaXMuX2VuZDtcbn07XG5cblxuLy8vLS0tIFB1YmxpYyBGdW5jdGlvbnNcblxuZnVuY3Rpb24gaXA2YWRkclBhcnNlKGlucHV0KSB7XG4gIGlmICh0eXBlb2YgKGlucHV0KSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHJpbmcoaW5wdXQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiAoaW5wdXQpID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBwYXJzZUxvbmcoaW5wdXQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiAoaW5wdXQpID09PSAnb2JqZWN0JyAmJiBfaXNBZGRyKGlucHV0KSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQ6IG9ubHkgc3RyaW5nfG51bWJlciBhbGxvd2VkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoaW5wdXQpIHtcbiAgYXNzZXJ0LnN0cmluZyhpbnB1dCk7XG4gIGlucHV0ID0gaW5wdXQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBZGRyKCk7XG5cbiAgdmFyIGlwNkZpZWxkcyA9IFtdOyAvLyBob2xkIHVucGFyc2VkIGhleCBmaWVsZHNcbiAgdmFyIGlwNEZpZWxkcyA9IFtdOyAvLyBob2xkIHVucGFyc2VkIGRlY2ltYWwgZmllbGRzXG4gIHZhciBleHBJbmRleCA9IG51bGw7IC8vIGZpZWxkIGluZGV4IG9mICc6OicgZGVsaW1pdGVyXG4gIHZhciB2YWx1ZSA9ICcnOyAgLy8gYWNjdW11bGF0ZSB1bnBhcnNlZCBoZXgvZGVjIGZpZWxkXG4gIHZhciBpLCBjO1xuXG4gIC8qXG4gICAqIE5vIHZhbGlkIGlwdjYgaXMgbG9uZ2VyIHRoYW4gMzkgY2hhcmFjdGVycy5cbiAgICogQW4gZXh0cmEgY2hhcmFjdGVyIG9mIGxlZXdheSBpcyB0aGVyZSB0byB0b2xlcmF0ZSBzb21lIDo6IGZ1bm55IGJ1c2luZXNzLlxuICAgKi9cbiAgaWYgKGlucHV0Lmxlbmd0aCA+IDQwKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoaW5wdXQsICdJbnB1dCB0b28gbG9uZycpO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IGlucHV0W2ldO1xuICAgIGlmIChjID09PSAnOicpIHtcbiAgICAgIGlmICgoaSsxKSA8IGlucHV0Lmxlbmd0aCAmJiBpbnB1dFtpKzFdID09PSAnOicpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogVmFyaWFibGUgbGVuZ3RoICc6OicgZGVsaW1pdGVyLlxuICAgICAgICAgKiBNdWx0aXBsZXMgd291bGQgYmUgYW1iaWd1b3VzXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZXhwSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihpbnB1dCwgJ011bHRpcGxlIDo6IGRlbGltaXRlcnMnLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSB2YWx1ZSBidWZmZXIgY2FuIGJlIGVtcHR5IGZvciBjYXNlcyB3aGVyZSB0aGUgJzo6JyBkZWxpbWl0ZXIgaXNcbiAgICAgICAgICogdGhlIGZpcnN0IHBvcnRpb24gb2YgdGhlIGFkZHJlc3MuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgaXA2RmllbGRzLnB1c2godmFsdWUpO1xuICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZXhwSW5kZXggPSBpcDZGaWVsZHMubGVuZ3RoO1xuICAgICAgICBpKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKlxuICAgICAgICAgKiBTdGFuZGFyZCAnOicgZGVsaW1pdGVyXG4gICAgICAgICAqIFRoZSB2YWx1ZSBidWZmZXIgY2Fubm90IGJlIGVtcHR5IHNpbmNlIHRoYXQgd291bGQgaW1wbHkgYW4gaWxsZWdhbFxuICAgICAgICAgKiBwYXR0ZXJuIHN1Y2ggYXMgJzo6Oicgb3IgJzouJy5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihpbnB1dCwgJ2lsbGVnYWwgZGVsaW1pdGVyJywgaSk7XG4gICAgICAgIH1cbiAgICAgICAgaXA2RmllbGRzLnB1c2godmFsdWUpO1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYyA9PT0gJy4nKSB7XG4gICAgICAvKlxuICAgICAgICogSGFuZGxlIGRvdHRlZCBxdWFkIG5vdGF0aW9uIGZvciBpcHY0IGFuZCBpcHY0LW1hcHBlZCBhZGRyZXNzZXMuXG4gICAgICAgKi9cbiAgICAgIGlwNEZpZWxkcy5wdXNoKHZhbHVlKTtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgKyBjO1xuICAgIH1cbiAgfVxuICAvKiBIYW5kbGUgdGhlIGxhc3Qgc3Rhc2hlZCB2YWx1ZSAqL1xuICBpZiAodmFsdWUgIT09ICcnKSB7XG4gICAgaWYgKGlwNEZpZWxkcy5sZW5ndGggIT09IDApIHtcbiAgICAgIGlwNEZpZWxkcy5wdXNoKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXA2RmllbGRzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICB2YWx1ZSA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8qIFdpdGggbm8gc3Rhc2hlZCB2YWx1ZSwgdGhlIGFkZHJlc3MgbXVzdCBlbmQgd2l0aCAnOjonLiAqL1xuICAgIGlmIChleHBJbmRleCAhPT0gaXA2RmllbGRzLmxlbmd0aCB8fCBpcDRGaWVsZHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoaW5wdXQsICdDYW5ub3QgZW5kIHdpdGggZGVsaW1pdGVyIGJlc2lkZXMgOjonKTtcbiAgICB9XG4gIH1cblxuICAvKiBXaXRoIHZhbHVlcyBjb2xsZWN0ZWQsIGVuc3VyZSB3ZSBkb24ndCBoYXZlIHRvbyBtYW55L2ZldyAqL1xuICBpZiAoaXA0RmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpcDZGaWVsZHMubGVuZ3RoID4gOCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoaW5wdXQsICdUb28gbWFueSBmaWVsZHMnKTtcbiAgICB9IGVsc2UgaWYgKGlwNkZpZWxkcy5sZW5ndGggPCA4ICYmIGV4cEluZGV4ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihpbnB1dCwgJ1RvbyBmZXcgZmllbGRzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpcDRGaWVsZHMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihpbnB1dCwgJ0lQdjQgcG9ydGlvbiBtdXN0IGhhdmUgNCBmaWVsZHMnKTtcbiAgICB9XG4gICAgLyogSWYgdGhpcyBpcyBhIGJhcmUgSVAgYWRkcmVzcywgaW1wbGljaXRseSBjb252ZXJ0IHRvIElQdjQgbWFwcGVkICovXG4gICAgaWYgKGlwNkZpZWxkcy5sZW5ndGggPT09IDAgJiYgZXhwSW5kZXggPT09IG51bGwpIHtcbiAgICAgIHJlc3VsdC5fYXR0cnMuaXB2NEJhcmUgPSB0cnVlO1xuICAgICAgaXA2RmllbGRzID0gWydmZmZmJ107XG4gICAgICBleHBJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGlwNkZpZWxkcy5sZW5ndGggPiA2KSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihpbnB1dCwgJ1RvbyBtYW55IGZpZWxkcycpO1xuICAgIH0gZWxzZSBpZiAoaXA2RmllbGRzLmxlbmd0aCA8IDYgJiYgZXhwSW5kZXggPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGlucHV0LCAnVG9vIGZldyBmaWVsZHMnKTtcbiAgICB9XG4gIH1cblxuICAvKiBQYXJzZSBpbnRlZ2VyIHZhbHVlcyAqL1xuICB2YXIgZmllbGQsIG51bTtcbiAgZm9yIChpID0gMDsgaSA8IGlwNkZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgIGZpZWxkID0gaXA2RmllbGRzW2ldO1xuICAgIG51bSA9IGpzcHJpbS5wYXJzZUludGVnZXIoZmllbGQsIHsgYmFzZTogMTYsIGFsbG93U2lnbjogZmFsc2UgfSk7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIEVycm9yIHx8IG51bSA8IDAgfHwgbnVtID4gNjU1MzUpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGlucHV0LCAnSW52YWxpZCBmaWVsZCB2YWx1ZTogJyArIGZpZWxkKTtcbiAgICB9XG4gICAgaXA2RmllbGRzW2ldID0gbnVtO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBpcDRGaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICBmaWVsZCA9IGlwNEZpZWxkc1tpXTtcbiAgICBudW0gPSBqc3ByaW0ucGFyc2VJbnRlZ2VyKGZpZWxkLCB7IGJhc2U6IDEwLCBhbGxvd1NpZ246IGZhbHNlIH0pO1xuICAgIGlmIChudW0gaW5zdGFuY2VvZiBFcnJvciB8fCBudW0gPCAwIHx8IG51bSA+IDI1NSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoaW5wdXQsICdJbnZhbGlkIGZpZWxkIHZhbHVlOiAnICsgZmllbGQpO1xuICAgIH1cbiAgICBpcDRGaWVsZHNbaV0gPSBudW07XG4gIH1cblxuICAvKiBDb2xsYXBzZSBJUHY0IHBvcnRpb24sIGlmIG5lY2Vzc2FyeSAqL1xuICBpZiAoaXA0RmllbGRzLmxlbmd0aCAhPT0gMCkge1xuICAgIGlwNkZpZWxkcy5wdXNoKChpcDRGaWVsZHNbMF0qMjU2KSArIGlwNEZpZWxkc1sxXSk7XG4gICAgaXA2RmllbGRzLnB1c2goKGlwNEZpZWxkc1syXSoyNTYpICsgaXA0RmllbGRzWzNdKTtcbiAgfVxuXG4gIC8qIEV4cGFuZCAnOjonIGRlbGltaXRlciBpbnRvIGltcGxpZWQgMHMgKi9cbiAgaWYgKGlwNkZpZWxkcy5sZW5ndGggPCA4ICYmIGV4cEluZGV4ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpbGxlciA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCAoOCAtIGlwNkZpZWxkcy5sZW5ndGgpOyBpKyspIHtcbiAgICAgIGZpbGxlci5wdXNoKDApO1xuICAgIH1cbiAgICBpcDZGaWVsZHMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0KFxuICAgICAgaXA2RmllbGRzLnNsaWNlKDAsIGV4cEluZGV4KSxcbiAgICAgIGZpbGxlcixcbiAgICAgIGlwNkZpZWxkcy5zbGljZShleHBJbmRleClcbiAgICApO1xuICB9XG5cbiAgLypcbiAgICogSWYgZG90dGVkLXF1YWQgbm90YXRpb24gd2FzIHVzZWQsIGVuc3VyZSB0aGUgaW5wdXQgd2FzIGVpdGhlciBhIGJhcmUgaXB2NFxuICAgKiBhZGRyZXNzIG9yIGEgdmFsaWQgaXB2NC1tYXBwZWQgYWRkcmVzcy5cbiAgICovXG4gIGlmIChpcDRGaWVsZHMubGVuZ3RoICE9PSAwKSB7XG4gICAgaWYgKCFfaXB2NE1hcHBlZChpcDZGaWVsZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihpbnB1dCwgJ2ludmFsaWQgZG90dGVkLXF1YWQgbm90YXRpb24nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0Ll9hdHRycy5pcHY0TWFwcGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXN1bHQuX2ZpZWxkcyA9IGlwNkZpZWxkcztcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUxvbmcoaW5wdXQpIHtcbiAgYXNzZXJ0Lm51bWJlcihpbnB1dCk7XG4gIGlmIChpbnB1dCAhPT0gTWF0aC5mbG9vcihpbnB1dCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIG11c3QgYmUgaW50ZWdlcicpO1xuICB9XG4gIGlmIChpbnB1dCA8IDAgfHwgaW5wdXQgPiAweGZmZmZmZmZmKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBtdXN0IGJlIDMyIGJpdCcpO1xuICB9XG4gIHZhciBvdXQgPSBuZXcgQWRkcigpO1xuICBvdXQuX2ZpZWxkc1s3XSA9IGlucHV0ICYgMHhmZmZmO1xuICBvdXQuX2ZpZWxkc1s2XSA9IChpbnB1dCA+Pj4gMTYpO1xuICAvKiB0aGlzIGlzIGlwdjQtbWFwcGVkICovXG4gIG91dC5fZmllbGRzWzVdID0gMHhmZmZmO1xuICBvdXQuX2F0dHJzLmlwdjRCYXJlID0gdHJ1ZTtcbiAgb3V0Ll9hdHRycy5pcHY0TWFwcGVkID0gdHJ1ZTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb21wYXJlIEFkZHIgb2JqZWN0cyBpbiBhIG1hbm5lciBzdWl0YWJsZSBmb3IgQXJyYXkuc29ydCgpLlxuICovXG5mdW5jdGlvbiBpcDZhZGRyQ29tcGFyZShhLCBiKSB7XG4gIGEgPSBfdG9BZGRyKGEpO1xuICBiID0gX3RvQWRkcihiKTtcblxuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIGlmIChhLl9maWVsZHNbaV0gPCBiLl9maWVsZHNbaV0pIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKGEuX2ZpZWxkc1tpXSA+IGIuX2ZpZWxkc1tpXSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5cbi8vLy0tLSBFeHBvcnRzXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZTogaXA2YWRkclBhcnNlLFxuICBjb21wYXJlOiBpcDZhZGRyQ29tcGFyZSxcbiAgY3JlYXRlQ0lEUjogZnVuY3Rpb24gKGFkZHIsIGxlbikge1xuICAgIHJldHVybiBuZXcgQ0lEUihhZGRyLCBsZW4pO1xuICB9LFxuICBjb21wYXJlQ0lEUjogaXA2Y2lkckNvbXBhcmUsXG4gIGNyZWF0ZUFkZHJSYW5nZTogZnVuY3Rpb24gKGJlZ2luLCBlbmQpIHtcbiAgICByZXR1cm4gbmV3IEFkZHJSYW5nZShiZWdpbiwgZW5kKTtcbiAgfVxufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyoqXHJcbiAqIEpTT05TY2hlbWEgVmFsaWRhdG9yIC0gVmFsaWRhdGVzIEphdmFTY3JpcHQgb2JqZWN0cyB1c2luZyBKU09OIFNjaGVtYXNcclxuICpcdChodHRwOi8vd3d3Lmpzb24uY29tL2pzb24tc2NoZW1hLXByb3Bvc2FsLylcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDA3IEtyaXMgWnlwIFNpdGVQZW4gKHd3dy5zaXRlcGVuLmNvbSlcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCAoTUlULUxJQ0VOU0UudHh0KSBsaWNlbnNlLlxyXG5UbyB1c2UgdGhlIHZhbGlkYXRvciBjYWxsIHRoZSB2YWxpZGF0ZSBmdW5jdGlvbiB3aXRoIGFuIGluc3RhbmNlIG9iamVjdCBhbmQgYW4gb3B0aW9uYWwgc2NoZW1hIG9iamVjdC5cclxuSWYgYSBzY2hlbWEgaXMgcHJvdmlkZWQsIGl0IHdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZS4gSWYgdGhlIGluc3RhbmNlIG9iamVjdCByZWZlcnMgdG8gYSBzY2hlbWEgKHNlbGYtdmFsaWRhdGluZyksXHJcbnRoYXQgc2NoZW1hIHdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBhbmQgdGhlIHNjaGVtYSBwYXJhbWV0ZXIgaXMgbm90IG5lY2Vzc2FyeSAoaWYgYm90aCBleGlzdCxcclxuYm90aCB2YWxpZGF0aW9ucyB3aWxsIG9jY3VyKS5cclxuVGhlIHZhbGlkYXRlIG1ldGhvZCB3aWxsIHJldHVybiBhbiBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9ycy4gSWYgdGhlcmUgYXJlIG5vIGVycm9ycywgdGhlbiBhblxyXG5lbXB0eSBsaXN0IHdpbGwgYmUgcmV0dXJuZWQuIEEgdmFsaWRhdGlvbiBlcnJvciB3aWxsIGhhdmUgdHdvIHByb3BlcnRpZXM6XHJcblwicHJvcGVydHlcIiB3aGljaCBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydHkgaGFkIHRoZSBlcnJvclxyXG5cIm1lc3NhZ2VcIiB3aGljaCBpbmRpY2F0ZXMgd2hhdCB0aGUgZXJyb3Igd2FzXHJcbiAqL1xyXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXHJcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XHJcbiAgICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXHJcbiAgICAgICAgLy8gbGlrZSBOb2RlLlxyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcclxuICAgICAgICByb290Lmpzb25TY2hlbWEgPSBmYWN0b3J5KCk7XHJcbiAgICB9XHJcbn0odGhpcywgZnVuY3Rpb24gKCkgey8vIHNldHVwIHByaW1pdGl2ZSBjbGFzc2VzIHRvIGJlIEpTT04gU2NoZW1hIHR5cGVzXHJcbnZhciBleHBvcnRzID0gdmFsaWRhdGVcclxuZXhwb3J0cy5JbnRlZ2VyID0ge3R5cGU6XCJpbnRlZ2VyXCJ9O1xyXG52YXIgcHJpbWl0aXZlQ29uc3RydWN0b3JzID0ge1xyXG5cdFN0cmluZzogU3RyaW5nLFxyXG5cdEJvb2xlYW46IEJvb2xlYW4sXHJcblx0TnVtYmVyOiBOdW1iZXIsXHJcblx0T2JqZWN0OiBPYmplY3QsXHJcblx0QXJyYXk6IEFycmF5LFxyXG5cdERhdGU6IERhdGVcclxufVxyXG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XHJcbmZ1bmN0aW9uIHZhbGlkYXRlKC8qQW55Ki9pbnN0YW5jZSwvKk9iamVjdCovc2NoZW1hKSB7XHJcblx0XHQvLyBTdW1tYXJ5OlxyXG5cdFx0Ly8gIFx0VG8gdXNlIHRoZSB2YWxpZGF0b3IgY2FsbCBKU09OU2NoZW1hLnZhbGlkYXRlIHdpdGggYW4gaW5zdGFuY2Ugb2JqZWN0IGFuZCBhbiBvcHRpb25hbCBzY2hlbWEgb2JqZWN0LlxyXG5cdFx0Ly8gXHRcdElmIGEgc2NoZW1hIGlzIHByb3ZpZGVkLCBpdCB3aWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUuIElmIHRoZSBpbnN0YW5jZSBvYmplY3QgcmVmZXJzIHRvIGEgc2NoZW1hIChzZWxmLXZhbGlkYXRpbmcpLFxyXG5cdFx0Ly8gXHRcdHRoYXQgc2NoZW1hIHdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBhbmQgdGhlIHNjaGVtYSBwYXJhbWV0ZXIgaXMgbm90IG5lY2Vzc2FyeSAoaWYgYm90aCBleGlzdCxcclxuXHRcdC8vIFx0XHRib3RoIHZhbGlkYXRpb25zIHdpbGwgb2NjdXIpLlxyXG5cdFx0Ly8gXHRcdFRoZSB2YWxpZGF0ZSBtZXRob2Qgd2lsbCByZXR1cm4gYW4gb2JqZWN0IHdpdGggdHdvIHByb3BlcnRpZXM6XHJcblx0XHQvLyBcdFx0XHR2YWxpZDogQSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGluc3RhbmNlIGlzIHZhbGlkIGJ5IHRoZSBzY2hlbWFcclxuXHRcdC8vIFx0XHRcdGVycm9yczogQW4gYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnMuIElmIHRoZXJlIGFyZSBubyBlcnJvcnMsIHRoZW4gYW5cclxuXHRcdC8vIFx0XHRcdFx0XHRlbXB0eSBsaXN0IHdpbGwgYmUgcmV0dXJuZWQuIEEgdmFsaWRhdGlvbiBlcnJvciB3aWxsIGhhdmUgdHdvIHByb3BlcnRpZXM6XHJcblx0XHQvLyBcdFx0XHRcdFx0XHRwcm9wZXJ0eTogd2hpY2ggaW5kaWNhdGVzIHdoaWNoIHByb3BlcnR5IGhhZCB0aGUgZXJyb3JcclxuXHRcdC8vIFx0XHRcdFx0XHRcdG1lc3NhZ2U6IHdoaWNoIGluZGljYXRlcyB3aGF0IHRoZSBlcnJvciB3YXNcclxuXHRcdC8vXHJcblx0XHRyZXR1cm4gdmFsaWRhdGUoaW5zdGFuY2UsIHNjaGVtYSwge2NoYW5naW5nOiBmYWxzZX0pOy8vLCBjb2VyY2U6IGZhbHNlLCBleGlzdGluZ09ubHk6IGZhbHNlfSk7XHJcblx0fTtcclxuZXhwb3J0cy5jaGVja1Byb3BlcnR5Q2hhbmdlID0gZnVuY3Rpb24oLypBbnkqL3ZhbHVlLC8qT2JqZWN0Ki9zY2hlbWEsIC8qU3RyaW5nKi9wcm9wZXJ0eSkge1xyXG5cdFx0Ly8gU3VtbWFyeTpcclxuXHRcdC8vIFx0XHRUaGUgY2hlY2tQcm9wZXJ0eUNoYW5nZSBtZXRob2Qgd2lsbCBjaGVjayB0byBzZWUgaWYgYW4gdmFsdWUgY2FuIGxlZ2FsbHkgYmUgaW4gcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gc2NoZW1hXHJcblx0XHQvLyBcdFx0VGhpcyBpcyBzbGlnaHRseSBkaWZmZXJlbnQgdGhhbiB0aGUgdmFsaWRhdGUgbWV0aG9kIGluIHRoYXQgaXQgd2lsbCBmYWlsIGlmIHRoZSBzY2hlbWEgaXMgcmVhZG9ubHkgYW5kIGl0IHdpbGxcclxuXHRcdC8vIFx0XHRub3QgY2hlY2sgZm9yIHNlbGYtdmFsaWRhdGlvbiwgaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBwYXNzZWQgaW4gdmFsdWUgaXMgYWxyZWFkeSBpbnRlcm5hbGx5IHZhbGlkLlxyXG5cdFx0Ly8gXHRcdFRoZSBjaGVja1Byb3BlcnR5Q2hhbmdlIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZSBvYmplY3QgdHlwZSBhcyB2YWxpZGF0ZSwgc2VlIEpTT05TY2hlbWEudmFsaWRhdGUgZm9yXHJcblx0XHQvLyBcdFx0aW5mb3JtYXRpb24uXHJcblx0XHQvL1xyXG5cdFx0cmV0dXJuIHZhbGlkYXRlKHZhbHVlLCBzY2hlbWEsIHtjaGFuZ2luZzogcHJvcGVydHkgfHwgXCJwcm9wZXJ0eVwifSk7XHJcblx0fTtcclxudmFyIHZhbGlkYXRlID0gZXhwb3J0cy5fdmFsaWRhdGUgPSBmdW5jdGlvbigvKkFueSovaW5zdGFuY2UsLypPYmplY3QqL3NjaGVtYSwvKk9iamVjdCovb3B0aW9ucykge1xyXG5cclxuXHRpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcclxuXHR2YXIgX2NoYW5naW5nID0gb3B0aW9ucy5jaGFuZ2luZztcclxuXHJcblx0ZnVuY3Rpb24gZ2V0VHlwZShzY2hlbWEpe1xyXG5cdFx0cmV0dXJuIHNjaGVtYS50eXBlIHx8IChwcmltaXRpdmVDb25zdHJ1Y3RvcnNbc2NoZW1hLm5hbWVdID09IHNjaGVtYSAmJiBzY2hlbWEubmFtZS50b0xvd2VyQ2FzZSgpKTtcclxuXHR9XHJcblx0dmFyIGVycm9ycyA9IFtdO1xyXG5cdC8vIHZhbGlkYXRlIGEgdmFsdWUgYWdhaW5zdCBhIHByb3BlcnR5IGRlZmluaXRpb25cclxuXHRmdW5jdGlvbiBjaGVja1Byb3AodmFsdWUsIHNjaGVtYSwgcGF0aCxpKXtcclxuXHJcblx0XHR2YXIgbDtcclxuXHRcdHBhdGggKz0gcGF0aCA/IHR5cGVvZiBpID09ICdudW1iZXInID8gJ1snICsgaSArICddJyA6IHR5cGVvZiBpID09ICd1bmRlZmluZWQnID8gJycgOiAnLicgKyBpIDogaTtcclxuXHRcdGZ1bmN0aW9uIGFkZEVycm9yKG1lc3NhZ2Upe1xyXG5cdFx0XHRlcnJvcnMucHVzaCh7cHJvcGVydHk6cGF0aCxtZXNzYWdlOm1lc3NhZ2V9KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZigodHlwZW9mIHNjaGVtYSAhPSAnb2JqZWN0JyB8fCBzY2hlbWEgaW5zdGFuY2VvZiBBcnJheSkgJiYgKHBhdGggfHwgdHlwZW9mIHNjaGVtYSAhPSAnZnVuY3Rpb24nKSAmJiAhKHNjaGVtYSAmJiBnZXRUeXBlKHNjaGVtYSkpKXtcclxuXHRcdFx0aWYodHlwZW9mIHNjaGVtYSA9PSAnZnVuY3Rpb24nKXtcclxuXHRcdFx0XHRpZighKHZhbHVlIGluc3RhbmNlb2Ygc2NoZW1hKSl7XHJcblx0XHRcdFx0XHRhZGRFcnJvcihcImlzIG5vdCBhbiBpbnN0YW5jZSBvZiB0aGUgY2xhc3MvY29uc3RydWN0b3IgXCIgKyBzY2hlbWEubmFtZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9ZWxzZSBpZihzY2hlbWEpe1xyXG5cdFx0XHRcdGFkZEVycm9yKFwiSW52YWxpZCBzY2hlbWEvcHJvcGVydHkgZGVmaW5pdGlvbiBcIiArIHNjaGVtYSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblx0XHRpZihfY2hhbmdpbmcgJiYgc2NoZW1hLnJlYWRvbmx5KXtcclxuXHRcdFx0YWRkRXJyb3IoXCJpcyBhIHJlYWRvbmx5IGZpZWxkLCBpdCBjYW4gbm90IGJlIGNoYW5nZWRcIik7XHJcblx0XHR9XHJcblx0XHRpZihzY2hlbWFbJ2V4dGVuZHMnXSl7IC8vIGlmIGl0IGV4dGVuZHMgYW5vdGhlciBzY2hlbWEsIGl0IG11c3QgcGFzcyB0aGF0IHNjaGVtYSBhcyB3ZWxsXHJcblx0XHRcdGNoZWNrUHJvcCh2YWx1ZSxzY2hlbWFbJ2V4dGVuZHMnXSxwYXRoLGkpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gdmFsaWRhdGUgYSB2YWx1ZSBhZ2FpbnN0IGEgdHlwZSBkZWZpbml0aW9uXHJcblx0XHRmdW5jdGlvbiBjaGVja1R5cGUodHlwZSx2YWx1ZSl7XHJcblx0XHRcdGlmKHR5cGUpe1xyXG5cdFx0XHRcdGlmKHR5cGVvZiB0eXBlID09ICdzdHJpbmcnICYmIHR5cGUgIT0gJ2FueScgJiZcclxuXHRcdFx0XHRcdFx0KHR5cGUgPT0gJ251bGwnID8gdmFsdWUgIT09IG51bGwgOiB0eXBlb2YgdmFsdWUgIT0gdHlwZSkgJiZcclxuXHRcdFx0XHRcdFx0ISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ICYmIHR5cGUgPT0gJ2FycmF5JykgJiZcclxuXHRcdFx0XHRcdFx0ISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgdHlwZSA9PSAnZGF0ZScpICYmXHJcblx0XHRcdFx0XHRcdCEodHlwZSA9PSAnaW50ZWdlcicgJiYgdmFsdWUlMT09PTApKXtcclxuXHRcdFx0XHRcdHJldHVybiBbe3Byb3BlcnR5OnBhdGgsbWVzc2FnZToodHlwZW9mIHZhbHVlKSArIFwiIHZhbHVlIGZvdW5kLCBidXQgYSBcIiArIHR5cGUgKyBcIiBpcyByZXF1aXJlZFwifV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHR5cGUgaW5zdGFuY2VvZiBBcnJheSl7XHJcblx0XHRcdFx0XHR2YXIgdW5pb25FcnJvcnM9W107XHJcblx0XHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgdHlwZS5sZW5ndGg7IGorKyl7IC8vIGEgdW5pb24gdHlwZVxyXG5cdFx0XHRcdFx0XHRpZighKHVuaW9uRXJyb3JzPWNoZWNrVHlwZSh0eXBlW2pdLHZhbHVlKSkubGVuZ3RoKXtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYodW5pb25FcnJvcnMubGVuZ3RoKXtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHVuaW9uRXJyb3JzO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1lbHNlIGlmKHR5cGVvZiB0eXBlID09ICdvYmplY3QnKXtcclxuXHRcdFx0XHRcdHZhciBwcmlvckVycm9ycyA9IGVycm9ycztcclxuXHRcdFx0XHRcdGVycm9ycyA9IFtdO1xyXG5cdFx0XHRcdFx0Y2hlY2tQcm9wKHZhbHVlLHR5cGUscGF0aCk7XHJcblx0XHRcdFx0XHR2YXIgdGhlc2VFcnJvcnMgPSBlcnJvcnM7XHJcblx0XHRcdFx0XHRlcnJvcnMgPSBwcmlvckVycm9ycztcclxuXHRcdFx0XHRcdHJldHVybiB0aGVzZUVycm9ycztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0fVxyXG5cdFx0aWYodmFsdWUgPT09IHVuZGVmaW5lZCl7XHJcblx0XHRcdGlmKHNjaGVtYS5yZXF1aXJlZCl7XHJcblx0XHRcdFx0YWRkRXJyb3IoXCJpcyBtaXNzaW5nIGFuZCBpdCBpcyByZXF1aXJlZFwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fWVsc2V7XHJcblx0XHRcdGVycm9ycyA9IGVycm9ycy5jb25jYXQoY2hlY2tUeXBlKGdldFR5cGUoc2NoZW1hKSx2YWx1ZSkpO1xyXG5cdFx0XHRpZihzY2hlbWEuZGlzYWxsb3cgJiYgIWNoZWNrVHlwZShzY2hlbWEuZGlzYWxsb3csdmFsdWUpLmxlbmd0aCl7XHJcblx0XHRcdFx0YWRkRXJyb3IoXCIgZGlzYWxsb3dlZCB2YWx1ZSB3YXMgbWF0Y2hlZFwiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZih2YWx1ZSAhPT0gbnVsbCl7XHJcblx0XHRcdFx0aWYodmFsdWUgaW5zdGFuY2VvZiBBcnJheSl7XHJcblx0XHRcdFx0XHRpZihzY2hlbWEuaXRlbXMpe1xyXG5cdFx0XHRcdFx0XHR2YXIgaXRlbXNJc0FycmF5ID0gc2NoZW1hLml0ZW1zIGluc3RhbmNlb2YgQXJyYXk7XHJcblx0XHRcdFx0XHRcdHZhciBwcm9wRGVmID0gc2NoZW1hLml0ZW1zO1xyXG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSArPSAxKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGl0ZW1zSXNBcnJheSlcclxuXHRcdFx0XHRcdFx0XHRcdHByb3BEZWYgPSBzY2hlbWEuaXRlbXNbaV07XHJcblx0XHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMuY29lcmNlKVxyXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWVbaV0gPSBvcHRpb25zLmNvZXJjZSh2YWx1ZVtpXSwgcHJvcERlZik7XHJcblx0XHRcdFx0XHRcdFx0ZXJyb3JzLmNvbmNhdChjaGVja1Byb3AodmFsdWVbaV0scHJvcERlZixwYXRoLGkpKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYoc2NoZW1hLm1pbkl0ZW1zICYmIHZhbHVlLmxlbmd0aCA8IHNjaGVtYS5taW5JdGVtcyl7XHJcblx0XHRcdFx0XHRcdGFkZEVycm9yKFwiVGhlcmUgbXVzdCBiZSBhIG1pbmltdW0gb2YgXCIgKyBzY2hlbWEubWluSXRlbXMgKyBcIiBpbiB0aGUgYXJyYXlcIik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihzY2hlbWEubWF4SXRlbXMgJiYgdmFsdWUubGVuZ3RoID4gc2NoZW1hLm1heEl0ZW1zKXtcclxuXHRcdFx0XHRcdFx0YWRkRXJyb3IoXCJUaGVyZSBtdXN0IGJlIGEgbWF4aW11bSBvZiBcIiArIHNjaGVtYS5tYXhJdGVtcyArIFwiIGluIHRoZSBhcnJheVwiKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9ZWxzZSBpZihzY2hlbWEucHJvcGVydGllcyB8fCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpe1xyXG5cdFx0XHRcdFx0ZXJyb3JzLmNvbmNhdChjaGVja09iaih2YWx1ZSwgc2NoZW1hLnByb3BlcnRpZXMsIHBhdGgsIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihzY2hlbWEucGF0dGVybiAmJiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgJiYgIXZhbHVlLm1hdGNoKHNjaGVtYS5wYXR0ZXJuKSl7XHJcblx0XHRcdFx0XHRhZGRFcnJvcihcImRvZXMgbm90IG1hdGNoIHRoZSByZWdleCBwYXR0ZXJuIFwiICsgc2NoZW1hLnBhdHRlcm4pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihzY2hlbWEubWF4TGVuZ3RoICYmIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyAmJiB2YWx1ZS5sZW5ndGggPiBzY2hlbWEubWF4TGVuZ3RoKXtcclxuXHRcdFx0XHRcdGFkZEVycm9yKFwibWF5IG9ubHkgYmUgXCIgKyBzY2hlbWEubWF4TGVuZ3RoICsgXCIgY2hhcmFjdGVycyBsb25nXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihzY2hlbWEubWluTGVuZ3RoICYmIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyAmJiB2YWx1ZS5sZW5ndGggPCBzY2hlbWEubWluTGVuZ3RoKXtcclxuXHRcdFx0XHRcdGFkZEVycm9yKFwibXVzdCBiZSBhdCBsZWFzdCBcIiArIHNjaGVtYS5taW5MZW5ndGggKyBcIiBjaGFyYWN0ZXJzIGxvbmdcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHR5cGVvZiBzY2hlbWEubWluaW11bSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PSB0eXBlb2Ygc2NoZW1hLm1pbmltdW0gJiZcclxuXHRcdFx0XHRcdFx0c2NoZW1hLm1pbmltdW0gPiB2YWx1ZSl7XHJcblx0XHRcdFx0XHRhZGRFcnJvcihcIm11c3QgaGF2ZSBhIG1pbmltdW0gdmFsdWUgb2YgXCIgKyBzY2hlbWEubWluaW11bSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHR5cGVvZiBzY2hlbWEubWF4aW11bSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PSB0eXBlb2Ygc2NoZW1hLm1heGltdW0gJiZcclxuXHRcdFx0XHRcdFx0c2NoZW1hLm1heGltdW0gPCB2YWx1ZSl7XHJcblx0XHRcdFx0XHRhZGRFcnJvcihcIm11c3QgaGF2ZSBhIG1heGltdW0gdmFsdWUgb2YgXCIgKyBzY2hlbWEubWF4aW11bSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHNjaGVtYVsnZW51bSddKXtcclxuXHRcdFx0XHRcdHZhciBlbnVtZXIgPSBzY2hlbWFbJ2VudW0nXTtcclxuXHRcdFx0XHRcdGwgPSBlbnVtZXIubGVuZ3RoO1xyXG5cdFx0XHRcdFx0dmFyIGZvdW5kO1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGw7IGorKyl7XHJcblx0XHRcdFx0XHRcdGlmKGVudW1lcltqXT09PXZhbHVlKXtcclxuXHRcdFx0XHRcdFx0XHRmb3VuZD0xO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZighZm91bmQpe1xyXG5cdFx0XHRcdFx0XHRhZGRFcnJvcihcImRvZXMgbm90IGhhdmUgYSB2YWx1ZSBpbiB0aGUgZW51bWVyYXRpb24gXCIgKyBlbnVtZXIuam9pbihcIiwgXCIpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYodHlwZW9mIHNjaGVtYS5tYXhEZWNpbWFsID09ICdudW1iZXInICYmXHJcblx0XHRcdFx0XHQodmFsdWUudG9TdHJpbmcoKS5tYXRjaChuZXcgUmVnRXhwKFwiXFxcXC5bMC05XXtcIiArIChzY2hlbWEubWF4RGVjaW1hbCArIDEpICsgXCIsfVwiKSkpKXtcclxuXHRcdFx0XHRcdGFkZEVycm9yKFwibWF5IG9ubHkgaGF2ZSBcIiArIHNjaGVtYS5tYXhEZWNpbWFsICsgXCIgZGlnaXRzIG9mIGRlY2ltYWwgcGxhY2VzXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdC8vIHZhbGlkYXRlIGFuIG9iamVjdCBhZ2FpbnN0IGEgc2NoZW1hXHJcblx0ZnVuY3Rpb24gY2hlY2tPYmooaW5zdGFuY2Usb2JqVHlwZURlZixwYXRoLGFkZGl0aW9uYWxQcm9wKXtcclxuXHJcblx0XHRpZih0eXBlb2Ygb2JqVHlwZURlZiA9PSdvYmplY3QnKXtcclxuXHRcdFx0aWYodHlwZW9mIGluc3RhbmNlICE9ICdvYmplY3QnIHx8IGluc3RhbmNlIGluc3RhbmNlb2YgQXJyYXkpe1xyXG5cdFx0XHRcdGVycm9ycy5wdXNoKHtwcm9wZXJ0eTpwYXRoLG1lc3NhZ2U6XCJhbiBvYmplY3QgaXMgcmVxdWlyZWRcIn0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRmb3IodmFyIGkgaW4gb2JqVHlwZURlZil7IFxyXG5cdFx0XHRcdGlmKG9ialR5cGVEZWYuaGFzT3duUHJvcGVydHkoaSkpe1xyXG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gaW5zdGFuY2VbaV07XHJcblx0XHRcdFx0XHQvLyBza2lwIF9ub3RfIHNwZWNpZmllZCBwcm9wZXJ0aWVzXHJcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmV4aXN0aW5nT25seSkgY29udGludWU7XHJcblx0XHRcdFx0XHR2YXIgcHJvcERlZiA9IG9ialR5cGVEZWZbaV07XHJcblx0XHRcdFx0XHQvLyBzZXQgZGVmYXVsdFxyXG5cdFx0XHRcdFx0aWYodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBwcm9wRGVmW1wiZGVmYXVsdFwiXSl7XHJcblx0XHRcdFx0XHRcdHZhbHVlID0gaW5zdGFuY2VbaV0gPSBwcm9wRGVmW1wiZGVmYXVsdFwiXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKG9wdGlvbnMuY29lcmNlICYmIGkgaW4gaW5zdGFuY2Upe1xyXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGluc3RhbmNlW2ldID0gb3B0aW9ucy5jb2VyY2UodmFsdWUsIHByb3BEZWYpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y2hlY2tQcm9wKHZhbHVlLHByb3BEZWYscGF0aCxpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZvcihpIGluIGluc3RhbmNlKXtcclxuXHRcdFx0aWYoaW5zdGFuY2UuaGFzT3duUHJvcGVydHkoaSkgJiYgIShpLmNoYXJBdCgwKSA9PSAnXycgJiYgaS5jaGFyQXQoMSkgPT0gJ18nKSAmJiBvYmpUeXBlRGVmICYmICFvYmpUeXBlRGVmW2ldICYmIGFkZGl0aW9uYWxQcm9wPT09ZmFsc2Upe1xyXG5cdFx0XHRcdGlmIChvcHRpb25zLmZpbHRlcikge1xyXG5cdFx0XHRcdFx0ZGVsZXRlIGluc3RhbmNlW2ldO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGVycm9ycy5wdXNoKHtwcm9wZXJ0eTpwYXRoLG1lc3NhZ2U6KHR5cGVvZiB2YWx1ZSkgKyBcIlRoZSBwcm9wZXJ0eSBcIiArIGkgK1xyXG5cdFx0XHRcdFx0XHRcIiBpcyBub3QgZGVmaW5lZCBpbiB0aGUgc2NoZW1hIGFuZCB0aGUgc2NoZW1hIGRvZXMgbm90IGFsbG93IGFkZGl0aW9uYWwgcHJvcGVydGllc1wifSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHZhciByZXF1aXJlcyA9IG9ialR5cGVEZWYgJiYgb2JqVHlwZURlZltpXSAmJiBvYmpUeXBlRGVmW2ldLnJlcXVpcmVzO1xyXG5cdFx0XHRpZihyZXF1aXJlcyAmJiAhKHJlcXVpcmVzIGluIGluc3RhbmNlKSl7XHJcblx0XHRcdFx0ZXJyb3JzLnB1c2goe3Byb3BlcnR5OnBhdGgsbWVzc2FnZTpcInRoZSBwcmVzZW5jZSBvZiB0aGUgcHJvcGVydHkgXCIgKyBpICsgXCIgcmVxdWlyZXMgdGhhdCBcIiArIHJlcXVpcmVzICsgXCIgYWxzbyBiZSBwcmVzZW50XCJ9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YWx1ZSA9IGluc3RhbmNlW2ldO1xyXG5cdFx0XHRpZihhZGRpdGlvbmFsUHJvcCAmJiAoIShvYmpUeXBlRGVmICYmIHR5cGVvZiBvYmpUeXBlRGVmID09ICdvYmplY3QnKSB8fCAhKGkgaW4gb2JqVHlwZURlZikpKXtcclxuXHRcdFx0XHRpZihvcHRpb25zLmNvZXJjZSl7XHJcblx0XHRcdFx0XHR2YWx1ZSA9IGluc3RhbmNlW2ldID0gb3B0aW9ucy5jb2VyY2UodmFsdWUsIGFkZGl0aW9uYWxQcm9wKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2hlY2tQcm9wKHZhbHVlLGFkZGl0aW9uYWxQcm9wLHBhdGgsaSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIV9jaGFuZ2luZyAmJiB2YWx1ZSAmJiB2YWx1ZS4kc2NoZW1hKXtcclxuXHRcdFx0XHRlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGNoZWNrUHJvcCh2YWx1ZSx2YWx1ZS4kc2NoZW1hLHBhdGgsaSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXJyb3JzO1xyXG5cdH1cclxuXHRpZihzY2hlbWEpe1xyXG5cdFx0Y2hlY2tQcm9wKGluc3RhbmNlLHNjaGVtYSwnJyxfY2hhbmdpbmcgfHwgJycpO1xyXG5cdH1cclxuXHRpZighX2NoYW5naW5nICYmIGluc3RhbmNlICYmIGluc3RhbmNlLiRzY2hlbWEpe1xyXG5cdFx0Y2hlY2tQcm9wKGluc3RhbmNlLGluc3RhbmNlLiRzY2hlbWEsJycsJycpO1xyXG5cdH1cclxuXHRyZXR1cm4ge3ZhbGlkOiFlcnJvcnMubGVuZ3RoLGVycm9yczplcnJvcnN9O1xyXG59O1xyXG5leHBvcnRzLm11c3RCZVZhbGlkID0gZnVuY3Rpb24ocmVzdWx0KXtcclxuXHQvL1x0c3VtbWFyeTpcclxuXHQvL1x0XHRUaGlzIGNoZWNrcyB0byBlbnN1cmUgdGhhdCB0aGUgcmVzdWx0IGlzIHZhbGlkIGFuZCB3aWxsIHRocm93IGFuIGFwcHJvcHJpYXRlIGVycm9yIG1lc3NhZ2UgaWYgaXQgaXMgbm90XHJcblx0Ly8gcmVzdWx0OiB0aGUgcmVzdWx0IHJldHVybmVkIGZyb20gY2hlY2tQcm9wZXJ0eUNoYW5nZSBvciB2YWxpZGF0ZVxyXG5cdGlmKCFyZXN1bHQudmFsaWQpe1xyXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihyZXN1bHQuZXJyb3JzLm1hcChmdW5jdGlvbihlcnJvcil7cmV0dXJuIFwiZm9yIHByb3BlcnR5IFwiICsgZXJyb3IucHJvcGVydHkgKyAnOiAnICsgZXJyb3IubWVzc2FnZTt9KS5qb2luKFwiLCBcXG5cIikpO1xyXG5cdH1cclxufVxyXG5cclxucmV0dXJuIGV4cG9ydHM7XHJcbn0pKTtcclxuIiwiLypcbiAqIGxpYi9qc3ByaW0uanM6IHV0aWxpdGllcyBmb3IgcHJpbWl0aXZlIEphdmFTY3JpcHQgdHlwZXNcbiAqL1xuXG52YXIgbW9kX2Fzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgbW9kX3V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBtb2RfZXh0c3ByaW50ZiA9IHJlcXVpcmUoJ2V4dHNwcmludGYnKTtcbnZhciBtb2RfdmVycm9yID0gcmVxdWlyZSgndmVycm9yJyk7XG52YXIgbW9kX2pzb25zY2hlbWEgPSByZXF1aXJlKCdqc29uLXNjaGVtYScpO1xuXG4vKlxuICogUHVibGljIGludGVyZmFjZVxuICovXG5leHBvcnRzLmRlZXBDb3B5ID0gZGVlcENvcHk7XG5leHBvcnRzLmRlZXBFcXVhbCA9IGRlZXBFcXVhbDtcbmV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XG5leHBvcnRzLmhhc0tleSA9IGhhc0tleTtcbmV4cG9ydHMuZm9yRWFjaEtleSA9IGZvckVhY2hLZXk7XG5leHBvcnRzLnBsdWNrID0gcGx1Y2s7XG5leHBvcnRzLmZsYXR0ZW5PYmplY3QgPSBmbGF0dGVuT2JqZWN0O1xuZXhwb3J0cy5mbGF0dGVuSXRlciA9IGZsYXR0ZW5JdGVyO1xuZXhwb3J0cy52YWxpZGF0ZUpzb25PYmplY3QgPSB2YWxpZGF0ZUpzb25PYmplY3RKUztcbmV4cG9ydHMudmFsaWRhdGVKc29uT2JqZWN0SlMgPSB2YWxpZGF0ZUpzb25PYmplY3RKUztcbmV4cG9ydHMucmFuZEVsdCA9IHJhbmRFbHQ7XG5leHBvcnRzLmV4dHJhUHJvcGVydGllcyA9IGV4dHJhUHJvcGVydGllcztcbmV4cG9ydHMubWVyZ2VPYmplY3RzID0gbWVyZ2VPYmplY3RzO1xuXG5leHBvcnRzLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuZXhwb3J0cy5lbmRzV2l0aCA9IGVuZHNXaXRoO1xuXG5leHBvcnRzLnBhcnNlSW50ZWdlciA9IHBhcnNlSW50ZWdlcjtcblxuZXhwb3J0cy5pc284NjAxID0gaXNvODYwMTtcbmV4cG9ydHMucmZjMTEyMyA9IHJmYzExMjM7XG5leHBvcnRzLnBhcnNlRGF0ZVRpbWUgPSBwYXJzZURhdGVUaW1lO1xuXG5leHBvcnRzLmhydGltZWRpZmYgPSBocnRpbWVEaWZmO1xuZXhwb3J0cy5ocnRpbWVEaWZmID0gaHJ0aW1lRGlmZjtcbmV4cG9ydHMuaHJ0aW1lQWNjdW0gPSBocnRpbWVBY2N1bTtcbmV4cG9ydHMuaHJ0aW1lQWRkID0gaHJ0aW1lQWRkO1xuZXhwb3J0cy5ocnRpbWVOYW5vc2VjID0gaHJ0aW1lTmFub3NlYztcbmV4cG9ydHMuaHJ0aW1lTWljcm9zZWMgPSBocnRpbWVNaWNyb3NlYztcbmV4cG9ydHMuaHJ0aW1lTWlsbGlzZWMgPSBocnRpbWVNaWxsaXNlYztcblxuXG4vKlxuICogRGVlcCBjb3B5IGFuIGFjeWNsaWMgKmJhc2ljKiBKYXZhc2NyaXB0IG9iamVjdC4gIFRoaXMgb25seSBoYW5kbGVzIGJhc2ljXG4gKiBzY2FsYXJzIChzdHJpbmdzLCBudW1iZXJzLCBib29sZWFucykgYW5kIGFyYml0cmFyaWx5IGRlZXAgYXJyYXlzIGFuZCBvYmplY3RzXG4gKiBjb250YWluaW5nIHRoZXNlLiAgVGhpcyBkb2VzICpub3QqIGhhbmRsZSBpbnN0YW5jZXMgb2Ygb3RoZXIgY2xhc3Nlcy5cbiAqL1xuZnVuY3Rpb24gZGVlcENvcHkob2JqKVxue1xuXHR2YXIgcmV0LCBrZXk7XG5cdHZhciBtYXJrZXIgPSAnX19kZWVwQ29weSc7XG5cblx0aWYgKG9iaiAmJiBvYmpbbWFya2VyXSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdhdHRlbXB0ZWQgZGVlcCBjb3B5IG9mIGN5Y2xpYyBvYmplY3QnKSk7XG5cblx0aWYgKG9iaiAmJiBvYmouY29uc3RydWN0b3IgPT0gT2JqZWN0KSB7XG5cdFx0cmV0ID0ge307XG5cdFx0b2JqW21hcmtlcl0gPSB0cnVlO1xuXG5cdFx0Zm9yIChrZXkgaW4gb2JqKSB7XG5cdFx0XHRpZiAoa2V5ID09IG1hcmtlcilcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdHJldFtrZXldID0gZGVlcENvcHkob2JqW2tleV0pO1xuXHRcdH1cblxuXHRcdGRlbGV0ZSAob2JqW21hcmtlcl0pO1xuXHRcdHJldHVybiAocmV0KTtcblx0fVxuXG5cdGlmIChvYmogJiYgb2JqLmNvbnN0cnVjdG9yID09IEFycmF5KSB7XG5cdFx0cmV0ID0gW107XG5cdFx0b2JqW21hcmtlcl0gPSB0cnVlO1xuXG5cdFx0Zm9yIChrZXkgPSAwOyBrZXkgPCBvYmoubGVuZ3RoOyBrZXkrKylcblx0XHRcdHJldC5wdXNoKGRlZXBDb3B5KG9ialtrZXldKSk7XG5cblx0XHRkZWxldGUgKG9ialttYXJrZXJdKTtcblx0XHRyZXR1cm4gKHJldCk7XG5cdH1cblxuXHQvKlxuXHQgKiBJdCBtdXN0IGJlIGEgcHJpbWl0aXZlIHR5cGUgLS0ganVzdCByZXR1cm4gaXQuXG5cdCAqL1xuXHRyZXR1cm4gKG9iaik7XG59XG5cbmZ1bmN0aW9uIGRlZXBFcXVhbChvYmoxLCBvYmoyKVxue1xuXHRpZiAodHlwZW9mIChvYmoxKSAhPSB0eXBlb2YgKG9iajIpKVxuXHRcdHJldHVybiAoZmFsc2UpO1xuXG5cdGlmIChvYmoxID09PSBudWxsIHx8IG9iajIgPT09IG51bGwgfHwgdHlwZW9mIChvYmoxKSAhPSAnb2JqZWN0Jylcblx0XHRyZXR1cm4gKG9iajEgPT09IG9iajIpO1xuXG5cdGlmIChvYmoxLmNvbnN0cnVjdG9yICE9IG9iajIuY29uc3RydWN0b3IpXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cblx0dmFyIGs7XG5cdGZvciAoayBpbiBvYmoxKSB7XG5cdFx0aWYgKCFvYmoyLmhhc093blByb3BlcnR5KGspKVxuXHRcdFx0cmV0dXJuIChmYWxzZSk7XG5cblx0XHRpZiAoIWRlZXBFcXVhbChvYmoxW2tdLCBvYmoyW2tdKSlcblx0XHRcdHJldHVybiAoZmFsc2UpO1xuXHR9XG5cblx0Zm9yIChrIGluIG9iajIpIHtcblx0XHRpZiAoIW9iajEuaGFzT3duUHJvcGVydHkoaykpXG5cdFx0XHRyZXR1cm4gKGZhbHNlKTtcblx0fVxuXG5cdHJldHVybiAodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKVxue1xuXHR2YXIga2V5O1xuXHRmb3IgKGtleSBpbiBvYmopXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cdHJldHVybiAodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGhhc0tleShvYmosIGtleSlcbntcblx0bW9kX2Fzc2VydC5lcXVhbCh0eXBlb2YgKGtleSksICdzdHJpbmcnKTtcblx0cmV0dXJuIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaEtleShvYmosIGNhbGxiYWNrKVxue1xuXHRmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdFx0aWYgKGhhc0tleShvYmosIGtleSkpIHtcblx0XHRcdGNhbGxiYWNrKGtleSwgb2JqW2tleV0pO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwbHVjayhvYmosIGtleSlcbntcblx0bW9kX2Fzc2VydC5lcXVhbCh0eXBlb2YgKGtleSksICdzdHJpbmcnKTtcblx0cmV0dXJuIChwbHVja3Yob2JqLCBrZXkpKTtcbn1cblxuZnVuY3Rpb24gcGx1Y2t2KG9iaiwga2V5KVxue1xuXHRpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiAob2JqKSAhPT0gJ29iamVjdCcpXG5cdFx0cmV0dXJuICh1bmRlZmluZWQpO1xuXG5cdGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSlcblx0XHRyZXR1cm4gKG9ialtrZXldKTtcblxuXHR2YXIgaSA9IGtleS5pbmRleE9mKCcuJyk7XG5cdGlmIChpID09IC0xKVxuXHRcdHJldHVybiAodW5kZWZpbmVkKTtcblxuXHR2YXIga2V5MSA9IGtleS5zdWJzdHIoMCwgaSk7XG5cdGlmICghb2JqLmhhc093blByb3BlcnR5KGtleTEpKVxuXHRcdHJldHVybiAodW5kZWZpbmVkKTtcblxuXHRyZXR1cm4gKHBsdWNrdihvYmpba2V5MV0sIGtleS5zdWJzdHIoaSArIDEpKSk7XG59XG5cbi8qXG4gKiBJbnZva2UgY2FsbGJhY2socm93KSBmb3IgZWFjaCBlbnRyeSBpbiB0aGUgYXJyYXkgdGhhdCB3b3VsZCBiZSByZXR1cm5lZCBieVxuICogZmxhdHRlbk9iamVjdChkYXRhLCBkZXB0aCkuICBUaGlzIGlzIGp1c3QgbGlrZSBmbGF0dGVuT2JqZWN0KGRhdGEsXG4gKiBkZXB0aCkuZm9yRWFjaChjYWxsYmFjayksIGV4Y2VwdCB0aGF0IHRoZSBpbnRlcm1lZGlhdGUgYXJyYXkgaXMgbmV2ZXJcbiAqIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5JdGVyKGRhdGEsIGRlcHRoLCBjYWxsYmFjaylcbntcblx0ZG9GbGF0dGVuSXRlcihkYXRhLCBkZXB0aCwgW10sIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZG9GbGF0dGVuSXRlcihkYXRhLCBkZXB0aCwgYWNjdW0sIGNhbGxiYWNrKVxue1xuXHR2YXIgZWFjaDtcblx0dmFyIGtleTtcblxuXHRpZiAoZGVwdGggPT09IDApIHtcblx0XHRlYWNoID0gYWNjdW0uc2xpY2UoMCk7XG5cdFx0ZWFjaC5wdXNoKGRhdGEpO1xuXHRcdGNhbGxiYWNrKGVhY2gpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdG1vZF9hc3NlcnQub2soZGF0YSAhPT0gbnVsbCk7XG5cdG1vZF9hc3NlcnQuZXF1YWwodHlwZW9mIChkYXRhKSwgJ29iamVjdCcpO1xuXHRtb2RfYXNzZXJ0LmVxdWFsKHR5cGVvZiAoZGVwdGgpLCAnbnVtYmVyJyk7XG5cdG1vZF9hc3NlcnQub2soZGVwdGggPj0gMCk7XG5cblx0Zm9yIChrZXkgaW4gZGF0YSkge1xuXHRcdGVhY2ggPSBhY2N1bS5zbGljZSgwKTtcblx0XHRlYWNoLnB1c2goa2V5KTtcblx0XHRkb0ZsYXR0ZW5JdGVyKGRhdGFba2V5XSwgZGVwdGggLSAxLCBlYWNoLCBjYWxsYmFjayk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZmxhdHRlbk9iamVjdChkYXRhLCBkZXB0aClcbntcblx0aWYgKGRlcHRoID09PSAwKVxuXHRcdHJldHVybiAoWyBkYXRhIF0pO1xuXG5cdG1vZF9hc3NlcnQub2soZGF0YSAhPT0gbnVsbCk7XG5cdG1vZF9hc3NlcnQuZXF1YWwodHlwZW9mIChkYXRhKSwgJ29iamVjdCcpO1xuXHRtb2RfYXNzZXJ0LmVxdWFsKHR5cGVvZiAoZGVwdGgpLCAnbnVtYmVyJyk7XG5cdG1vZF9hc3NlcnQub2soZGVwdGggPj0gMCk7XG5cblx0dmFyIHJ2ID0gW107XG5cdHZhciBrZXk7XG5cblx0Zm9yIChrZXkgaW4gZGF0YSkge1xuXHRcdGZsYXR0ZW5PYmplY3QoZGF0YVtrZXldLCBkZXB0aCAtIDEpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcblx0XHRcdHJ2LnB1c2goWyBrZXkgXS5jb25jYXQocCkpO1xuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIChydik7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBwcmVmaXgpXG57XG5cdHJldHVybiAoc3RyLnN1YnN0cigwLCBwcmVmaXgubGVuZ3RoKSA9PSBwcmVmaXgpO1xufVxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHN1ZmZpeClcbntcblx0cmV0dXJuIChzdHIuc3Vic3RyKFxuXHQgICAgc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgsIHN1ZmZpeC5sZW5ndGgpID09IHN1ZmZpeCk7XG59XG5cbmZ1bmN0aW9uIGlzbzg2MDEoZClcbntcblx0aWYgKHR5cGVvZiAoZCkgPT0gJ251bWJlcicpXG5cdFx0ZCA9IG5ldyBEYXRlKGQpO1xuXHRtb2RfYXNzZXJ0Lm9rKGQuY29uc3RydWN0b3IgPT09IERhdGUpO1xuXHRyZXR1cm4gKG1vZF9leHRzcHJpbnRmLnNwcmludGYoJyU0ZC0lMDJkLSUwMmRUJTAyZDolMDJkOiUwMmQuJTAzZFonLFxuXHQgICAgZC5nZXRVVENGdWxsWWVhcigpLCBkLmdldFVUQ01vbnRoKCkgKyAxLCBkLmdldFVUQ0RhdGUoKSxcblx0ICAgIGQuZ2V0VVRDSG91cnMoKSwgZC5nZXRVVENNaW51dGVzKCksIGQuZ2V0VVRDU2Vjb25kcygpLFxuXHQgICAgZC5nZXRVVENNaWxsaXNlY29uZHMoKSkpO1xufVxuXG52YXIgUkZDMTEyM19NT05USFMgPSBbXG4gICAgJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJyxcbiAgICAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcbnZhciBSRkMxMTIzX0RBWVMgPSBbXG4gICAgJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddO1xuXG5mdW5jdGlvbiByZmMxMTIzKGRhdGUpIHtcblx0cmV0dXJuIChtb2RfZXh0c3ByaW50Zi5zcHJpbnRmKCclcywgJTAyZCAlcyAlMDRkICUwMmQ6JTAyZDolMDJkIEdNVCcsXG5cdCAgICBSRkMxMTIzX0RBWVNbZGF0ZS5nZXRVVENEYXkoKV0sIGRhdGUuZ2V0VVRDRGF0ZSgpLFxuXHQgICAgUkZDMTEyM19NT05USFNbZGF0ZS5nZXRVVENNb250aCgpXSwgZGF0ZS5nZXRVVENGdWxsWWVhcigpLFxuXHQgICAgZGF0ZS5nZXRVVENIb3VycygpLCBkYXRlLmdldFVUQ01pbnV0ZXMoKSxcblx0ICAgIGRhdGUuZ2V0VVRDU2Vjb25kcygpKSk7XG59XG5cbi8qXG4gKiBQYXJzZXMgYSBkYXRlIGV4cHJlc3NlZCBhcyBhIHN0cmluZywgYXMgZWl0aGVyIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZVxuICogdGhlIGVwb2NoIG9yIGFueSBzdHJpbmcgZm9ybWF0IHRoYXQgRGF0ZSBhY2NlcHRzLCBnaXZpbmcgcHJlZmVyZW5jZSB0byB0aGVcbiAqIGZvcm1lciB3aGVyZSB0aGVzZSB0d28gc2V0cyBvdmVybGFwIChlLmcuLCBzbWFsbCBudW1iZXJzKS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VEYXRlVGltZShzdHIpXG57XG5cdC8qXG5cdCAqIFRoaXMgaXMgaXJyaXRhdGluZ2x5IGltcGxpY2l0LCBidXQgc2lnbmlmaWNhbnRseSBtb3JlIGNvbmNpc2UgdGhhblxuXHQgKiBhbHRlcm5hdGl2ZXMuICBUaGUgXCIrc3RyXCIgd2lsbCBjb252ZXJ0IGEgc3RyaW5nIGNvbnRhaW5pbmcgb25seSBhXG5cdCAqIG51bWJlciBkaXJlY3RseSB0byBhIE51bWJlciwgb3IgTmFOIGZvciBvdGhlciBzdHJpbmdzLiAgVGh1cywgaWYgdGhlXG5cdCAqIGNvbnZlcnNpb24gc3VjY2VlZHMsIHdlIHVzZSBpdCAodGhpcyBpcyB0aGUgbWlsbGlzZWNvbmRzLXNpbmNlLWVwb2NoXG5cdCAqIGNhc2UpLiAgT3RoZXJ3aXNlLCB3ZSBwYXNzIHRoZSBzdHJpbmcgZGlyZWN0bHkgdG8gdGhlIERhdGVcblx0ICogY29uc3RydWN0b3IgdG8gcGFyc2UuXG5cdCAqL1xuXHR2YXIgbnVtZXJpYyA9ICtzdHI7XG5cdGlmICghaXNOYU4obnVtZXJpYykpIHtcblx0XHRyZXR1cm4gKG5ldyBEYXRlKG51bWVyaWMpKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gKG5ldyBEYXRlKHN0cikpO1xuXHR9XG59XG5cblxuLypcbiAqIE51bWJlci4qX1NBRkVfSU5URUdFUiBpc24ndCBwcmVzZW50IGJlZm9yZSBub2RlIHYwLjEyLCBzbyB3ZSBoYXJkY29kZVxuICogdGhlIEVTNiBkZWZpbml0aW9ucyBoZXJlLCB3aGlsZSBhbGxvd2luZyBmb3IgdGhlbSB0byBzb21lZGF5IGJlIGhpZ2hlci5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xudmFyIE1JTl9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB8fCAtOTAwNzE5OTI1NDc0MDk5MTtcblxuXG4vKlxuICogRGVmYXVsdCBvcHRpb25zIGZvciBwYXJzZUludGVnZXIoKS5cbiAqL1xudmFyIFBJX0RFRkFVTFRTID0ge1xuXHRiYXNlOiAxMCxcblx0YWxsb3dTaWduOiB0cnVlLFxuXHRhbGxvd1ByZWZpeDogZmFsc2UsXG5cdGFsbG93VHJhaWxpbmc6IGZhbHNlLFxuXHRhbGxvd0ltcHJlY2lzZTogZmFsc2UsXG5cdHRyaW1XaGl0ZXNwYWNlOiBmYWxzZSxcblx0bGVhZGluZ1plcm9Jc09jdGFsOiBmYWxzZVxufTtcblxudmFyIENQXzAgPSAweDMwO1xudmFyIENQXzkgPSAweDM5O1xuXG52YXIgQ1BfQSA9IDB4NDE7XG52YXIgQ1BfQiA9IDB4NDI7XG52YXIgQ1BfTyA9IDB4NGY7XG52YXIgQ1BfVCA9IDB4NTQ7XG52YXIgQ1BfWCA9IDB4NTg7XG52YXIgQ1BfWiA9IDB4NWE7XG5cbnZhciBDUF9hID0gMHg2MTtcbnZhciBDUF9iID0gMHg2MjtcbnZhciBDUF9vID0gMHg2ZjtcbnZhciBDUF90ID0gMHg3NDtcbnZhciBDUF94ID0gMHg3ODtcbnZhciBDUF96ID0gMHg3YTtcblxudmFyIFBJX0NPTlZfREVDID0gMHgzMDtcbnZhciBQSV9DT05WX1VDID0gMHgzNztcbnZhciBQSV9DT05WX0xDID0gMHg1NztcblxuXG4vKlxuICogQSBzdHJpY3RlciB2ZXJzaW9uIG9mIHBhcnNlSW50KCkgdGhhdCBwcm92aWRlcyBvcHRpb25zIGZvciBjaGFuZ2luZyB3aGF0XG4gKiBpcyBhbiBhY2NlcHRhYmxlIHN0cmluZyAoZm9yIGV4YW1wbGUsIGRpc2FsbG93aW5nIHRyYWlsaW5nIGNoYXJhY3RlcnMpLlxuICovXG5mdW5jdGlvbiBwYXJzZUludGVnZXIoc3RyLCB1b3B0cylcbntcblx0bW9kX2Fzc2VydC5zdHJpbmcoc3RyLCAnc3RyJyk7XG5cdG1vZF9hc3NlcnQub3B0aW9uYWxPYmplY3QodW9wdHMsICdvcHRpb25zJyk7XG5cblx0dmFyIGJhc2VPdmVycmlkZSA9IGZhbHNlO1xuXHR2YXIgb3B0aW9ucyA9IFBJX0RFRkFVTFRTO1xuXG5cdGlmICh1b3B0cykge1xuXHRcdGJhc2VPdmVycmlkZSA9IGhhc0tleSh1b3B0cywgJ2Jhc2UnKTtcblx0XHRvcHRpb25zID0gbWVyZ2VPYmplY3RzKG9wdGlvbnMsIHVvcHRzKTtcblx0XHRtb2RfYXNzZXJ0Lm51bWJlcihvcHRpb25zLmJhc2UsICdvcHRpb25zLmJhc2UnKTtcblx0XHRtb2RfYXNzZXJ0Lm9rKG9wdGlvbnMuYmFzZSA+PSAyLCAnb3B0aW9ucy5iYXNlID49IDInKTtcblx0XHRtb2RfYXNzZXJ0Lm9rKG9wdGlvbnMuYmFzZSA8PSAzNiwgJ29wdGlvbnMuYmFzZSA8PSAzNicpO1xuXHRcdG1vZF9hc3NlcnQuYm9vbChvcHRpb25zLmFsbG93U2lnbiwgJ29wdGlvbnMuYWxsb3dTaWduJyk7XG5cdFx0bW9kX2Fzc2VydC5ib29sKG9wdGlvbnMuYWxsb3dQcmVmaXgsICdvcHRpb25zLmFsbG93UHJlZml4Jyk7XG5cdFx0bW9kX2Fzc2VydC5ib29sKG9wdGlvbnMuYWxsb3dUcmFpbGluZyxcblx0XHQgICAgJ29wdGlvbnMuYWxsb3dUcmFpbGluZycpO1xuXHRcdG1vZF9hc3NlcnQuYm9vbChvcHRpb25zLmFsbG93SW1wcmVjaXNlLFxuXHRcdCAgICAnb3B0aW9ucy5hbGxvd0ltcHJlY2lzZScpO1xuXHRcdG1vZF9hc3NlcnQuYm9vbChvcHRpb25zLnRyaW1XaGl0ZXNwYWNlLFxuXHRcdCAgICAnb3B0aW9ucy50cmltV2hpdGVzcGFjZScpO1xuXHRcdG1vZF9hc3NlcnQuYm9vbChvcHRpb25zLmxlYWRpbmdaZXJvSXNPY3RhbCxcblx0XHQgICAgJ29wdGlvbnMubGVhZGluZ1plcm9Jc09jdGFsJyk7XG5cblx0XHRpZiAob3B0aW9ucy5sZWFkaW5nWmVyb0lzT2N0YWwpIHtcblx0XHRcdG1vZF9hc3NlcnQub2soIWJhc2VPdmVycmlkZSxcblx0XHRcdCAgICAnXCJiYXNlXCIgYW5kIFwibGVhZGluZ1plcm9Jc09jdGFsXCIgYXJlICcgK1xuXHRcdFx0ICAgICdtdXR1YWxseSBleGNsdXNpdmUnKTtcblx0XHR9XG5cdH1cblxuXHR2YXIgYztcblx0dmFyIHBiYXNlID0gLTE7XG5cdHZhciBiYXNlID0gb3B0aW9ucy5iYXNlO1xuXHR2YXIgc3RhcnQ7XG5cdHZhciBtdWx0ID0gMTtcblx0dmFyIHZhbHVlID0gMDtcblx0dmFyIGlkeCA9IDA7XG5cdHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuXG5cdC8qIFRyaW0gYW55IHdoaXRlc3BhY2Ugb24gdGhlIGxlZnQgc2lkZS4gKi9cblx0aWYgKG9wdGlvbnMudHJpbVdoaXRlc3BhY2UpIHtcblx0XHR3aGlsZSAoaWR4IDwgbGVuICYmIGlzU3BhY2Uoc3RyLmNoYXJDb2RlQXQoaWR4KSkpIHtcblx0XHRcdCsraWR4O1xuXHRcdH1cblx0fVxuXG5cdC8qIENoZWNrIHRoZSBudW1iZXIgZm9yIGEgbGVhZGluZyBzaWduLiAqL1xuXHRpZiAob3B0aW9ucy5hbGxvd1NpZ24pIHtcblx0XHRpZiAoc3RyW2lkeF0gPT09ICctJykge1xuXHRcdFx0aWR4ICs9IDE7XG5cdFx0XHRtdWx0ID0gLTE7XG5cdFx0fSBlbHNlIGlmIChzdHJbaWR4XSA9PT0gJysnKSB7XG5cdFx0XHRpZHggKz0gMTtcblx0XHR9XG5cdH1cblxuXHQvKiBQYXJzZSB0aGUgYmFzZS1pbmRpY2F0aW5nIHByZWZpeCBpZiB0aGVyZSBpcyBvbmUuICovXG5cdGlmIChzdHJbaWR4XSA9PT0gJzAnKSB7XG5cdFx0aWYgKG9wdGlvbnMuYWxsb3dQcmVmaXgpIHtcblx0XHRcdHBiYXNlID0gcHJlZml4VG9CYXNlKHN0ci5jaGFyQ29kZUF0KGlkeCArIDEpKTtcblx0XHRcdGlmIChwYmFzZSAhPT0gLTEgJiYgKCFiYXNlT3ZlcnJpZGUgfHwgcGJhc2UgPT09IGJhc2UpKSB7XG5cdFx0XHRcdGJhc2UgPSBwYmFzZTtcblx0XHRcdFx0aWR4ICs9IDI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHBiYXNlID09PSAtMSAmJiBvcHRpb25zLmxlYWRpbmdaZXJvSXNPY3RhbCkge1xuXHRcdFx0YmFzZSA9IDg7XG5cdFx0fVxuXHR9XG5cblx0LyogUGFyc2UgdGhlIGFjdHVhbCBkaWdpdHMuICovXG5cdGZvciAoc3RhcnQgPSBpZHg7IGlkeCA8IGxlbjsgKytpZHgpIHtcblx0XHRjID0gdHJhbnNsYXRlRGlnaXQoc3RyLmNoYXJDb2RlQXQoaWR4KSk7XG5cdFx0aWYgKGMgIT09IC0xICYmIGMgPCBiYXNlKSB7XG5cdFx0XHR2YWx1ZSAqPSBiYXNlO1xuXHRcdFx0dmFsdWUgKz0gYztcblx0XHR9IGVsc2Uge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0LyogSWYgd2UgZGlkbid0IHBhcnNlIGFueSBkaWdpdHMsIHdlIGhhdmUgYW4gaW52YWxpZCBudW1iZXIuICovXG5cdGlmIChzdGFydCA9PT0gaWR4KSB7XG5cdFx0cmV0dXJuIChuZXcgRXJyb3IoJ2ludmFsaWQgbnVtYmVyOiAnICsgSlNPTi5zdHJpbmdpZnkoc3RyKSkpO1xuXHR9XG5cblx0LyogVHJpbSBhbnkgd2hpdGVzcGFjZSBvbiB0aGUgcmlnaHQgc2lkZS4gKi9cblx0aWYgKG9wdGlvbnMudHJpbVdoaXRlc3BhY2UpIHtcblx0XHR3aGlsZSAoaWR4IDwgbGVuICYmIGlzU3BhY2Uoc3RyLmNoYXJDb2RlQXQoaWR4KSkpIHtcblx0XHRcdCsraWR4O1xuXHRcdH1cblx0fVxuXG5cdC8qIENoZWNrIGZvciB0cmFpbGluZyBjaGFyYWN0ZXJzLiAqL1xuXHRpZiAoaWR4IDwgbGVuICYmICFvcHRpb25zLmFsbG93VHJhaWxpbmcpIHtcblx0XHRyZXR1cm4gKG5ldyBFcnJvcigndHJhaWxpbmcgY2hhcmFjdGVycyBhZnRlciBudW1iZXI6ICcgK1xuXHRcdCAgICBKU09OLnN0cmluZ2lmeShzdHIuc2xpY2UoaWR4KSkpKTtcblx0fVxuXG5cdC8qIElmIG91ciB2YWx1ZSBpcyAwLCB3ZSByZXR1cm4gbm93LCB0byBhdm9pZCByZXR1cm5pbmcgLTAuICovXG5cdGlmICh2YWx1ZSA9PT0gMCkge1xuXHRcdHJldHVybiAoMCk7XG5cdH1cblxuXHQvKiBDYWxjdWxhdGUgb3VyIGZpbmFsIHZhbHVlLiAqL1xuXHR2YXIgcmVzdWx0ID0gdmFsdWUgKiBtdWx0O1xuXG5cdC8qXG5cdCAqIElmIHRoZSBzdHJpbmcgcmVwcmVzZW50cyBhIHZhbHVlIHRoYXQgY2Fubm90IGJlIHByZWNpc2VseSByZXByZXNlbnRlZFxuXHQgKiBieSBKYXZhU2NyaXB0LCB0aGVuIHdlIHdhbnQgdG8gY2hlY2sgdGhhdDpcblx0ICpcblx0ICogLSBXZSBuZXZlciBpbmNyZWFzZWQgdGhlIHZhbHVlIHBhc3QgTUFYX1NBRkVfSU5URUdFUlxuXHQgKiAtIFdlIGRvbid0IG1ha2UgdGhlIHJlc3VsdCBuZWdhdGl2ZSBhbmQgYmVsb3cgTUlOX1NBRkVfSU5URUdFUlxuXHQgKlxuXHQgKiBCZWNhdXNlIHdlIG9ubHkgZXZlciBpbmNyZW1lbnQgdGhlIHZhbHVlIGR1cmluZyBwYXJzaW5nLCB0aGVyZSdzIG5vXG5cdCAqIGNoYW5jZSBvZiBtb3ZpbmcgcGFzdCBNQVhfU0FGRV9JTlRFR0VSIGFuZCB0aGVuIGRyb3BwaW5nIGJlbG93IGl0XG5cdCAqIGFnYWluLCBsb3NpbmcgcHJlY2lzaW9uIGluIHRoZSBwcm9jZXNzLiBUaGlzIG1lYW5zIHRoYXQgd2Ugb25seSBuZWVkXG5cdCAqIHRvIGRvIG91ciBjaGVja3MgaGVyZSwgYXQgdGhlIGVuZC5cblx0ICovXG5cdGlmICghb3B0aW9ucy5hbGxvd0ltcHJlY2lzZSAmJlxuXHQgICAgKHZhbHVlID4gTUFYX1NBRkVfSU5URUdFUiB8fCByZXN1bHQgPCBNSU5fU0FGRV9JTlRFR0VSKSkge1xuXHRcdHJldHVybiAobmV3IEVycm9yKCdudW1iZXIgaXMgb3V0c2lkZSBvZiB0aGUgc3VwcG9ydGVkIHJhbmdlOiAnICtcblx0XHQgICAgSlNPTi5zdHJpbmdpZnkoc3RyLnNsaWNlKHN0YXJ0LCBpZHgpKSkpO1xuXHR9XG5cblx0cmV0dXJuIChyZXN1bHQpO1xufVxuXG5cbi8qXG4gKiBJbnRlcnByZXQgYSBjaGFyYWN0ZXIgY29kZSBhcyBhIGJhc2UtMzYgZGlnaXQuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zbGF0ZURpZ2l0KGQpXG57XG5cdGlmIChkID49IENQXzAgJiYgZCA8PSBDUF85KSB7XG5cdFx0LyogJzAnIHRvICc5JyAtPiAwIHRvIDkgKi9cblx0XHRyZXR1cm4gKGQgLSBQSV9DT05WX0RFQyk7XG5cdH0gZWxzZSBpZiAoZCA+PSBDUF9BICYmIGQgPD0gQ1BfWikge1xuXHRcdC8qICdBJyAtICdaJyAtPiAxMCB0byAzNSAqL1xuXHRcdHJldHVybiAoZCAtIFBJX0NPTlZfVUMpO1xuXHR9IGVsc2UgaWYgKGQgPj0gQ1BfYSAmJiBkIDw9IENQX3opIHtcblx0XHQvKiAnYScgLSAneicgLT4gMTAgdG8gMzUgKi9cblx0XHRyZXR1cm4gKGQgLSBQSV9DT05WX0xDKTtcblx0fSBlbHNlIHtcblx0XHQvKiBJbnZhbGlkIGNoYXJhY3RlciBjb2RlICovXG5cdFx0cmV0dXJuICgtMSk7XG5cdH1cbn1cblxuXG4vKlxuICogVGVzdCBpZiBhIHZhbHVlIG1hdGNoZXMgdGhlIEVDTUFTY3JpcHQgZGVmaW5pdGlvbiBvZiB0cmltbWFibGUgd2hpdGVzcGFjZS5cbiAqL1xuZnVuY3Rpb24gaXNTcGFjZShjKVxue1xuXHRyZXR1cm4gKGMgPT09IDB4MjApIHx8XG5cdCAgICAoYyA+PSAweDAwMDkgJiYgYyA8PSAweDAwMGQpIHx8XG5cdCAgICAoYyA9PT0gMHgwMGEwKSB8fFxuXHQgICAgKGMgPT09IDB4MTY4MCkgfHxcblx0ICAgIChjID09PSAweDE4MGUpIHx8XG5cdCAgICAoYyA+PSAweDIwMDAgJiYgYyA8PSAweDIwMGEpIHx8XG5cdCAgICAoYyA9PT0gMHgyMDI4KSB8fFxuXHQgICAgKGMgPT09IDB4MjAyOSkgfHxcblx0ICAgIChjID09PSAweDIwMmYpIHx8XG5cdCAgICAoYyA9PT0gMHgyMDVmKSB8fFxuXHQgICAgKGMgPT09IDB4MzAwMCkgfHxcblx0ICAgIChjID09PSAweGZlZmYpO1xufVxuXG5cbi8qXG4gKiBEZXRlcm1pbmUgd2hpY2ggYmFzZSBhIGNoYXJhY3RlciBpbmRpY2F0ZXMgKGUuZy4sICd4JyBpbmRpY2F0ZXMgaGV4KS5cbiAqL1xuZnVuY3Rpb24gcHJlZml4VG9CYXNlKGMpXG57XG5cdGlmIChjID09PSBDUF9iIHx8IGMgPT09IENQX0IpIHtcblx0XHQvKiAwYi8wQiAoYmluYXJ5KSAqL1xuXHRcdHJldHVybiAoMik7XG5cdH0gZWxzZSBpZiAoYyA9PT0gQ1BfbyB8fCBjID09PSBDUF9PKSB7XG5cdFx0LyogMG8vME8gKG9jdGFsKSAqL1xuXHRcdHJldHVybiAoOCk7XG5cdH0gZWxzZSBpZiAoYyA9PT0gQ1BfdCB8fCBjID09PSBDUF9UKSB7XG5cdFx0LyogMHQvMFQgKGRlY2ltYWwpICovXG5cdFx0cmV0dXJuICgxMCk7XG5cdH0gZWxzZSBpZiAoYyA9PT0gQ1BfeCB8fCBjID09PSBDUF9YKSB7XG5cdFx0LyogMHgvMFggKGhleGFkZWNpbWFsKSAqL1xuXHRcdHJldHVybiAoMTYpO1xuXHR9IGVsc2Uge1xuXHRcdC8qIE5vdCBhIG1lYW5pbmdmdWwgY2hhcmFjdGVyICovXG5cdFx0cmV0dXJuICgtMSk7XG5cdH1cbn1cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUpzb25PYmplY3RKUyhzY2hlbWEsIGlucHV0KVxue1xuXHR2YXIgcmVwb3J0ID0gbW9kX2pzb25zY2hlbWEudmFsaWRhdGUoaW5wdXQsIHNjaGVtYSk7XG5cblx0aWYgKHJlcG9ydC5lcnJvcnMubGVuZ3RoID09PSAwKVxuXHRcdHJldHVybiAobnVsbCk7XG5cblx0LyogQ3VycmVudGx5LCB3ZSBvbmx5IGRvIGFueXRoaW5nIHVzZWZ1bCB3aXRoIHRoZSBmaXJzdCBlcnJvci4gKi9cblx0dmFyIGVycm9yID0gcmVwb3J0LmVycm9yc1swXTtcblxuXHQvKiBUaGUgZmFpbGVkIHByb3BlcnR5IGlzIGdpdmVuIGJ5IGEgVVJJIHdpdGggYW4gaXJyZWxldmFudCBwcmVmaXguICovXG5cdHZhciBwcm9wbmFtZSA9IGVycm9yWydwcm9wZXJ0eSddO1xuXHR2YXIgcmVhc29uID0gZXJyb3JbJ21lc3NhZ2UnXS50b0xvd2VyQ2FzZSgpO1xuXHR2YXIgaSwgajtcblxuXHQvKlxuXHQgKiBUaGVyZSdzIGF0IGxlYXN0IG9uZSBjYXNlIHdoZXJlIHRoZSBwcm9wZXJ0eSBlcnJvciBtZXNzYWdlIGlzXG5cdCAqIGNvbmZ1c2luZyBhdCBiZXN0LiAgV2Ugd29yayBhcm91bmQgdGhpcyBoZXJlLlxuXHQgKi9cblx0aWYgKChpID0gcmVhc29uLmluZGV4T2YoJ3RoZSBwcm9wZXJ0eSAnKSkgIT0gLTEgJiZcblx0ICAgIChqID0gcmVhc29uLmluZGV4T2YoJyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgc2NoZW1hIGFuZCB0aGUgJyArXG5cdCAgICAnc2NoZW1hIGRvZXMgbm90IGFsbG93IGFkZGl0aW9uYWwgcHJvcGVydGllcycpKSAhPSAtMSkge1xuXHRcdGkgKz0gJ3RoZSBwcm9wZXJ0eSAnLmxlbmd0aDtcblx0XHRpZiAocHJvcG5hbWUgPT09ICcnKVxuXHRcdFx0cHJvcG5hbWUgPSByZWFzb24uc3Vic3RyKGksIGogLSBpKTtcblx0XHRlbHNlXG5cdFx0XHRwcm9wbmFtZSA9IHByb3BuYW1lICsgJy4nICsgcmVhc29uLnN1YnN0cihpLCBqIC0gaSk7XG5cblx0XHRyZWFzb24gPSAndW5zdXBwb3J0ZWQgcHJvcGVydHknO1xuXHR9XG5cblx0dmFyIHJ2ID0gbmV3IG1vZF92ZXJyb3IuVkVycm9yKCdwcm9wZXJ0eSBcIiVzXCI6ICVzJywgcHJvcG5hbWUsIHJlYXNvbik7XG5cdHJ2Lmpzdl9kZXRhaWxzID0gZXJyb3I7XG5cdHJldHVybiAocnYpO1xufVxuXG5mdW5jdGlvbiByYW5kRWx0KGFycilcbntcblx0bW9kX2Fzc2VydC5vayhBcnJheS5pc0FycmF5KGFycikgJiYgYXJyLmxlbmd0aCA+IDAsXG5cdCAgICAncmFuZEVsdCBhcmd1bWVudCBtdXN0IGJlIGEgbm9uLWVtcHR5IGFycmF5Jyk7XG5cblx0cmV0dXJuIChhcnJbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyLmxlbmd0aCldKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SHJ0aW1lKGEpXG57XG5cdG1vZF9hc3NlcnQub2soYVswXSA+PSAwICYmIGFbMV0gPj0gMCxcblx0ICAgICduZWdhdGl2ZSBudW1iZXJzIG5vdCBhbGxvd2VkIGluIGhydGltZXMnKTtcblx0bW9kX2Fzc2VydC5vayhhWzFdIDwgMWU5LCAnbmFub3NlY29uZHMgY29sdW1uIG92ZXJmbG93Jyk7XG59XG5cbi8qXG4gKiBDb21wdXRlIHRoZSB0aW1lIGVsYXBzZWQgYmV0d2VlbiBocnRpbWUgcmVhZGluZ3MgQSBhbmQgQiwgd2hlcmUgQSBpcyBsYXRlclxuICogdGhhbiBCLiAgaHJ0aW1lIHJlYWRpbmdzIGNvbWUgZnJvbSBOb2RlJ3MgcHJvY2Vzcy5ocnRpbWUoKS4gIFRoZXJlIGlzIG5vXG4gKiBkZWZpbmVkIHdheSB0byByZXByZXNlbnQgbmVnYXRpdmUgZGVsdGFzLCBzbyBpdCdzIGlsbGVnYWwgdG8gZGlmZiBCIGZyb20gQVxuICogd2hlcmUgdGhlIHRpbWUgZGVub3RlZCBieSBCIGlzIGxhdGVyIHRoYW4gdGhlIHRpbWUgZGVub3RlZCBieSBBLiAgSWYgdGhpc1xuICogYmVjb21lcyB2YWx1YWJsZSwgd2UgY2FuIGRlZmluZSBhIHJlcHJlc2VudGF0aW9uIGFuZCBleHRlbmQgdGhlXG4gKiBpbXBsZW1lbnRhdGlvbiB0byBzdXBwb3J0IGl0LlxuICovXG5mdW5jdGlvbiBocnRpbWVEaWZmKGEsIGIpXG57XG5cdGFzc2VydEhydGltZShhKTtcblx0YXNzZXJ0SHJ0aW1lKGIpO1xuXHRtb2RfYXNzZXJ0Lm9rKGFbMF0gPiBiWzBdIHx8IChhWzBdID09IGJbMF0gJiYgYVsxXSA+PSBiWzFdKSxcblx0ICAgICduZWdhdGl2ZSBkaWZmZXJlbmNlcyBub3QgYWxsb3dlZCcpO1xuXG5cdHZhciBydiA9IFsgYVswXSAtIGJbMF0sIDAgXTtcblxuXHRpZiAoYVsxXSA+PSBiWzFdKSB7XG5cdFx0cnZbMV0gPSBhWzFdIC0gYlsxXTtcblx0fSBlbHNlIHtcblx0XHRydlswXS0tO1xuXHRcdHJ2WzFdID0gMWU5IC0gKGJbMV0gLSBhWzFdKTtcblx0fVxuXG5cdHJldHVybiAocnYpO1xufVxuXG4vKlxuICogQ29udmVydCBhIGhydGltZSByZWFkaW5nIGZyb20gdGhlIGFycmF5IGZvcm1hdCByZXR1cm5lZCBieSBOb2RlJ3NcbiAqIHByb2Nlc3MuaHJ0aW1lKCkgaW50byBhIHNjYWxhciBudW1iZXIgb2YgbmFub3NlY29uZHMuXG4gKi9cbmZ1bmN0aW9uIGhydGltZU5hbm9zZWMoYSlcbntcblx0YXNzZXJ0SHJ0aW1lKGEpO1xuXG5cdHJldHVybiAoTWF0aC5mbG9vcihhWzBdICogMWU5ICsgYVsxXSkpO1xufVxuXG4vKlxuICogQ29udmVydCBhIGhydGltZSByZWFkaW5nIGZyb20gdGhlIGFycmF5IGZvcm1hdCByZXR1cm5lZCBieSBOb2RlJ3NcbiAqIHByb2Nlc3MuaHJ0aW1lKCkgaW50byBhIHNjYWxhciBudW1iZXIgb2YgbWljcm9zZWNvbmRzLlxuICovXG5mdW5jdGlvbiBocnRpbWVNaWNyb3NlYyhhKVxue1xuXHRhc3NlcnRIcnRpbWUoYSk7XG5cblx0cmV0dXJuIChNYXRoLmZsb29yKGFbMF0gKiAxZTYgKyBhWzFdIC8gMWUzKSk7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGEgaHJ0aW1lIHJlYWRpbmcgZnJvbSB0aGUgYXJyYXkgZm9ybWF0IHJldHVybmVkIGJ5IE5vZGUnc1xuICogcHJvY2Vzcy5ocnRpbWUoKSBpbnRvIGEgc2NhbGFyIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gKi9cbmZ1bmN0aW9uIGhydGltZU1pbGxpc2VjKGEpXG57XG5cdGFzc2VydEhydGltZShhKTtcblxuXHRyZXR1cm4gKE1hdGguZmxvb3IoYVswXSAqIDFlMyArIGFbMV0gLyAxZTYpKTtcbn1cblxuLypcbiAqIEFkZCB0d28gaHJ0aW1lIHJlYWRpbmdzIEEgYW5kIEIsIG92ZXJ3cml0aW5nIEEgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZVxuICogYWRkaXRpb24uICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCBmb3IgYWNjdW11bGF0aW5nIHNldmVyYWwgaHJ0aW1lIGludGVydmFsc1xuICogaW50byBhIGNvdW50ZXIuICBSZXR1cm5zIEEuXG4gKi9cbmZ1bmN0aW9uIGhydGltZUFjY3VtKGEsIGIpXG57XG5cdGFzc2VydEhydGltZShhKTtcblx0YXNzZXJ0SHJ0aW1lKGIpO1xuXG5cdC8qXG5cdCAqIEFjY3VtdWxhdGUgdGhlIG5hbm9zZWNvbmQgY29tcG9uZW50LlxuXHQgKi9cblx0YVsxXSArPSBiWzFdO1xuXHRpZiAoYVsxXSA+PSAxZTkpIHtcblx0XHQvKlxuXHRcdCAqIFRoZSBuYW5vc2Vjb25kIGNvbXBvbmVudCBvdmVyZmxvd2VkLCBzbyBjYXJyeSB0byB0aGUgc2Vjb25kc1xuXHRcdCAqIGZpZWxkLlxuXHRcdCAqL1xuXHRcdGFbMF0rKztcblx0XHRhWzFdIC09IDFlOTtcblx0fVxuXG5cdC8qXG5cdCAqIEFjY3VtdWxhdGUgdGhlIHNlY29uZHMgY29tcG9uZW50LlxuXHQgKi9cblx0YVswXSArPSBiWzBdO1xuXG5cdHJldHVybiAoYSk7XG59XG5cbi8qXG4gKiBBZGQgdHdvIGhydGltZSByZWFkaW5ncyBBIGFuZCBCLCByZXR1cm5pbmcgdGhlIHJlc3VsdCBhcyBhIG5ldyBocnRpbWUgYXJyYXkuXG4gKiBEb2VzIG5vdCBtb2RpZnkgZWl0aGVyIGlucHV0IGFyZ3VtZW50LlxuICovXG5mdW5jdGlvbiBocnRpbWVBZGQoYSwgYilcbntcblx0YXNzZXJ0SHJ0aW1lKGEpO1xuXG5cdHZhciBydiA9IFsgYVswXSwgYVsxXSBdO1xuXG5cdHJldHVybiAoaHJ0aW1lQWNjdW0ocnYsIGIpKTtcbn1cblxuXG4vKlxuICogQ2hlY2sgYW4gb2JqZWN0IGZvciB1bmV4cGVjdGVkIHByb3BlcnRpZXMuICBBY2NlcHRzIHRoZSBvYmplY3QgdG8gY2hlY2ssIGFuZFxuICogYW4gYXJyYXkgb2YgYWxsb3dlZCBwcm9wZXJ0eSBuYW1lcyAoc3RyaW5ncykuICBSZXR1cm5zIGFuIGFycmF5IG9mIGtleSBuYW1lc1xuICogdGhhdCB3ZXJlIGZvdW5kIG9uIHRoZSBvYmplY3QsIGJ1dCBkaWQgbm90IGFwcGVhciBpbiB0aGUgbGlzdCBvZiBhbGxvd2VkXG4gKiBwcm9wZXJ0aWVzLiAgSWYgbm8gcHJvcGVydGllcyB3ZXJlIGZvdW5kLCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBiZSBvZlxuICogemVybyBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGV4dHJhUHJvcGVydGllcyhvYmosIGFsbG93ZWQpXG57XG5cdG1vZF9hc3NlcnQub2sodHlwZW9mIChvYmopID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwsXG5cdCAgICAnb2JqIGFyZ3VtZW50IG11c3QgYmUgYSBub24tbnVsbCBvYmplY3QnKTtcblx0bW9kX2Fzc2VydC5vayhBcnJheS5pc0FycmF5KGFsbG93ZWQpLFxuXHQgICAgJ2FsbG93ZWQgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzJyk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYWxsb3dlZC5sZW5ndGg7IGkrKykge1xuXHRcdG1vZF9hc3NlcnQub2sodHlwZW9mIChhbGxvd2VkW2ldKSA9PT0gJ3N0cmluZycsXG5cdFx0ICAgICdhbGxvd2VkIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncycpO1xuXHR9XG5cblx0cmV0dXJuIChPYmplY3Qua2V5cyhvYmopLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG5cdFx0cmV0dXJuIChhbGxvd2VkLmluZGV4T2Yoa2V5KSA9PT0gLTEpO1xuXHR9KSk7XG59XG5cbi8qXG4gKiBHaXZlbiB0aHJlZSBzZXRzIG9mIHByb3BlcnRpZXMgXCJwcm92aWRlZFwiIChtYXkgYmUgdW5kZWZpbmVkKSwgXCJvdmVycmlkZXNcIlxuICogKHJlcXVpcmVkKSwgYW5kIFwiZGVmYXVsdHNcIiAobWF5IGJlIHVuZGVmaW5lZCksIGNvbnN0cnVjdCBhbiBvYmplY3QgY29udGFpbmluZ1xuICogdGhlIHVuaW9uIG9mIHRoZXNlIHNldHMgd2l0aCBcIm92ZXJyaWRlc1wiIG92ZXJyaWRpbmcgXCJwcm92aWRlZFwiLCBhbmRcbiAqIFwicHJvdmlkZWRcIiBvdmVycmlkaW5nIFwiZGVmYXVsdHNcIi4gIE5vbmUgb2YgdGhlIGlucHV0IG9iamVjdHMgYXJlIG1vZGlmaWVkLlxuICovXG5mdW5jdGlvbiBtZXJnZU9iamVjdHMocHJvdmlkZWQsIG92ZXJyaWRlcywgZGVmYXVsdHMpXG57XG5cdHZhciBydiwgaztcblxuXHRydiA9IHt9O1xuXHRpZiAoZGVmYXVsdHMpIHtcblx0XHRmb3IgKGsgaW4gZGVmYXVsdHMpXG5cdFx0XHRydltrXSA9IGRlZmF1bHRzW2tdO1xuXHR9XG5cblx0aWYgKHByb3ZpZGVkKSB7XG5cdFx0Zm9yIChrIGluIHByb3ZpZGVkKVxuXHRcdFx0cnZba10gPSBwcm92aWRlZFtrXTtcblx0fVxuXG5cdGlmIChvdmVycmlkZXMpIHtcblx0XHRmb3IgKGsgaW4gb3ZlcnJpZGVzKVxuXHRcdFx0cnZba10gPSBvdmVycmlkZXNba107XG5cdH1cblxuXHRyZXR1cm4gKHJ2KTtcbn1cbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25NZXJnZVZhbHVlO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XG4iLCJ2YXIgY3JlYXRlQmFzZUZvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VGb3InKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBiYXNlTWVyZ2VEZWVwID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlRGVlcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBrZXlzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZTtcbiIsInZhciBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0JyksXG4gICAgdG9QbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vdG9QbGFpbk9iamVjdCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZURlZXA7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlc3Q7XG4iLCJ2YXIgY29uc3RhbnQgPSByZXF1aXJlKCcuL2NvbnN0YW50JyksXG4gICAgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0VG9TdHJpbmc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwidmFyIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXNzaWduZXI7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiIG9yIFwiY29uc3RydWN0b3JcIi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhZmVHZXQ7XG4iLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudDtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwidmFyIGJhc2VNZXJnZSA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZScpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gdGhlIG9ubHkgcmVsaWFibGUgbWVhbnMgdG8gZ2V0IHRoZSBnbG9iYWwgb2JqZWN0IGlzXG5cdC8vIGBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpYFxuXHQvLyBIb3dldmVyLCB0aGlzIGNhdXNlcyBDU1AgdmlvbGF0aW9ucyBpbiBDaHJvbWUgYXBwcy5cblx0aWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gc2VsZjsgfVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHdpbmRvdzsgfVxuXHRpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGdsb2JhbDsgfVxuXHR0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdCcpO1xufVxuXG52YXIgZ2xvYmFsID0gZ2V0R2xvYmFsKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGdsb2JhbC5mZXRjaDtcblxuLy8gTmVlZGVkIGZvciBUeXBlU2NyaXB0IGFuZCBXZWJwYWNrLlxuZXhwb3J0cy5kZWZhdWx0ID0gZ2xvYmFsLmZldGNoLmJpbmQoZ2xvYmFsKTtcblxuZXhwb3J0cy5IZWFkZXJzID0gZ2xvYmFsLkhlYWRlcnM7XG5leHBvcnRzLlJlcXVlc3QgPSBnbG9iYWwuUmVxdWVzdDtcbmV4cG9ydHMuUmVzcG9uc2UgPSBnbG9iYWwuUmVzcG9uc2U7IiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fFxuICAgICFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IG5leHRUaWNrOiBuZXh0VGljayB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBhdm9pZCBzY29wZSBjcmVlcCwgdGhlIGtleXMgYXJyYXkgY2FuIHRoZW4gYmUgY29sbGVjdGVkXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwbmEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwbmEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG4gIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMuZW5kKCk7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5QYXNzVGhyb3VnaFxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBydW50aW1lLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG59KShcbiAgLy8gSW4gc2xvcHB5IG1vZGUsIHVuYm91bmQgYHRoaXNgIHJlZmVycyB0byB0aGUgZ2xvYmFsIG9iamVjdCwgZmFsbGJhY2sgdG9cbiAgLy8gRnVuY3Rpb24gY29uc3RydWN0b3IgaWYgd2UncmUgaW4gZ2xvYmFsIHN0cmljdCBtb2RlLiBUaGF0IGlzIHNhZGx5IGEgZm9ybVxuICAvLyBvZiBpbmRpcmVjdCBldmFsIHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LlxuICAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpXG4pO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwidmFyIENsaWVudFJlcXVlc3QgPSByZXF1aXJlKCcuL2xpYi9yZXF1ZXN0JylcbnZhciByZXNwb25zZSA9IHJlcXVpcmUoJy4vbGliL3Jlc3BvbnNlJylcbnZhciBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgc3RhdHVzQ29kZXMgPSByZXF1aXJlKCdidWlsdGluLXN0YXR1cy1jb2RlcycpXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcblxudmFyIGh0dHAgPSBleHBvcnRzXG5cbmh0dHAucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRzLCBjYikge1xuXHRpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKVxuXHRcdG9wdHMgPSB1cmwucGFyc2Uob3B0cylcblx0ZWxzZVxuXHRcdG9wdHMgPSBleHRlbmQob3B0cylcblxuXHQvLyBOb3JtYWxseSwgdGhlIHBhZ2UgaXMgbG9hZGVkIGZyb20gaHR0cCBvciBodHRwcywgc28gbm90IHNwZWNpZnlpbmcgYSBwcm90b2NvbFxuXHQvLyB3aWxsIHJlc3VsdCBpbiBhICh2YWxpZCkgcHJvdG9jb2wtcmVsYXRpdmUgdXJsLiBIb3dldmVyLCB0aGlzIHdvbid0IHdvcmsgaWZcblx0Ly8gdGhlIHByb3RvY29sIGlzIHNvbWV0aGluZyBlbHNlLCBsaWtlICdmaWxlOidcblx0dmFyIGRlZmF1bHRQcm90b2NvbCA9IGdsb2JhbC5sb2NhdGlvbi5wcm90b2NvbC5zZWFyY2goL15odHRwcz86JC8pID09PSAtMSA/ICdodHRwOicgOiAnJ1xuXG5cdHZhciBwcm90b2NvbCA9IG9wdHMucHJvdG9jb2wgfHwgZGVmYXVsdFByb3RvY29sXG5cdHZhciBob3N0ID0gb3B0cy5ob3N0bmFtZSB8fCBvcHRzLmhvc3Rcblx0dmFyIHBvcnQgPSBvcHRzLnBvcnRcblx0dmFyIHBhdGggPSBvcHRzLnBhdGggfHwgJy8nXG5cblx0Ly8gTmVjZXNzYXJ5IGZvciBJUHY2IGFkZHJlc3Nlc1xuXHRpZiAoaG9zdCAmJiBob3N0LmluZGV4T2YoJzonKSAhPT0gLTEpXG5cdFx0aG9zdCA9ICdbJyArIGhvc3QgKyAnXSdcblxuXHQvLyBUaGlzIG1heSBiZSBhIHJlbGF0aXZlIHVybC4gVGhlIGJyb3dzZXIgc2hvdWxkIGFsd2F5cyBiZSBhYmxlIHRvIGludGVycHJldCBpdCBjb3JyZWN0bHkuXG5cdG9wdHMudXJsID0gKGhvc3QgPyAocHJvdG9jb2wgKyAnLy8nICsgaG9zdCkgOiAnJykgKyAocG9ydCA/ICc6JyArIHBvcnQgOiAnJykgKyBwYXRoXG5cdG9wdHMubWV0aG9kID0gKG9wdHMubWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpXG5cdG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fVxuXG5cdC8vIEFsc28gdmFsaWQgb3B0cy5hdXRoLCBvcHRzLm1vZGVcblxuXHR2YXIgcmVxID0gbmV3IENsaWVudFJlcXVlc3Qob3B0cylcblx0aWYgKGNiKVxuXHRcdHJlcS5vbigncmVzcG9uc2UnLCBjYilcblx0cmV0dXJuIHJlcVxufVxuXG5odHRwLmdldCA9IGZ1bmN0aW9uIGdldCAob3B0cywgY2IpIHtcblx0dmFyIHJlcSA9IGh0dHAucmVxdWVzdChvcHRzLCBjYilcblx0cmVxLmVuZCgpXG5cdHJldHVybiByZXFcbn1cblxuaHR0cC5DbGllbnRSZXF1ZXN0ID0gQ2xpZW50UmVxdWVzdFxuaHR0cC5JbmNvbWluZ01lc3NhZ2UgPSByZXNwb25zZS5JbmNvbWluZ01lc3NhZ2VcblxuaHR0cC5BZ2VudCA9IGZ1bmN0aW9uICgpIHt9XG5odHRwLkFnZW50LmRlZmF1bHRNYXhTb2NrZXRzID0gNFxuXG5odHRwLmdsb2JhbEFnZW50ID0gbmV3IGh0dHAuQWdlbnQoKVxuXG5odHRwLlNUQVRVU19DT0RFUyA9IHN0YXR1c0NvZGVzXG5cbmh0dHAuTUVUSE9EUyA9IFtcblx0J0NIRUNLT1VUJyxcblx0J0NPTk5FQ1QnLFxuXHQnQ09QWScsXG5cdCdERUxFVEUnLFxuXHQnR0VUJyxcblx0J0hFQUQnLFxuXHQnTE9DSycsXG5cdCdNLVNFQVJDSCcsXG5cdCdNRVJHRScsXG5cdCdNS0FDVElWSVRZJyxcblx0J01LQ09MJyxcblx0J01PVkUnLFxuXHQnTk9USUZZJyxcblx0J09QVElPTlMnLFxuXHQnUEFUQ0gnLFxuXHQnUE9TVCcsXG5cdCdQUk9QRklORCcsXG5cdCdQUk9QUEFUQ0gnLFxuXHQnUFVSR0UnLFxuXHQnUFVUJyxcblx0J1JFUE9SVCcsXG5cdCdTRUFSQ0gnLFxuXHQnU1VCU0NSSUJFJyxcblx0J1RSQUNFJyxcblx0J1VOTE9DSycsXG5cdCdVTlNVQlNDUklCRSdcbl0iLCJleHBvcnRzLmZldGNoID0gaXNGdW5jdGlvbihnbG9iYWwuZmV0Y2gpICYmIGlzRnVuY3Rpb24oZ2xvYmFsLlJlYWRhYmxlU3RyZWFtKVxuXG5leHBvcnRzLndyaXRhYmxlU3RyZWFtID0gaXNGdW5jdGlvbihnbG9iYWwuV3JpdGFibGVTdHJlYW0pXG5cbmV4cG9ydHMuYWJvcnRDb250cm9sbGVyID0gaXNGdW5jdGlvbihnbG9iYWwuQWJvcnRDb250cm9sbGVyKVxuXG5leHBvcnRzLmJsb2JDb25zdHJ1Y3RvciA9IGZhbHNlXG50cnkge1xuXHRuZXcgQmxvYihbbmV3IEFycmF5QnVmZmVyKDEpXSlcblx0ZXhwb3J0cy5ibG9iQ29uc3RydWN0b3IgPSB0cnVlXG59IGNhdGNoIChlKSB7fVxuXG4vLyBUaGUgeGhyIHJlcXVlc3QgdG8gZXhhbXBsZS5jb20gbWF5IHZpb2xhdGUgc29tZSByZXN0cmljdGl2ZSBDU1AgY29uZmlndXJhdGlvbnMsXG4vLyBzbyBpZiB3ZSdyZSBydW5uaW5nIGluIGEgYnJvd3NlciB0aGF0IHN1cHBvcnRzIGBmZXRjaGAsIGF2b2lkIGNhbGxpbmcgZ2V0WEhSKClcbi8vIGFuZCBhc3N1bWUgc3VwcG9ydCBmb3IgY2VydGFpbiBmZWF0dXJlcyBiZWxvdy5cbnZhciB4aHJcbmZ1bmN0aW9uIGdldFhIUiAoKSB7XG5cdC8vIENhY2hlIHRoZSB4aHIgdmFsdWVcblx0aWYgKHhociAhPT0gdW5kZWZpbmVkKSByZXR1cm4geGhyXG5cblx0aWYgKGdsb2JhbC5YTUxIdHRwUmVxdWVzdCkge1xuXHRcdHhociA9IG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKVxuXHRcdC8vIElmIFhEb21haW5SZXF1ZXN0IGlzIGF2YWlsYWJsZSAoaWUgb25seSwgd2hlcmUgeGhyIG1pZ2h0IG5vdCB3b3JrXG5cdFx0Ly8gY3Jvc3MgZG9tYWluKSwgdXNlIHRoZSBwYWdlIGxvY2F0aW9uLiBPdGhlcndpc2UgdXNlIGV4YW1wbGUuY29tXG5cdFx0Ly8gTm90ZTogdGhpcyBkb2Vzbid0IGFjdHVhbGx5IG1ha2UgYW4gaHR0cCByZXF1ZXN0LlxuXHRcdHRyeSB7XG5cdFx0XHR4aHIub3BlbignR0VUJywgZ2xvYmFsLlhEb21haW5SZXF1ZXN0ID8gJy8nIDogJ2h0dHBzOi8vZXhhbXBsZS5jb20nKVxuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0eGhyID0gbnVsbFxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBTZXJ2aWNlIHdvcmtlcnMgZG9uJ3QgaGF2ZSBYSFJcblx0XHR4aHIgPSBudWxsXG5cdH1cblx0cmV0dXJuIHhoclxufVxuXG5mdW5jdGlvbiBjaGVja1R5cGVTdXBwb3J0ICh0eXBlKSB7XG5cdHZhciB4aHIgPSBnZXRYSFIoKVxuXHRpZiAoIXhocikgcmV0dXJuIGZhbHNlXG5cdHRyeSB7XG5cdFx0eGhyLnJlc3BvbnNlVHlwZSA9IHR5cGVcblx0XHRyZXR1cm4geGhyLnJlc3BvbnNlVHlwZSA9PT0gdHlwZVxuXHR9IGNhdGNoIChlKSB7fVxuXHRyZXR1cm4gZmFsc2Vcbn1cblxuLy8gRm9yIHNvbWUgc3RyYW5nZSByZWFzb24sIFNhZmFyaSA3LjAgcmVwb3J0cyB0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyID09PSAnb2JqZWN0Jy5cbi8vIFNhZmFyaSA3LjEgYXBwZWFycyB0byBoYXZlIGZpeGVkIHRoaXMgYnVnLlxudmFyIGhhdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnXG52YXIgaGF2ZVNsaWNlID0gaGF2ZUFycmF5QnVmZmVyICYmIGlzRnVuY3Rpb24oZ2xvYmFsLkFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSlcblxuLy8gSWYgZmV0Y2ggaXMgc3VwcG9ydGVkLCB0aGVuIGFycmF5YnVmZmVyIHdpbGwgYmUgc3VwcG9ydGVkIHRvby4gU2tpcCBjYWxsaW5nXG4vLyBjaGVja1R5cGVTdXBwb3J0KCksIHNpbmNlIHRoYXQgY2FsbHMgZ2V0WEhSKCkuXG5leHBvcnRzLmFycmF5YnVmZmVyID0gZXhwb3J0cy5mZXRjaCB8fCAoaGF2ZUFycmF5QnVmZmVyICYmIGNoZWNrVHlwZVN1cHBvcnQoJ2FycmF5YnVmZmVyJykpXG5cbi8vIFRoZXNlIG5leHQgdHdvIHRlc3RzIHVuYXZvaWRhYmx5IHNob3cgd2FybmluZ3MgaW4gQ2hyb21lLiBTaW5jZSBmZXRjaCB3aWxsIGFsd2F5c1xuLy8gYmUgdXNlZCBpZiBpdCdzIGF2YWlsYWJsZSwganVzdCByZXR1cm4gZmFsc2UgZm9yIHRoZXNlIHRvIGF2b2lkIHRoZSB3YXJuaW5ncy5cbmV4cG9ydHMubXNzdHJlYW0gPSAhZXhwb3J0cy5mZXRjaCAmJiBoYXZlU2xpY2UgJiYgY2hlY2tUeXBlU3VwcG9ydCgnbXMtc3RyZWFtJylcbmV4cG9ydHMubW96Y2h1bmtlZGFycmF5YnVmZmVyID0gIWV4cG9ydHMuZmV0Y2ggJiYgaGF2ZUFycmF5QnVmZmVyICYmXG5cdGNoZWNrVHlwZVN1cHBvcnQoJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJylcblxuLy8gSWYgZmV0Y2ggaXMgc3VwcG9ydGVkLCB0aGVuIG92ZXJyaWRlTWltZVR5cGUgd2lsbCBiZSBzdXBwb3J0ZWQgdG9vLiBTa2lwIGNhbGxpbmdcbi8vIGdldFhIUigpLlxuZXhwb3J0cy5vdmVycmlkZU1pbWVUeXBlID0gZXhwb3J0cy5mZXRjaCB8fCAoZ2V0WEhSKCkgPyBpc0Z1bmN0aW9uKGdldFhIUigpLm92ZXJyaWRlTWltZVR5cGUpIDogZmFsc2UpXG5cbmV4cG9ydHMudmJBcnJheSA9IGlzRnVuY3Rpb24oZ2xvYmFsLlZCQXJyYXkpXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKHZhbHVlKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbn1cblxueGhyID0gbnVsbCAvLyBIZWxwIGdjXG4iLCJ2YXIgY2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vY2FwYWJpbGl0eScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgcmVzcG9uc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxudmFyIHRvQXJyYXlCdWZmZXIgPSByZXF1aXJlKCd0by1hcnJheWJ1ZmZlcicpXG5cbnZhciBJbmNvbWluZ01lc3NhZ2UgPSByZXNwb25zZS5JbmNvbWluZ01lc3NhZ2VcbnZhciByU3RhdGVzID0gcmVzcG9uc2UucmVhZHlTdGF0ZXNcblxuZnVuY3Rpb24gZGVjaWRlTW9kZSAocHJlZmVyQmluYXJ5LCB1c2VGZXRjaCkge1xuXHRpZiAoY2FwYWJpbGl0eS5mZXRjaCAmJiB1c2VGZXRjaCkge1xuXHRcdHJldHVybiAnZmV0Y2gnXG5cdH0gZWxzZSBpZiAoY2FwYWJpbGl0eS5tb3pjaHVua2VkYXJyYXlidWZmZXIpIHtcblx0XHRyZXR1cm4gJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkubXNzdHJlYW0pIHtcblx0XHRyZXR1cm4gJ21zLXN0cmVhbSdcblx0fSBlbHNlIGlmIChjYXBhYmlsaXR5LmFycmF5YnVmZmVyICYmIHByZWZlckJpbmFyeSkge1xuXHRcdHJldHVybiAnYXJyYXlidWZmZXInXG5cdH0gZWxzZSBpZiAoY2FwYWJpbGl0eS52YkFycmF5ICYmIHByZWZlckJpbmFyeSkge1xuXHRcdHJldHVybiAndGV4dDp2YmFycmF5J1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiAndGV4dCdcblx0fVxufVxuXG52YXIgQ2xpZW50UmVxdWVzdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHN0cmVhbS5Xcml0YWJsZS5jYWxsKHNlbGYpXG5cblx0c2VsZi5fb3B0cyA9IG9wdHNcblx0c2VsZi5fYm9keSA9IFtdXG5cdHNlbGYuX2hlYWRlcnMgPSB7fVxuXHRpZiAob3B0cy5hdXRoKVxuXHRcdHNlbGYuc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBuZXcgQnVmZmVyKG9wdHMuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpKVxuXHRPYmplY3Qua2V5cyhvcHRzLmhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRzZWxmLnNldEhlYWRlcihuYW1lLCBvcHRzLmhlYWRlcnNbbmFtZV0pXG5cdH0pXG5cblx0dmFyIHByZWZlckJpbmFyeVxuXHR2YXIgdXNlRmV0Y2ggPSB0cnVlXG5cdGlmIChvcHRzLm1vZGUgPT09ICdkaXNhYmxlLWZldGNoJyB8fCAoJ3JlcXVlc3RUaW1lb3V0JyBpbiBvcHRzICYmICFjYXBhYmlsaXR5LmFib3J0Q29udHJvbGxlcikpIHtcblx0XHQvLyBJZiB0aGUgdXNlIG9mIFhIUiBzaG91bGQgYmUgcHJlZmVycmVkLiBOb3QgdHlwaWNhbGx5IG5lZWRlZC5cblx0XHR1c2VGZXRjaCA9IGZhbHNlXG5cdFx0cHJlZmVyQmluYXJ5ID0gdHJ1ZVxuXHR9IGVsc2UgaWYgKG9wdHMubW9kZSA9PT0gJ3ByZWZlci1zdHJlYW1pbmcnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIGEgaGlnaCBwcmlvcml0eSBidXQgYmluYXJ5IGNvbXBhdGliaWxpdHkgYW5kXG5cdFx0Ly8gdGhlIGFjY3VyYWN5IG9mIHRoZSAnY29udGVudC10eXBlJyBoZWFkZXIgYXJlbid0XG5cdFx0cHJlZmVyQmluYXJ5ID0gZmFsc2Vcblx0fSBlbHNlIGlmIChvcHRzLm1vZGUgPT09ICdhbGxvdy13cm9uZy1jb250ZW50LXR5cGUnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIG1vcmUgaW1wb3J0YW50IHRoYW4gcHJlc2VydmluZyB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyXG5cdFx0cHJlZmVyQmluYXJ5ID0gIWNhcGFiaWxpdHkub3ZlcnJpZGVNaW1lVHlwZVxuXHR9IGVsc2UgaWYgKCFvcHRzLm1vZGUgfHwgb3B0cy5tb2RlID09PSAnZGVmYXVsdCcgfHwgb3B0cy5tb2RlID09PSAncHJlZmVyLWZhc3QnKSB7XG5cdFx0Ly8gVXNlIGJpbmFyeSBpZiB0ZXh0IHN0cmVhbWluZyBtYXkgY29ycnVwdCBkYXRhIG9yIHRoZSBjb250ZW50LXR5cGUgaGVhZGVyLCBvciBmb3Igc3BlZWRcblx0XHRwcmVmZXJCaW5hcnkgPSB0cnVlXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBvcHRzLm1vZGUnKVxuXHR9XG5cdHNlbGYuX21vZGUgPSBkZWNpZGVNb2RlKHByZWZlckJpbmFyeSwgdXNlRmV0Y2gpXG5cdHNlbGYuX2ZldGNoVGltZXIgPSBudWxsXG5cblx0c2VsZi5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuXHRcdHNlbGYuX29uRmluaXNoKClcblx0fSlcbn1cblxuaW5oZXJpdHMoQ2xpZW50UmVxdWVzdCwgc3RyZWFtLldyaXRhYmxlKVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHZhciBsb3dlck5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcblx0Ly8gVGhpcyBjaGVjayBpcyBub3QgbmVjZXNzYXJ5LCBidXQgaXQgcHJldmVudHMgd2FybmluZ3MgZnJvbSBicm93c2VycyBhYm91dCBzZXR0aW5nIHVuc2FmZVxuXHQvLyBoZWFkZXJzLiBUbyBiZSBob25lc3QgSSdtIG5vdCBlbnRpcmVseSBzdXJlIGhpZGluZyB0aGVzZSB3YXJuaW5ncyBpcyBhIGdvb2QgdGhpbmcsIGJ1dFxuXHQvLyBodHRwLWJyb3dzZXJpZnkgZGlkIGl0LCBzbyBJIHdpbGwgdG9vLlxuXHRpZiAodW5zYWZlSGVhZGVycy5pbmRleE9mKGxvd2VyTmFtZSkgIT09IC0xKVxuXHRcdHJldHVyblxuXG5cdHNlbGYuX2hlYWRlcnNbbG93ZXJOYW1lXSA9IHtcblx0XHRuYW1lOiBuYW1lLFxuXHRcdHZhbHVlOiB2YWx1ZVxuXHR9XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHZhciBoZWFkZXIgPSB0aGlzLl9oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV1cblx0aWYgKGhlYWRlcilcblx0XHRyZXR1cm4gaGVhZGVyLnZhbHVlXG5cdHJldHVybiBudWxsXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnJlbW92ZUhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHRkZWxldGUgc2VsZi5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9vbkZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRyZXR1cm5cblx0dmFyIG9wdHMgPSBzZWxmLl9vcHRzXG5cblx0dmFyIGhlYWRlcnNPYmogPSBzZWxmLl9oZWFkZXJzXG5cdHZhciBib2R5ID0gbnVsbFxuXHRpZiAob3B0cy5tZXRob2QgIT09ICdHRVQnICYmIG9wdHMubWV0aG9kICE9PSAnSEVBRCcpIHtcblx0XHRpZiAoY2FwYWJpbGl0eS5hcnJheWJ1ZmZlcikge1xuXHRcdFx0Ym9keSA9IHRvQXJyYXlCdWZmZXIoQnVmZmVyLmNvbmNhdChzZWxmLl9ib2R5KSlcblx0XHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkuYmxvYkNvbnN0cnVjdG9yKSB7XG5cdFx0XHRib2R5ID0gbmV3IGdsb2JhbC5CbG9iKHNlbGYuX2JvZHkubWFwKGZ1bmN0aW9uIChidWZmZXIpIHtcblx0XHRcdFx0cmV0dXJuIHRvQXJyYXlCdWZmZXIoYnVmZmVyKVxuXHRcdFx0fSksIHtcblx0XHRcdFx0dHlwZTogKGhlYWRlcnNPYmpbJ2NvbnRlbnQtdHlwZSddIHx8IHt9KS52YWx1ZSB8fCAnJ1xuXHRcdFx0fSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZ2V0IHV0Zjggc3RyaW5nXG5cdFx0XHRib2R5ID0gQnVmZmVyLmNvbmNhdChzZWxmLl9ib2R5KS50b1N0cmluZygpXG5cdFx0fVxuXHR9XG5cblx0Ly8gY3JlYXRlIGZsYXR0ZW5lZCBsaXN0IG9mIGhlYWRlcnNcblx0dmFyIGhlYWRlcnNMaXN0ID0gW11cblx0T2JqZWN0LmtleXMoaGVhZGVyc09iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5TmFtZSkge1xuXHRcdHZhciBuYW1lID0gaGVhZGVyc09ialtrZXlOYW1lXS5uYW1lXG5cdFx0dmFyIHZhbHVlID0gaGVhZGVyc09ialtrZXlOYW1lXS52YWx1ZVxuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0dmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodikge1xuXHRcdFx0XHRoZWFkZXJzTGlzdC5wdXNoKFtuYW1lLCB2XSlcblx0XHRcdH0pXG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlYWRlcnNMaXN0LnB1c2goW25hbWUsIHZhbHVlXSlcblx0XHR9XG5cdH0pXG5cblx0aWYgKHNlbGYuX21vZGUgPT09ICdmZXRjaCcpIHtcblx0XHR2YXIgc2lnbmFsID0gbnVsbFxuXHRcdHZhciBmZXRjaFRpbWVyID0gbnVsbFxuXHRcdGlmIChjYXBhYmlsaXR5LmFib3J0Q29udHJvbGxlcikge1xuXHRcdFx0dmFyIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblx0XHRcdHNpZ25hbCA9IGNvbnRyb2xsZXIuc2lnbmFsXG5cdFx0XHRzZWxmLl9mZXRjaEFib3J0Q29udHJvbGxlciA9IGNvbnRyb2xsZXJcblxuXHRcdFx0aWYgKCdyZXF1ZXN0VGltZW91dCcgaW4gb3B0cyAmJiBvcHRzLnJlcXVlc3RUaW1lb3V0ICE9PSAwKSB7XG5cdFx0XHRcdHNlbGYuX2ZldGNoVGltZXIgPSBnbG9iYWwuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0c2VsZi5lbWl0KCdyZXF1ZXN0VGltZW91dCcpXG5cdFx0XHRcdFx0aWYgKHNlbGYuX2ZldGNoQWJvcnRDb250cm9sbGVyKVxuXHRcdFx0XHRcdFx0c2VsZi5fZmV0Y2hBYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuXHRcdFx0XHR9LCBvcHRzLnJlcXVlc3RUaW1lb3V0KVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGdsb2JhbC5mZXRjaChzZWxmLl9vcHRzLnVybCwge1xuXHRcdFx0bWV0aG9kOiBzZWxmLl9vcHRzLm1ldGhvZCxcblx0XHRcdGhlYWRlcnM6IGhlYWRlcnNMaXN0LFxuXHRcdFx0Ym9keTogYm9keSB8fCB1bmRlZmluZWQsXG5cdFx0XHRtb2RlOiAnY29ycycsXG5cdFx0XHRjcmVkZW50aWFsczogb3B0cy53aXRoQ3JlZGVudGlhbHMgPyAnaW5jbHVkZScgOiAnc2FtZS1vcmlnaW4nLFxuXHRcdFx0c2lnbmFsOiBzaWduYWxcblx0XHR9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHRcdFx0c2VsZi5fZmV0Y2hSZXNwb25zZSA9IHJlc3BvbnNlXG5cdFx0XHRzZWxmLl9jb25uZWN0KClcblx0XHR9LCBmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRnbG9iYWwuY2xlYXJUaW1lb3V0KHNlbGYuX2ZldGNoVGltZXIpXG5cdFx0XHRpZiAoIXNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIHJlYXNvbilcblx0XHR9KVxuXHR9IGVsc2Uge1xuXHRcdHZhciB4aHIgPSBzZWxmLl94aHIgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KClcblx0XHR0cnkge1xuXHRcdFx0eGhyLm9wZW4oc2VsZi5fb3B0cy5tZXRob2QsIHNlbGYuX29wdHMudXJsLCB0cnVlKVxuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0cHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHR9KVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0Ly8gQ2FuJ3Qgc2V0IHJlc3BvbnNlVHlwZSBvbiByZWFsbHkgb2xkIGJyb3dzZXJzXG5cdFx0aWYgKCdyZXNwb25zZVR5cGUnIGluIHhocilcblx0XHRcdHhoci5yZXNwb25zZVR5cGUgPSBzZWxmLl9tb2RlLnNwbGl0KCc6JylbMF1cblxuXHRcdGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpXG5cdFx0XHR4aHIud2l0aENyZWRlbnRpYWxzID0gISFvcHRzLndpdGhDcmVkZW50aWFsc1xuXG5cdFx0aWYgKHNlbGYuX21vZGUgPT09ICd0ZXh0JyAmJiAnb3ZlcnJpZGVNaW1lVHlwZScgaW4geGhyKVxuXHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQnKVxuXG5cdFx0aWYgKCdyZXF1ZXN0VGltZW91dCcgaW4gb3B0cykge1xuXHRcdFx0eGhyLnRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0XG5cdFx0XHR4aHIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ3JlcXVlc3RUaW1lb3V0Jylcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoZWFkZXJzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcblx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuXHRcdH0pXG5cblx0XHRzZWxmLl9yZXNwb25zZSA9IG51bGxcblx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0c3dpdGNoICh4aHIucmVhZHlTdGF0ZSkge1xuXHRcdFx0XHRjYXNlIHJTdGF0ZXMuTE9BRElORzpcblx0XHRcdFx0Y2FzZSByU3RhdGVzLkRPTkU6XG5cdFx0XHRcdFx0c2VsZi5fb25YSFJQcm9ncmVzcygpXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gTmVjZXNzYXJ5IGZvciBzdHJlYW1pbmcgaW4gRmlyZWZveCwgc2luY2UgeGhyLnJlc3BvbnNlIGlzIE9OTFkgZGVmaW5lZFxuXHRcdC8vIGluIG9ucHJvZ3Jlc3MsIG5vdCBpbiBvbnJlYWR5c3RhdGVjaGFuZ2Ugd2l0aCB4aHIucmVhZHlTdGF0ZSA9IDNcblx0XHRpZiAoc2VsZi5fbW9kZSA9PT0gJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJykge1xuXHRcdFx0eGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuX29uWEhSUHJvZ3Jlc3MoKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdYSFIgZXJyb3InKSlcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0eGhyLnNlbmQoYm9keSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHRcdHJldHVyblxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB4aHIuc3RhdHVzIGlzIHJlYWRhYmxlIGFuZCBub24temVybywgaW5kaWNhdGluZyBubyBlcnJvci5cbiAqIEV2ZW4gdGhvdWdoIHRoZSBzcGVjIHNheXMgaXQgc2hvdWxkIGJlIGF2YWlsYWJsZSBpbiByZWFkeVN0YXRlIDMsXG4gKiBhY2Nlc3NpbmcgaXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpbiBJRThcbiAqL1xuZnVuY3Rpb24gc3RhdHVzVmFsaWQgKHhocikge1xuXHR0cnkge1xuXHRcdHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzXG5cdFx0cmV0dXJuIChzdGF0dXMgIT09IG51bGwgJiYgc3RhdHVzICE9PSAwKVxuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX29uWEhSUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGlmICghc3RhdHVzVmFsaWQoc2VsZi5feGhyKSB8fCBzZWxmLl9kZXN0cm95ZWQpXG5cdFx0cmV0dXJuXG5cblx0aWYgKCFzZWxmLl9yZXNwb25zZSlcblx0XHRzZWxmLl9jb25uZWN0KClcblxuXHRzZWxmLl9yZXNwb25zZS5fb25YSFJQcm9ncmVzcygpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdHJldHVyblxuXG5cdHNlbGYuX3Jlc3BvbnNlID0gbmV3IEluY29taW5nTWVzc2FnZShzZWxmLl94aHIsIHNlbGYuX2ZldGNoUmVzcG9uc2UsIHNlbGYuX21vZGUsIHNlbGYuX2ZldGNoVGltZXIpXG5cdHNlbGYuX3Jlc3BvbnNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuXHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdH0pXG5cblx0c2VsZi5lbWl0KCdyZXNwb25zZScsIHNlbGYuX3Jlc3BvbnNlKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHRzZWxmLl9ib2R5LnB1c2goY2h1bmspXG5cdGNiKClcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBDbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c2VsZi5fZGVzdHJveWVkID0gdHJ1ZVxuXHRnbG9iYWwuY2xlYXJUaW1lb3V0KHNlbGYuX2ZldGNoVGltZXIpXG5cdGlmIChzZWxmLl9yZXNwb25zZSlcblx0XHRzZWxmLl9yZXNwb25zZS5fZGVzdHJveWVkID0gdHJ1ZVxuXHRpZiAoc2VsZi5feGhyKVxuXHRcdHNlbGYuX3hoci5hYm9ydCgpXG5cdGVsc2UgaWYgKHNlbGYuX2ZldGNoQWJvcnRDb250cm9sbGVyKVxuXHRcdHNlbGYuX2ZldGNoQWJvcnRDb250cm9sbGVyLmFib3J0KClcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0aWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Y2IgPSBkYXRhXG5cdFx0ZGF0YSA9IHVuZGVmaW5lZFxuXHR9XG5cblx0c3RyZWFtLldyaXRhYmxlLnByb3RvdHlwZS5lbmQuY2FsbChzZWxmLCBkYXRhLCBlbmNvZGluZywgY2IpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmZsdXNoSGVhZGVycyA9IGZ1bmN0aW9uICgpIHt9XG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge31cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldE5vRGVsYXkgPSBmdW5jdGlvbiAoKSB7fVxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0U29ja2V0S2VlcEFsaXZlID0gZnVuY3Rpb24gKCkge31cblxuLy8gVGFrZW4gZnJvbSBodHRwOi8vd3d3LnczLm9yZy9UUi9YTUxIdHRwUmVxdWVzdC8jdGhlLXNldHJlcXVlc3RoZWFkZXIlMjglMjktbWV0aG9kXG52YXIgdW5zYWZlSGVhZGVycyA9IFtcblx0J2FjY2VwdC1jaGFyc2V0Jyxcblx0J2FjY2VwdC1lbmNvZGluZycsXG5cdCdhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnMnLFxuXHQnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2QnLFxuXHQnY29ubmVjdGlvbicsXG5cdCdjb250ZW50LWxlbmd0aCcsXG5cdCdjb29raWUnLFxuXHQnY29va2llMicsXG5cdCdkYXRlJyxcblx0J2RudCcsXG5cdCdleHBlY3QnLFxuXHQnaG9zdCcsXG5cdCdrZWVwLWFsaXZlJyxcblx0J29yaWdpbicsXG5cdCdyZWZlcmVyJyxcblx0J3RlJyxcblx0J3RyYWlsZXInLFxuXHQndHJhbnNmZXItZW5jb2RpbmcnLFxuXHQndXBncmFkZScsXG5cdCd2aWEnXG5dXG4iLCJ2YXIgY2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vY2FwYWJpbGl0eScpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcblxudmFyIHJTdGF0ZXMgPSBleHBvcnRzLnJlYWR5U3RhdGVzID0ge1xuXHRVTlNFTlQ6IDAsXG5cdE9QRU5FRDogMSxcblx0SEVBREVSU19SRUNFSVZFRDogMixcblx0TE9BRElORzogMyxcblx0RE9ORTogNFxufVxuXG52YXIgSW5jb21pbmdNZXNzYWdlID0gZXhwb3J0cy5JbmNvbWluZ01lc3NhZ2UgPSBmdW5jdGlvbiAoeGhyLCByZXNwb25zZSwgbW9kZSwgZmV0Y2hUaW1lcikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c3RyZWFtLlJlYWRhYmxlLmNhbGwoc2VsZilcblxuXHRzZWxmLl9tb2RlID0gbW9kZVxuXHRzZWxmLmhlYWRlcnMgPSB7fVxuXHRzZWxmLnJhd0hlYWRlcnMgPSBbXVxuXHRzZWxmLnRyYWlsZXJzID0ge31cblx0c2VsZi5yYXdUcmFpbGVycyA9IFtdXG5cblx0Ly8gRmFrZSB0aGUgJ2Nsb3NlJyBldmVudCwgYnV0IG9ubHkgb25jZSAnZW5kJyBmaXJlc1xuXHRzZWxmLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVGhlIG5leHRUaWNrIGlzIG5lY2Vzc2FyeSB0byBwcmV2ZW50IHRoZSAncmVxdWVzdCcgbW9kdWxlIGZyb20gY2F1c2luZyBhbiBpbmZpbml0ZSBsb29wXG5cdFx0cHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0XHRzZWxmLmVtaXQoJ2Nsb3NlJylcblx0XHR9KVxuXHR9KVxuXG5cdGlmIChtb2RlID09PSAnZmV0Y2gnKSB7XG5cdFx0c2VsZi5fZmV0Y2hSZXNwb25zZSA9IHJlc3BvbnNlXG5cblx0XHRzZWxmLnVybCA9IHJlc3BvbnNlLnVybFxuXHRcdHNlbGYuc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c1xuXHRcdHNlbGYuc3RhdHVzTWVzc2FnZSA9IHJlc3BvbnNlLnN0YXR1c1RleHRcblx0XHRcblx0XHRyZXNwb25zZS5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlciwga2V5KXtcblx0XHRcdHNlbGYuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSBoZWFkZXJcblx0XHRcdHNlbGYucmF3SGVhZGVycy5wdXNoKGtleSwgaGVhZGVyKVxuXHRcdH0pXG5cblx0XHRpZiAoY2FwYWJpbGl0eS53cml0YWJsZVN0cmVhbSkge1xuXHRcdFx0dmFyIHdyaXRhYmxlID0gbmV3IFdyaXRhYmxlU3RyZWFtKHtcblx0XHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChjaHVuaykge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdFx0XHRpZiAoc2VsZi5fZGVzdHJveWVkKSB7XG5cdFx0XHRcdFx0XHRcdHJlamVjdCgpXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoc2VsZi5wdXNoKG5ldyBCdWZmZXIoY2h1bmspKSkge1xuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKClcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYuX3Jlc3VtZUZldGNoID0gcmVzb2x2ZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNsb3NlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Z2xvYmFsLmNsZWFyVGltZW91dChmZXRjaFRpbWVyKVxuXHRcdFx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdFx0c2VsZi5wdXNoKG51bGwpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdFx0aWYgKCFzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXNwb25zZS5ib2R5LnBpcGVUbyh3cml0YWJsZSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRcdGdsb2JhbC5jbGVhclRpbWVvdXQoZmV0Y2hUaW1lcilcblx0XHRcdFx0XHRpZiAoIXNlbGYuX2Rlc3Ryb3llZClcblx0XHRcdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fSBjYXRjaCAoZSkge30gLy8gcGlwZVRvIG1ldGhvZCBpc24ndCBkZWZpbmVkLiBDYW4ndCBmaW5kIGEgYmV0dGVyIHdheSB0byBmZWF0dXJlIHRlc3QgdGhpc1xuXHRcdH1cblx0XHQvLyBmYWxsYmFjayBmb3Igd2hlbiB3cml0YWJsZVN0cmVhbSBvciBwaXBlVG8gYXJlbid0IGF2YWlsYWJsZVxuXHRcdHZhciByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpXG5cdFx0ZnVuY3Rpb24gcmVhZCAoKSB7XG5cdFx0XHRyZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0XHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRpZiAocmVzdWx0LmRvbmUpIHtcblx0XHRcdFx0XHRnbG9iYWwuY2xlYXJUaW1lb3V0KGZldGNoVGltZXIpXG5cdFx0XHRcdFx0c2VsZi5wdXNoKG51bGwpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5wdXNoKG5ldyBCdWZmZXIocmVzdWx0LnZhbHVlKSlcblx0XHRcdFx0cmVhZCgpXG5cdFx0XHR9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdGdsb2JhbC5jbGVhclRpbWVvdXQoZmV0Y2hUaW1lcilcblx0XHRcdFx0aWYgKCFzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdH0pXG5cdFx0fVxuXHRcdHJlYWQoKVxuXHR9IGVsc2Uge1xuXHRcdHNlbGYuX3hociA9IHhoclxuXHRcdHNlbGYuX3BvcyA9IDBcblxuXHRcdHNlbGYudXJsID0geGhyLnJlc3BvbnNlVVJMXG5cdFx0c2VsZi5zdGF0dXNDb2RlID0geGhyLnN0YXR1c1xuXHRcdHNlbGYuc3RhdHVzTWVzc2FnZSA9IHhoci5zdGF0dXNUZXh0XG5cdFx0dmFyIGhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkuc3BsaXQoL1xccj9cXG4vKVxuXHRcdGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyA9IGhlYWRlci5tYXRjaCgvXihbXjpdKyk6XFxzKiguKikvKVxuXHRcdFx0aWYgKG1hdGNoZXMpIHtcblx0XHRcdFx0dmFyIGtleSA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKVxuXHRcdFx0XHRpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcblx0XHRcdFx0XHRpZiAoc2VsZi5oZWFkZXJzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0c2VsZi5oZWFkZXJzW2tleV0gPSBbXVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XS5wdXNoKG1hdGNoZXNbMl0pXG5cdFx0XHRcdH0gZWxzZSBpZiAoc2VsZi5oZWFkZXJzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldICs9ICcsICcgKyBtYXRjaGVzWzJdXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi5oZWFkZXJzW2tleV0gPSBtYXRjaGVzWzJdXG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5yYXdIZWFkZXJzLnB1c2gobWF0Y2hlc1sxXSwgbWF0Y2hlc1syXSlcblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0c2VsZi5fY2hhcnNldCA9ICd4LXVzZXItZGVmaW5lZCdcblx0XHRpZiAoIWNhcGFiaWxpdHkub3ZlcnJpZGVNaW1lVHlwZSkge1xuXHRcdFx0dmFyIG1pbWVUeXBlID0gc2VsZi5yYXdIZWFkZXJzWydtaW1lLXR5cGUnXVxuXHRcdFx0aWYgKG1pbWVUeXBlKSB7XG5cdFx0XHRcdHZhciBjaGFyc2V0TWF0Y2ggPSBtaW1lVHlwZS5tYXRjaCgvO1xccypjaGFyc2V0PShbXjtdKSg7fCQpLylcblx0XHRcdFx0aWYgKGNoYXJzZXRNYXRjaCkge1xuXHRcdFx0XHRcdHNlbGYuX2NoYXJzZXQgPSBjaGFyc2V0TWF0Y2hbMV0udG9Mb3dlckNhc2UoKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXNlbGYuX2NoYXJzZXQpXG5cdFx0XHRcdHNlbGYuX2NoYXJzZXQgPSAndXRmLTgnIC8vIGJlc3QgZ3Vlc3Ncblx0XHR9XG5cdH1cbn1cblxuaW5oZXJpdHMoSW5jb21pbmdNZXNzYWdlLCBzdHJlYW0uUmVhZGFibGUpXG5cbkluY29taW5nTWVzc2FnZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHZhciByZXNvbHZlID0gc2VsZi5fcmVzdW1lRmV0Y2hcblx0aWYgKHJlc29sdmUpIHtcblx0XHRzZWxmLl9yZXN1bWVGZXRjaCA9IG51bGxcblx0XHRyZXNvbHZlKClcblx0fVxufVxuXG5JbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLl9vblhIUlByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgeGhyID0gc2VsZi5feGhyXG5cblx0dmFyIHJlc3BvbnNlID0gbnVsbFxuXHRzd2l0Y2ggKHNlbGYuX21vZGUpIHtcblx0XHRjYXNlICd0ZXh0OnZiYXJyYXknOiAvLyBGb3IgSUU5XG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuRE9ORSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIFRoaXMgZmFpbHMgaW4gSUU4XG5cdFx0XHRcdHJlc3BvbnNlID0gbmV3IGdsb2JhbC5WQkFycmF5KHhoci5yZXNwb25zZUJvZHkpLnRvQXJyYXkoKVxuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHRcdGlmIChyZXNwb25zZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRzZWxmLnB1c2gobmV3IEJ1ZmZlcihyZXNwb25zZSkpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0XHQvLyBGYWxscyB0aHJvdWdoIGluIElFOFx0XG5cdFx0Y2FzZSAndGV4dCc6XG5cdFx0XHR0cnkgeyAvLyBUaGlzIHdpbGwgZmFpbCB3aGVuIHJlYWR5U3RhdGUgPSAzIGluIElFOS4gU3dpdGNoIG1vZGUgYW5kIHdhaXQgZm9yIHJlYWR5U3RhdGUgPSA0XG5cdFx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlVGV4dFxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRzZWxmLl9tb2RlID0gJ3RleHQ6dmJhcnJheSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHRcdGlmIChyZXNwb25zZS5sZW5ndGggPiBzZWxmLl9wb3MpIHtcblx0XHRcdFx0dmFyIG5ld0RhdGEgPSByZXNwb25zZS5zdWJzdHIoc2VsZi5fcG9zKVxuXHRcdFx0XHRpZiAoc2VsZi5fY2hhcnNldCA9PT0gJ3gtdXNlci1kZWZpbmVkJykge1xuXHRcdFx0XHRcdHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKG5ld0RhdGEubGVuZ3RoKVxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RGF0YS5sZW5ndGg7IGkrKylcblx0XHRcdFx0XHRcdGJ1ZmZlcltpXSA9IG5ld0RhdGEuY2hhckNvZGVBdChpKSAmIDB4ZmZcblxuXHRcdFx0XHRcdHNlbGYucHVzaChidWZmZXIpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi5wdXNoKG5ld0RhdGEsIHNlbGYuX2NoYXJzZXQpXG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5fcG9zID0gcmVzcG9uc2UubGVuZ3RoXG5cdFx0XHR9XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgJ2FycmF5YnVmZmVyJzpcblx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gclN0YXRlcy5ET05FIHx8ICF4aHIucmVzcG9uc2UpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVxuXHRcdFx0c2VsZi5wdXNoKG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKSlcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInOiAvLyB0YWtlIHdob2xlXG5cdFx0XHRyZXNwb25zZSA9IHhoci5yZXNwb25zZVxuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlICE9PSByU3RhdGVzLkxPQURJTkcgfHwgIXJlc3BvbnNlKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0c2VsZi5wdXNoKG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKSlcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnbXMtc3RyZWFtJzpcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORylcblx0XHRcdFx0YnJlYWtcblx0XHRcdHZhciByZWFkZXIgPSBuZXcgZ2xvYmFsLk1TU3RyZWFtUmVhZGVyKClcblx0XHRcdHJlYWRlci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAocmVhZGVyLnJlc3VsdC5ieXRlTGVuZ3RoID4gc2VsZi5fcG9zKSB7XG5cdFx0XHRcdFx0c2VsZi5wdXNoKG5ldyBCdWZmZXIobmV3IFVpbnQ4QXJyYXkocmVhZGVyLnJlc3VsdC5zbGljZShzZWxmLl9wb3MpKSkpXG5cdFx0XHRcdFx0c2VsZi5fcG9zID0gcmVhZGVyLnJlc3VsdC5ieXRlTGVuZ3RoXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYucHVzaChudWxsKVxuXHRcdFx0fVxuXHRcdFx0Ly8gcmVhZGVyLm9uZXJyb3IgPSA/Pz8gLy8gVE9ETzogdGhpc1xuXHRcdFx0cmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHJlc3BvbnNlKVxuXHRcdFx0YnJlYWtcblx0fVxuXG5cdC8vIFRoZSBtcy1zdHJlYW0gY2FzZSBoYW5kbGVzIGVuZCBzZXBhcmF0ZWx5IGluIHJlYWRlci5vbmxvYWQoKVxuXHRpZiAoc2VsZi5feGhyLnJlYWR5U3RhdGUgPT09IHJTdGF0ZXMuRE9ORSAmJiBzZWxmLl9tb2RlICE9PSAnbXMtc3RyZWFtJykge1xuXHRcdHNlbGYucHVzaChudWxsKVxuXHR9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJ1Zikge1xuXHQvLyBJZiB0aGUgYnVmZmVyIGlzIGJhY2tlZCBieSBhIFVpbnQ4QXJyYXksIGEgZmFzdGVyIHZlcnNpb24gd2lsbCB3b3JrXG5cdGlmIChidWYgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG5cdFx0Ly8gSWYgdGhlIGJ1ZmZlciBpc24ndCBhIHN1YmFycmF5LCByZXR1cm4gdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXJcblx0XHRpZiAoYnVmLmJ5dGVPZmZzZXQgPT09IDAgJiYgYnVmLmJ5dGVMZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGJ1Zi5idWZmZXJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBidWYuYnVmZmVyLnNsaWNlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBnZXQgYSBwcm9wZXIgY29weVxuXHRcdFx0cmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmJ5dGVMZW5ndGgpXG5cdFx0fVxuXHR9XG5cblx0aWYgKEJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG5cdFx0Ly8gVGhpcyBpcyB0aGUgc2xvdyB2ZXJzaW9uIHRoYXQgd2lsbCB3b3JrIHdpdGggYW55IEJ1ZmZlclxuXHRcdC8vIGltcGxlbWVudGF0aW9uIChldmVuIGluIG9sZCBicm93c2Vycylcblx0XHR2YXIgYXJyYXlDb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmxlbmd0aClcblx0XHR2YXIgbGVuID0gYnVmLmxlbmd0aFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGFycmF5Q29weVtpXSA9IGJ1ZltpXVxuXHRcdH1cblx0XHRyZXR1cm4gYXJyYXlDb3B5LmJ1ZmZlclxuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG5cdH1cbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLCBudWxsLCByZXQpIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQsIHJlaiwgY2IpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuIiwiLypcbiAqIHZlcnJvci5qczogcmljaGVyIEphdmFTY3JpcHQgZXJyb3JzXG4gKi9cblxudmFyIG1vZF9hc3NlcnRwbHVzID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBtb2RfdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIG1vZF9leHRzcHJpbnRmID0gcmVxdWlyZSgnZXh0c3ByaW50ZicpO1xudmFyIG1vZF9pc0Vycm9yID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJykuaXNFcnJvcjtcbnZhciBzcHJpbnRmID0gbW9kX2V4dHNwcmludGYuc3ByaW50ZjtcblxuLypcbiAqIFB1YmxpYyBpbnRlcmZhY2VcbiAqL1xuXG4vKiBTbyB5b3UgY2FuICd2YXIgVkVycm9yID0gcmVxdWlyZSgndmVycm9yJyknICovXG5tb2R1bGUuZXhwb3J0cyA9IFZFcnJvcjtcbi8qIEZvciBjb21wYXRpYmlsaXR5ICovXG5WRXJyb3IuVkVycm9yID0gVkVycm9yO1xuLyogT3RoZXIgZXhwb3J0ZWQgY2xhc3NlcyAqL1xuVkVycm9yLlNFcnJvciA9IFNFcnJvcjtcblZFcnJvci5XRXJyb3IgPSBXRXJyb3I7XG5WRXJyb3IuTXVsdGlFcnJvciA9IE11bHRpRXJyb3I7XG5cbi8qXG4gKiBDb21tb24gZnVuY3Rpb24gdXNlZCB0byBwYXJzZSBjb25zdHJ1Y3RvciBhcmd1bWVudHMgZm9yIFZFcnJvciwgV0Vycm9yLCBhbmRcbiAqIFNFcnJvci4gIE5hbWVkIGFyZ3VtZW50cyB0byB0aGlzIGZ1bmN0aW9uOlxuICpcbiAqICAgICBzdHJpY3RcdFx0Zm9yY2Ugc3RyaWN0IGludGVycHJldGF0aW9uIG9mIHNwcmludGYgYXJndW1lbnRzLCBldmVuXG4gKiAgICAgXHRcdFx0aWYgdGhlIG9wdGlvbnMgaW4gXCJhcmd2XCIgZG9uJ3Qgc2F5IHNvXG4gKlxuICogICAgIGFyZ3ZcdFx0ZXJyb3IncyBjb25zdHJ1Y3RvciBhcmd1bWVudHMsIHdoaWNoIGFyZSB0byBiZVxuICogICAgIFx0XHRcdGludGVycHJldGVkIGFzIGRlc2NyaWJlZCBpbiBSRUFETUUubWQuICBGb3IgcXVpY2tcbiAqICAgICBcdFx0XHRyZWZlcmVuY2UsIFwiYXJndlwiIGhhcyBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtczpcbiAqXG4gKiAgICAgICAgICBbIHNwcmludGZfYXJncy4uLiBdICAgICAgICAgICAoYXJndlswXSBpcyBhIHN0cmluZylcbiAqICAgICAgICAgIFsgY2F1c2UsIHNwcmludGZfYXJncy4uLiBdICAgIChhcmd2WzBdIGlzIGFuIEVycm9yKVxuICogICAgICAgICAgWyBvcHRpb25zLCBzcHJpbnRmX2FyZ3MuLi4gXSAgKGFyZ3ZbMF0gaXMgYW4gb2JqZWN0KVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbm9ybWFsaXplcyB0aGVzZSBmb3JtcywgcHJvZHVjaW5nIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHByb3BlcnRpZXM6XG4gKlxuICogICAgb3B0aW9ucyAgICAgICAgICAgZXF1aXZhbGVudCB0byBcIm9wdGlvbnNcIiBpbiB0aGlyZCBmb3JtLiAgVGhpcyB3aWxsIG5ldmVyXG4gKiAgICBcdFx0XHRiZSBhIGRpcmVjdCByZWZlcmVuY2UgdG8gd2hhdCB0aGUgY2FsbGVyIHBhc3NlZCBpblxuICogICAgXHRcdFx0KGkuZS4sIGl0IG1heSBiZSBhIHNoYWxsb3cgY29weSksIHNvIGl0IGNhbiBiZSBmcmVlbHlcbiAqICAgIFx0XHRcdG1vZGlmaWVkLlxuICpcbiAqICAgIHNob3J0bWVzc2FnZSAgICAgIHJlc3VsdCBvZiBzcHJpbnRmKHNwcmludGZfYXJncyksIHRha2luZyBvcHRpb25zLnN0cmljdFxuICogICAgXHRcdFx0aW50byBhY2NvdW50IGFzIGRlc2NyaWJlZCBpbiBSRUFETUUubWQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ29uc3RydWN0b3JBcmd1bWVudHMoYXJncylcbntcblx0dmFyIGFyZ3YsIG9wdGlvbnMsIHNwcmludGZfYXJncywgc2hvcnRtZXNzYWdlLCBrO1xuXG5cdG1vZF9hc3NlcnRwbHVzLm9iamVjdChhcmdzLCAnYXJncycpO1xuXHRtb2RfYXNzZXJ0cGx1cy5ib29sKGFyZ3Muc3RyaWN0LCAnYXJncy5zdHJpY3QnKTtcblx0bW9kX2Fzc2VydHBsdXMuYXJyYXkoYXJncy5hcmd2LCAnYXJncy5hcmd2Jyk7XG5cdGFyZ3YgPSBhcmdzLmFyZ3Y7XG5cblx0Lypcblx0ICogRmlyc3QsIGZpZ3VyZSBvdXQgd2hpY2ggZm9ybSBvZiBpbnZvY2F0aW9uIHdlJ3ZlIGJlZW4gZ2l2ZW4uXG5cdCAqL1xuXHRpZiAoYXJndi5sZW5ndGggPT09IDApIHtcblx0XHRvcHRpb25zID0ge307XG5cdFx0c3ByaW50Zl9hcmdzID0gW107XG5cdH0gZWxzZSBpZiAobW9kX2lzRXJyb3IoYXJndlswXSkpIHtcblx0XHRvcHRpb25zID0geyAnY2F1c2UnOiBhcmd2WzBdIH07XG5cdFx0c3ByaW50Zl9hcmdzID0gYXJndi5zbGljZSgxKTtcblx0fSBlbHNlIGlmICh0eXBlb2YgKGFyZ3ZbMF0pID09PSAnb2JqZWN0Jykge1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0XHRmb3IgKGsgaW4gYXJndlswXSkge1xuXHRcdFx0b3B0aW9uc1trXSA9IGFyZ3ZbMF1ba107XG5cdFx0fVxuXHRcdHNwcmludGZfYXJncyA9IGFyZ3Yuc2xpY2UoMSk7XG5cdH0gZWxzZSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMuc3RyaW5nKGFyZ3ZbMF0sXG5cdFx0ICAgICdmaXJzdCBhcmd1bWVudCB0byBWRXJyb3IsIFNFcnJvciwgb3IgV0Vycm9yICcgK1xuXHRcdCAgICAnY29uc3RydWN0b3IgbXVzdCBiZSBhIHN0cmluZywgb2JqZWN0LCBvciBFcnJvcicpO1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0XHRzcHJpbnRmX2FyZ3MgPSBhcmd2O1xuXHR9XG5cblx0Lypcblx0ICogTm93IGNvbnN0cnVjdCB0aGUgZXJyb3IncyBtZXNzYWdlLlxuXHQgKlxuXHQgKiBleHRzcHJpbnRmICh3aGljaCB3ZSBpbnZva2UgaGVyZSB3aXRoIG91ciBjYWxsZXIncyBhcmd1bWVudHMgaW4gb3JkZXJcblx0ICogdG8gY29uc3RydWN0IHRoaXMgRXJyb3IncyBtZXNzYWdlKSBpcyBzdHJpY3QgaW4gaXRzIGludGVycHJldGF0aW9uIG9mXG5cdCAqIHZhbHVlcyB0byBiZSBwcm9jZXNzZWQgYnkgdGhlIFwiJXNcIiBzcGVjaWZpZXIuICBUaGUgdmFsdWUgcGFzc2VkIHRvXG5cdCAqIGV4dHNwcmludGYgbXVzdCBhY3R1YWxseSBiZSBhIHN0cmluZyBvciBzb21ldGhpbmcgY29udmVydGlibGUgdG8gYVxuXHQgKiBTdHJpbmcgdXNpbmcgLnRvU3RyaW5nKCkuICBQYXNzaW5nIG90aGVyIHZhbHVlcyAobm90YWJseSBcIm51bGxcIiBhbmRcblx0ICogXCJ1bmRlZmluZWRcIikgaXMgY29uc2lkZXJlZCBhIHByb2dyYW1tZXIgZXJyb3IuICBUaGUgYXNzdW1wdGlvbiBpc1xuXHQgKiB0aGF0IGlmIHlvdSBhY3R1YWxseSB3YW50IHRvIHByaW50IHRoZSBzdHJpbmcgXCJudWxsXCIgb3IgXCJ1bmRlZmluZWRcIixcblx0ICogdGhlbiB0aGF0J3MgZWFzeSB0byBkbyB0aGF0IHdoZW4geW91J3JlIGNhbGxpbmcgZXh0c3ByaW50Zjsgb24gdGhlXG5cdCAqIG90aGVyIGhhbmQsIGlmIHlvdSBkaWQgTk9UIHdhbnQgdGhhdCAoaS5lLiwgdGhlcmUncyBhY3R1YWxseSBhIGJ1Z1xuXHQgKiB3aGVyZSB0aGUgcHJvZ3JhbSBhc3N1bWVzIHNvbWUgdmFyaWFibGUgaXMgbm9uLW51bGwgYW5kIHRyaWVzIHRvXG5cdCAqIHByaW50IGl0LCB3aGljaCBtaWdodCBoYXBwZW4gd2hlbiBjb25zdHJ1Y3RpbmcgYSBwYWNrZXQgb3IgZmlsZSBpblxuXHQgKiBzb21lIHNwZWNpZmljIGZvcm1hdCksIHRoZW4gaXQncyBiZXR0ZXIgdG8gc3RvcCBpbW1lZGlhdGVseSB0aGFuXG5cdCAqIHByb2R1Y2UgYm9ndXMgb3V0cHV0LlxuXHQgKlxuXHQgKiBIb3dldmVyLCBzb21ldGltZXMgdGhlIGJ1ZyBpcyBvbmx5IGluIHRoZSBjb2RlIGNhbGxpbmcgVkVycm9yLCBhbmQgYVxuXHQgKiBwcm9ncmFtbWVyIG1pZ2h0IHByZWZlciB0byBoYXZlIHRoZSBlcnJvciBtZXNzYWdlIGNvbnRhaW4gXCJudWxsXCIgb3Jcblx0ICogXCJ1bmRlZmluZWRcIiByYXRoZXIgdGhhbiBoYXZlIHRoZSBidWcgaW4gdGhlIGVycm9yIHBhdGggY3Jhc2ggdGhlXG5cdCAqIHByb2dyYW0gKG1ha2luZyB0aGUgZmlyc3QgYnVnIGhhcmRlciB0byBpZGVudGlmeSkuICBGb3IgdGhhdCByZWFzb24sXG5cdCAqIGJ5IGRlZmF1bHQgVkVycm9yIGNvbnZlcnRzIFwibnVsbFwiIG9yIFwidW5kZWZpbmVkXCIgYXJndW1lbnRzIHRvIHRoZWlyXG5cdCAqIHN0cmluZyByZXByZXNlbnRhdGlvbnMgYW5kIHBhc3NlcyB0aG9zZSB0byBleHRzcHJpbnRmLiAgUHJvZ3JhbW1lcnNcblx0ICogZGVzaXJpbmcgdGhlIHN0cmljdCBiZWhhdmlvciBjYW4gdXNlIHRoZSBTRXJyb3IgY2xhc3Mgb3IgcGFzcyB0aGVcblx0ICogXCJzdHJpY3RcIiBvcHRpb24gdG8gdGhlIFZFcnJvciBjb25zdHJ1Y3Rvci5cblx0ICovXG5cdG1vZF9hc3NlcnRwbHVzLm9iamVjdChvcHRpb25zKTtcblx0aWYgKCFvcHRpb25zLnN0cmljdCAmJiAhYXJncy5zdHJpY3QpIHtcblx0XHRzcHJpbnRmX2FyZ3MgPSBzcHJpbnRmX2FyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG5cdFx0XHRyZXR1cm4gKGEgPT09IG51bGwgPyAnbnVsbCcgOlxuXHRcdFx0ICAgIGEgPT09IHVuZGVmaW5lZCA/ICd1bmRlZmluZWQnIDogYSk7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoc3ByaW50Zl9hcmdzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHNob3J0bWVzc2FnZSA9ICcnO1xuXHR9IGVsc2Uge1xuXHRcdHNob3J0bWVzc2FnZSA9IHNwcmludGYuYXBwbHkobnVsbCwgc3ByaW50Zl9hcmdzKTtcblx0fVxuXG5cdHJldHVybiAoe1xuXHQgICAgJ29wdGlvbnMnOiBvcHRpb25zLFxuXHQgICAgJ3Nob3J0bWVzc2FnZSc6IHNob3J0bWVzc2FnZVxuXHR9KTtcbn1cblxuLypcbiAqIFNlZSBSRUFETUUubWQgZm9yIHJlZmVyZW5jZSBkb2N1bWVudGF0aW9uLlxuICovXG5mdW5jdGlvbiBWRXJyb3IoKVxue1xuXHR2YXIgYXJncywgb2JqLCBwYXJzZWQsIGNhdXNlLCBjdG9yLCBtZXNzYWdlLCBrO1xuXG5cdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG5cdC8qXG5cdCAqIFRoaXMgaXMgYSByZWdyZXR0YWJsZSBwYXR0ZXJuLCBidXQgSmF2YVNjcmlwdCdzIGJ1aWx0LWluIEVycm9yIGNsYXNzXG5cdCAqIGlzIGRlZmluZWQgdG8gd29yayB0aGlzIHdheSwgc28gd2UgYWxsb3cgdGhlIGNvbnN0cnVjdG9yIHRvIGJlIGNhbGxlZFxuXHQgKiB3aXRob3V0IFwibmV3XCIuXG5cdCAqL1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgVkVycm9yKSkge1xuXHRcdG9iaiA9IE9iamVjdC5jcmVhdGUoVkVycm9yLnByb3RvdHlwZSk7XG5cdFx0VkVycm9yLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gKG9iaik7XG5cdH1cblxuXHQvKlxuXHQgKiBGb3IgY29udmVuaWVuY2UgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB3ZSBzdXBwb3J0IHNldmVyYWxcblx0ICogZGlmZmVyZW50IGNhbGxpbmcgZm9ybXMuICBOb3JtYWxpemUgdGhlbSBoZXJlLlxuXHQgKi9cblx0cGFyc2VkID0gcGFyc2VDb25zdHJ1Y3RvckFyZ3VtZW50cyh7XG5cdCAgICAnYXJndic6IGFyZ3MsXG5cdCAgICAnc3RyaWN0JzogZmFsc2Vcblx0fSk7XG5cblx0Lypcblx0ICogSWYgd2UndmUgYmVlbiBnaXZlbiBhIG5hbWUsIGFwcGx5IGl0IG5vdy5cblx0ICovXG5cdGlmIChwYXJzZWQub3B0aW9ucy5uYW1lKSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMuc3RyaW5nKHBhcnNlZC5vcHRpb25zLm5hbWUsXG5cdFx0ICAgICdlcnJvclxcJ3MgXCJuYW1lXCIgbXVzdCBiZSBhIHN0cmluZycpO1xuXHRcdHRoaXMubmFtZSA9IHBhcnNlZC5vcHRpb25zLm5hbWU7XG5cdH1cblxuXHQvKlxuXHQgKiBGb3IgZGVidWdnaW5nLCB3ZSBrZWVwIHRyYWNrIG9mIHRoZSBvcmlnaW5hbCBzaG9ydCBtZXNzYWdlIChhdHRhY2hlZFxuXHQgKiB0aGlzIEVycm9yIHBhcnRpY3VsYXJseSkgc2VwYXJhdGVseSBmcm9tIHRoZSBjb21wbGV0ZSBtZXNzYWdlICh3aGljaFxuXHQgKiBpbmNsdWRlcyB0aGUgbWVzc2FnZXMgb2Ygb3VyIGNhdXNlIGNoYWluKS5cblx0ICovXG5cdHRoaXMuanNlX3Nob3J0bXNnID0gcGFyc2VkLnNob3J0bWVzc2FnZTtcblx0bWVzc2FnZSA9IHBhcnNlZC5zaG9ydG1lc3NhZ2U7XG5cblx0Lypcblx0ICogSWYgd2UndmUgYmVlbiBnaXZlbiBhIGNhdXNlLCByZWNvcmQgYSByZWZlcmVuY2UgdG8gaXQgYW5kIHVwZGF0ZSBvdXJcblx0ICogbWVzc2FnZSBhcHByb3ByaWF0ZWx5LlxuXHQgKi9cblx0Y2F1c2UgPSBwYXJzZWQub3B0aW9ucy5jYXVzZTtcblx0aWYgKGNhdXNlKSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoY2F1c2UpLCAnY2F1c2UgaXMgbm90IGFuIEVycm9yJyk7XG5cdFx0dGhpcy5qc2VfY2F1c2UgPSBjYXVzZTtcblxuXHRcdGlmICghcGFyc2VkLm9wdGlvbnMuc2tpcENhdXNlTWVzc2FnZSkge1xuXHRcdFx0bWVzc2FnZSArPSAnOiAnICsgY2F1c2UubWVzc2FnZTtcblx0XHR9XG5cdH1cblxuXHQvKlxuXHQgKiBJZiB3ZSd2ZSBiZWVuIGdpdmVuIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMsIHNoYWxsb3ctY29weSB0aGF0XG5cdCAqIGhlcmUuICBXZSBkb24ndCB3YW50IHRvIHVzZSBhIGRlZXAgY29weSBpbiBjYXNlIHRoZXJlIGFyZSBub24tcGxhaW5cblx0ICogb2JqZWN0cyBoZXJlLCBidXQgd2UgZG9uJ3Qgd2FudCB0byB1c2UgdGhlIG9yaWdpbmFsIG9iamVjdCBpbiBjYXNlXG5cdCAqIHRoZSBjYWxsZXIgbW9kaWZpZXMgaXQgbGF0ZXIuXG5cdCAqL1xuXHR0aGlzLmpzZV9pbmZvID0ge307XG5cdGlmIChwYXJzZWQub3B0aW9ucy5pbmZvKSB7XG5cdFx0Zm9yIChrIGluIHBhcnNlZC5vcHRpb25zLmluZm8pIHtcblx0XHRcdHRoaXMuanNlX2luZm9ba10gPSBwYXJzZWQub3B0aW9ucy5pbmZvW2tdO1xuXHRcdH1cblx0fVxuXG5cdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cblx0aWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG5cdFx0Y3RvciA9IHBhcnNlZC5vcHRpb25zLmNvbnN0cnVjdG9yT3B0IHx8IHRoaXMuY29uc3RydWN0b3I7XG5cdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgY3Rvcik7XG5cdH1cblxuXHRyZXR1cm4gKHRoaXMpO1xufVxuXG5tb2RfdXRpbC5pbmhlcml0cyhWRXJyb3IsIEVycm9yKTtcblZFcnJvci5wcm90b3R5cGUubmFtZSA9ICdWRXJyb3InO1xuXG5WRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdmVfdG9TdHJpbmcoKVxue1xuXHR2YXIgc3RyID0gKHRoaXMuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJiB0aGlzLm5hbWUgfHxcblx0XHR0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUubmFtZSk7XG5cdGlmICh0aGlzLm1lc3NhZ2UpXG5cdFx0c3RyICs9ICc6ICcgKyB0aGlzLm1lc3NhZ2U7XG5cblx0cmV0dXJuIChzdHIpO1xufTtcblxuLypcbiAqIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGZvciBjb21wYXRpYmlsaXR5LiAgTmV3IGNhbGxlcnMgc2hvdWxkIHVzZVxuICogVkVycm9yLmNhdXNlKCkgaW5zdGVhZC4gIFRoYXQgbWV0aG9kIGFsc28gdXNlcyB0aGUgc2FuZXIgYG51bGxgIHJldHVybiB2YWx1ZVxuICogd2hlbiB0aGVyZSBpcyBubyBjYXVzZS5cbiAqL1xuVkVycm9yLnByb3RvdHlwZS5jYXVzZSA9IGZ1bmN0aW9uIHZlX2NhdXNlKClcbntcblx0dmFyIGNhdXNlID0gVkVycm9yLmNhdXNlKHRoaXMpO1xuXHRyZXR1cm4gKGNhdXNlID09PSBudWxsID8gdW5kZWZpbmVkIDogY2F1c2UpO1xufTtcblxuLypcbiAqIFN0YXRpYyBtZXRob2RzXG4gKlxuICogVGhlc2UgY2xhc3MtbGV2ZWwgbWV0aG9kcyBhcmUgcHJvdmlkZWQgc28gdGhhdCBjYWxsZXJzIGNhbiB1c2UgdGhlbSBvblxuICogaW5zdGFuY2VzIG9mIEVycm9ycyB0aGF0IGFyZSBub3QgVkVycm9ycy4gIE5ldyBpbnRlcmZhY2VzIHNob3VsZCBiZSBwcm92aWRlZFxuICogb25seSB1c2luZyBzdGF0aWMgbWV0aG9kcyB0byBlbGltaW5hdGUgdGhlIGNsYXNzIG9mIHByb2dyYW1taW5nIG1pc3Rha2Ugd2hlcmVcbiAqIHBlb3BsZSBmYWlsIHRvIGNoZWNrIHdoZXRoZXIgdGhlIEVycm9yIG9iamVjdCBoYXMgdGhlIGNvcnJlc3BvbmRpbmcgbWV0aG9kcy5cbiAqL1xuXG5WRXJyb3IuY2F1c2UgPSBmdW5jdGlvbiAoZXJyKVxue1xuXHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihlcnIpLCAnZXJyIG11c3QgYmUgYW4gRXJyb3InKTtcblx0cmV0dXJuIChtb2RfaXNFcnJvcihlcnIuanNlX2NhdXNlKSA/IGVyci5qc2VfY2F1c2UgOiBudWxsKTtcbn07XG5cblZFcnJvci5pbmZvID0gZnVuY3Rpb24gKGVycilcbntcblx0dmFyIHJ2LCBjYXVzZSwgaztcblxuXHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihlcnIpLCAnZXJyIG11c3QgYmUgYW4gRXJyb3InKTtcblx0Y2F1c2UgPSBWRXJyb3IuY2F1c2UoZXJyKTtcblx0aWYgKGNhdXNlICE9PSBudWxsKSB7XG5cdFx0cnYgPSBWRXJyb3IuaW5mbyhjYXVzZSk7XG5cdH0gZWxzZSB7XG5cdFx0cnYgPSB7fTtcblx0fVxuXG5cdGlmICh0eXBlb2YgKGVyci5qc2VfaW5mbykgPT0gJ29iamVjdCcgJiYgZXJyLmpzZV9pbmZvICE9PSBudWxsKSB7XG5cdFx0Zm9yIChrIGluIGVyci5qc2VfaW5mbykge1xuXHRcdFx0cnZba10gPSBlcnIuanNlX2luZm9ba107XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIChydik7XG59O1xuXG5WRXJyb3IuZmluZENhdXNlQnlOYW1lID0gZnVuY3Rpb24gKGVyciwgbmFtZSlcbntcblx0dmFyIGNhdXNlO1xuXG5cdG1vZF9hc3NlcnRwbHVzLm9rKG1vZF9pc0Vycm9yKGVyciksICdlcnIgbXVzdCBiZSBhbiBFcnJvcicpO1xuXHRtb2RfYXNzZXJ0cGx1cy5zdHJpbmcobmFtZSwgJ25hbWUnKTtcblx0bW9kX2Fzc2VydHBsdXMub2sobmFtZS5sZW5ndGggPiAwLCAnbmFtZSBjYW5ub3QgYmUgZW1wdHknKTtcblxuXHRmb3IgKGNhdXNlID0gZXJyOyBjYXVzZSAhPT0gbnVsbDsgY2F1c2UgPSBWRXJyb3IuY2F1c2UoY2F1c2UpKSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoY2F1c2UpKTtcblx0XHRpZiAoY2F1c2UubmFtZSA9PSBuYW1lKSB7XG5cdFx0XHRyZXR1cm4gKGNhdXNlKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gKG51bGwpO1xufTtcblxuVkVycm9yLmhhc0NhdXNlV2l0aE5hbWUgPSBmdW5jdGlvbiAoZXJyLCBuYW1lKVxue1xuXHRyZXR1cm4gKFZFcnJvci5maW5kQ2F1c2VCeU5hbWUoZXJyLCBuYW1lKSAhPT0gbnVsbCk7XG59O1xuXG5WRXJyb3IuZnVsbFN0YWNrID0gZnVuY3Rpb24gKGVycilcbntcblx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoZXJyKSwgJ2VyciBtdXN0IGJlIGFuIEVycm9yJyk7XG5cblx0dmFyIGNhdXNlID0gVkVycm9yLmNhdXNlKGVycik7XG5cblx0aWYgKGNhdXNlKSB7XG5cdFx0cmV0dXJuIChlcnIuc3RhY2sgKyAnXFxuY2F1c2VkIGJ5OiAnICsgVkVycm9yLmZ1bGxTdGFjayhjYXVzZSkpO1xuXHR9XG5cblx0cmV0dXJuIChlcnIuc3RhY2spO1xufTtcblxuVkVycm9yLmVycm9yRnJvbUxpc3QgPSBmdW5jdGlvbiAoZXJyb3JzKVxue1xuXHRtb2RfYXNzZXJ0cGx1cy5hcnJheU9mT2JqZWN0KGVycm9ycywgJ2Vycm9ycycpO1xuXG5cdGlmIChlcnJvcnMubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIChudWxsKTtcblx0fVxuXG5cdGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoZSkpO1xuXHR9KTtcblxuXHRpZiAoZXJyb3JzLmxlbmd0aCA9PSAxKSB7XG5cdFx0cmV0dXJuIChlcnJvcnNbMF0pO1xuXHR9XG5cblx0cmV0dXJuIChuZXcgTXVsdGlFcnJvcihlcnJvcnMpKTtcbn07XG5cblZFcnJvci5lcnJvckZvckVhY2ggPSBmdW5jdGlvbiAoZXJyLCBmdW5jKVxue1xuXHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihlcnIpLCAnZXJyIG11c3QgYmUgYW4gRXJyb3InKTtcblx0bW9kX2Fzc2VydHBsdXMuZnVuYyhmdW5jLCAnZnVuYycpO1xuXG5cdGlmIChlcnIgaW5zdGFuY2VvZiBNdWx0aUVycm9yKSB7XG5cdFx0ZXJyLmVycm9ycygpLmZvckVhY2goZnVuY3Rpb24gaXRlckVycm9yKGUpIHsgZnVuYyhlKTsgfSk7XG5cdH0gZWxzZSB7XG5cdFx0ZnVuYyhlcnIpO1xuXHR9XG59O1xuXG5cbi8qXG4gKiBTRXJyb3IgaXMgbGlrZSBWRXJyb3IsIGJ1dCBzdHJpY3RlciBhYm91dCB0eXBlcy4gIFlvdSBjYW5ub3QgcGFzcyBcIm51bGxcIiBvclxuICogXCJ1bmRlZmluZWRcIiBhcyBzdHJpbmcgYXJndW1lbnRzIHRvIHRoZSBmb3JtYXR0ZXIuXG4gKi9cbmZ1bmN0aW9uIFNFcnJvcigpXG57XG5cdHZhciBhcmdzLCBvYmosIHBhcnNlZCwgb3B0aW9ucztcblxuXHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFNFcnJvcikpIHtcblx0XHRvYmogPSBPYmplY3QuY3JlYXRlKFNFcnJvci5wcm90b3R5cGUpO1xuXHRcdFNFcnJvci5hcHBseShvYmosIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIChvYmopO1xuXHR9XG5cblx0cGFyc2VkID0gcGFyc2VDb25zdHJ1Y3RvckFyZ3VtZW50cyh7XG5cdCAgICAnYXJndic6IGFyZ3MsXG5cdCAgICAnc3RyaWN0JzogdHJ1ZVxuXHR9KTtcblxuXHRvcHRpb25zID0gcGFyc2VkLm9wdGlvbnM7XG5cdFZFcnJvci5jYWxsKHRoaXMsIG9wdGlvbnMsICclcycsIHBhcnNlZC5zaG9ydG1lc3NhZ2UpO1xuXG5cdHJldHVybiAodGhpcyk7XG59XG5cbi8qXG4gKiBXZSBkb24ndCBib3RoZXIgc2V0dGluZyBTRXJyb3IucHJvdG90eXBlLm5hbWUgYmVjYXVzZSBvbmNlIGNvbnN0cnVjdGVkLFxuICogU0Vycm9ycyBhcmUganVzdCBsaWtlIFZFcnJvcnMuXG4gKi9cbm1vZF91dGlsLmluaGVyaXRzKFNFcnJvciwgVkVycm9yKTtcblxuXG4vKlxuICogUmVwcmVzZW50cyBhIGNvbGxlY3Rpb24gb2YgZXJyb3JzIGZvciB0aGUgcHVycG9zZSBvZiBjb25zdW1lcnMgdGhhdCBnZW5lcmFsbHlcbiAqIG9ubHkgZGVhbCB3aXRoIG9uZSBlcnJvci4gIENhbGxlcnMgY2FuIGV4dHJhY3QgdGhlIGluZGl2aWR1YWwgZXJyb3JzXG4gKiBjb250YWluZWQgaW4gdGhpcyBvYmplY3QsIGJ1dCBtYXkgYWxzbyBqdXN0IHRyZWF0IGl0IGFzIGEgbm9ybWFsIHNpbmdsZVxuICogZXJyb3IsIGluIHdoaWNoIGNhc2UgYSBzdW1tYXJ5IG1lc3NhZ2Ugd2lsbCBiZSBwcmludGVkLlxuICovXG5mdW5jdGlvbiBNdWx0aUVycm9yKGVycm9ycylcbntcblx0bW9kX2Fzc2VydHBsdXMuYXJyYXkoZXJyb3JzLCAnbGlzdCBvZiBlcnJvcnMnKTtcblx0bW9kX2Fzc2VydHBsdXMub2soZXJyb3JzLmxlbmd0aCA+IDAsICdtdXN0IGJlIGF0IGxlYXN0IG9uZSBlcnJvcicpO1xuXHR0aGlzLmFzZV9lcnJvcnMgPSBlcnJvcnM7XG5cblx0VkVycm9yLmNhbGwodGhpcywge1xuXHQgICAgJ2NhdXNlJzogZXJyb3JzWzBdXG5cdH0sICdmaXJzdCBvZiAlZCBlcnJvciVzJywgZXJyb3JzLmxlbmd0aCwgZXJyb3JzLmxlbmd0aCA9PSAxID8gJycgOiAncycpO1xufVxuXG5tb2RfdXRpbC5pbmhlcml0cyhNdWx0aUVycm9yLCBWRXJyb3IpO1xuTXVsdGlFcnJvci5wcm90b3R5cGUubmFtZSA9ICdNdWx0aUVycm9yJztcblxuTXVsdGlFcnJvci5wcm90b3R5cGUuZXJyb3JzID0gZnVuY3Rpb24gbWVfZXJyb3JzKClcbntcblx0cmV0dXJuICh0aGlzLmFzZV9lcnJvcnMuc2xpY2UoMCkpO1xufTtcblxuXG4vKlxuICogU2VlIFJFQURNRS5tZCBmb3IgcmVmZXJlbmNlIGRldGFpbHMuXG4gKi9cbmZ1bmN0aW9uIFdFcnJvcigpXG57XG5cdHZhciBhcmdzLCBvYmosIHBhcnNlZCwgb3B0aW9ucztcblxuXHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFdFcnJvcikpIHtcblx0XHRvYmogPSBPYmplY3QuY3JlYXRlKFdFcnJvci5wcm90b3R5cGUpO1xuXHRcdFdFcnJvci5hcHBseShvYmosIGFyZ3MpO1xuXHRcdHJldHVybiAob2JqKTtcblx0fVxuXG5cdHBhcnNlZCA9IHBhcnNlQ29uc3RydWN0b3JBcmd1bWVudHMoe1xuXHQgICAgJ2FyZ3YnOiBhcmdzLFxuXHQgICAgJ3N0cmljdCc6IGZhbHNlXG5cdH0pO1xuXG5cdG9wdGlvbnMgPSBwYXJzZWQub3B0aW9ucztcblx0b3B0aW9uc1snc2tpcENhdXNlTWVzc2FnZSddID0gdHJ1ZTtcblx0VkVycm9yLmNhbGwodGhpcywgb3B0aW9ucywgJyVzJywgcGFyc2VkLnNob3J0bWVzc2FnZSk7XG5cblx0cmV0dXJuICh0aGlzKTtcbn1cblxubW9kX3V0aWwuaW5oZXJpdHMoV0Vycm9yLCBWRXJyb3IpO1xuV0Vycm9yLnByb3RvdHlwZS5uYW1lID0gJ1dFcnJvcic7XG5cbldFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB3ZV90b1N0cmluZygpXG57XG5cdHZhciBzdHIgPSAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnbmFtZScpICYmIHRoaXMubmFtZSB8fFxuXHRcdHRoaXMuY29uc3RydWN0b3IubmFtZSB8fCB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5uYW1lKTtcblx0aWYgKHRoaXMubWVzc2FnZSlcblx0XHRzdHIgKz0gJzogJyArIHRoaXMubWVzc2FnZTtcblx0aWYgKHRoaXMuanNlX2NhdXNlICYmIHRoaXMuanNlX2NhdXNlLm1lc3NhZ2UpXG5cdFx0c3RyICs9ICc7IGNhdXNlZCBieSAnICsgdGhpcy5qc2VfY2F1c2UudG9TdHJpbmcoKTtcblxuXHRyZXR1cm4gKHN0cik7XG59O1xuXG4vKlxuICogRm9yIHB1cmVseSBoaXN0b3JpY2FsIHJlYXNvbnMsIFdFcnJvcidzIGNhdXNlKCkgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXRcbiAqIHRoZSBjYXVzZS5cbiAqL1xuV0Vycm9yLnByb3RvdHlwZS5jYXVzZSA9IGZ1bmN0aW9uIHdlX2NhdXNlKGMpXG57XG5cdGlmIChtb2RfaXNFcnJvcihjKSlcblx0XHR0aGlzLmpzZV9jYXVzZSA9IGM7XG5cblx0cmV0dXJuICh0aGlzLmpzZV9jYXVzZSk7XG59O1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vY2xpZW50JykoKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHt9OyIsImNvbnN0IG1lcmdlID0gcmVxdWlyZSgnbG9kYXNoL21lcmdlJyk7XG5jb25zdCBmZXRjaCA9IHJlcXVpcmUoJ25vZGUtZmV0Y2gnKTtcbmNvbnN0IEZvcm1EYXRhID0gcmVxdWlyZSgnZm9ybS1kYXRhJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBtcyA9IHJlcXVpcmUoJ21zJyk7XG5jb25zdCBMb2dnZXJDb25zb2xlID0gcmVxdWlyZSgnLi9sb2dnZXIvdHJhbnNwb3J0cy9jb25zb2xlJykoKTtcbmNvbnN0IFRhc2tJbnRlcnZhbCA9IHJlcXVpcmUoJy4vdGFzay90cmFuc3BvcnRzL2ludGVydmFsJykoKTtcbmNvbnN0IFNlcnZpY2UgPSByZXF1aXJlKCcuL3NlcnZpY2UnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChQYXJlbnQpID0+IHtcbiAgLyoqXG4gICAqIENsYXNzIHRvIG1hbmFnZSBjbGllbnQgcmVxdWVzdHMgdG8gdGhlIG5ldHdvcmtcbiAgICovXG4gIHJldHVybiBjbGFzcyBDbGllbnQgZXh0ZW5kcyAoUGFyZW50IHx8IFNlcnZpY2UpIHtcbiAgICBzdGF0aWMgZ2V0IExvZ2dlclRyYW5zcG9ydCAoKSB7IHJldHVybiBMb2dnZXJDb25zb2xlIH1cbiAgICBzdGF0aWMgZ2V0IFRhc2tUcmFuc3BvcnQgKCkgeyByZXR1cm4gVGFza0ludGVydmFsIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IG9wdGlvbnMuYWRkcmVzc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcblxuICAgICAgaWYoIW9wdGlvbnMuYWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHBhc3MgdGhlIG5vZGUgYWRkcmVzcyBpbiBcImlwOnBvcnRcIiBmb3JtYXQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zID0gbWVyZ2Uoe1xuICAgICAgICByZXF1ZXN0OiB7XG4gICAgICAgICAgcGluZ1RpbWVvdXQ6ICcxcycsXG4gICAgICAgICAgY2xpZW50VGltZW91dDogJzhzJ1xuICAgICAgICB9LFxuICAgICAgICBzZWNyZXRLZXk6ICcnLFxuICAgICAgICBodHRwczogZmFsc2UsXG4gICAgICAgIGxvZ2dlcjoge1xuICAgICAgICAgIGxldmVsOiAnaW5mbydcbiAgICAgICAgfSxcbiAgICAgICAgdGFzazoge1xuICAgICAgICAgIHdvcmtlckNoYW5nZUludGVydmFsOiAnMzBzJ1xuICAgICAgICB9XG4gICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgIXRoaXMub3B0aW9ucy5sb2dnZXIgJiYgKHRoaXMub3B0aW9ucy5sb2dnZXIgPSB7IGxldmVsOiBmYWxzZSB9KTtcbiAgICAgIHRoaXMuTG9nZ2VyVHJhbnNwb3J0ID0gdGhpcy5jb25zdHJ1Y3Rvci5Mb2dnZXJUcmFuc3BvcnQ7XG4gICAgICB0aGlzLlRhc2tUcmFuc3BvcnQgPSB0aGlzLmNvbnN0cnVjdG9yLlRhc2tUcmFuc3BvcnQ7XG4gICAgICB0aGlzLmFkZHJlc3MgPSBvcHRpb25zLmFkZHJlc3M7XG4gICAgICB0aGlzLnByZXBhcmVPcHRpb25zKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgY2xpZW50XG4gICAgICogXG4gICAgICogQGFzeW5jXG4gICAgICovXG4gICAgYXN5bmMgaW5pdCgpIHtcbiAgICAgIGF3YWl0IHRoaXMucHJlcGFyZVNlcnZpY2VzKCk7XG4gICAgICBhd2FpdCB0aGlzLmluaXRTZXJ2aWNlcygpO1xuICAgICAgY29uc3QgYWRkcmVzc2VzID0gQXJyYXkuaXNBcnJheSh0aGlzLmFkZHJlc3MpPyB0aGlzLmFkZHJlc3M6IFt0aGlzLmFkZHJlc3NdO1xuICAgICAgY29uc3QgYXZhaWxhYmxlQWRkcmVzcyA9IGF3YWl0IHRoaXMuZ2V0QXZhaWxhYmxlQWRkcmVzcyhhZGRyZXNzZXMpO1xuICAgICAgXG4gICAgICBpZighYXZhaWxhYmxlQWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIGFkZHJlc3NlcyBhcmUgbm90IGF2YWlsYWJsZScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLndvcmtlckFkZHJlc3MgPSBhdmFpbGFibGVBZGRyZXNzO1xuICAgICAgYXdhaXQgdGhpcy5jaGFuZ2VXb3JrZXIoKTtcbiAgICAgIHN1cGVyLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWluaXRpYWxpemUgdGhlIGNsaWVudFxuICAgICAqIFxuICAgICAqIEBhc3luY1xuICAgICAqL1xuICAgIGFzeW5jIGRlaW5pdCgpIHtcbiAgICAgIGF3YWl0IHRoaXMuZGVpbml0U2VydmljZXMoKTtcbiAgICAgIHN1cGVyLmRlaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIHNlcnZpY2VzXG4gICAgICogXG4gICAgICogQGFzeW5jXG4gICAgICovXG4gICAgYXN5bmMgcHJlcGFyZVNlcnZpY2VzKCkge1xuICAgICAgdGhpcy5sb2dnZXIgPSBuZXcgdGhpcy5Mb2dnZXJUcmFuc3BvcnQodGhpcywgdGhpcy5vcHRpb25zLmxvZ2dlcik7XG4gICAgICB0aGlzLm9wdGlvbnMudGFzayAmJiAodGhpcy50YXNrID0gbmV3IHRoaXMuVGFza1RyYW5zcG9ydCh0aGlzLCB0aGlzLm9wdGlvbnMudGFzaykpO1xuXG4gICAgICBpZighdGhpcy50YXNrKSB7XG4gICAgICAgIHJldHVybjsgICAgICAgIFxuICAgICAgfVxuXG4gICAgICBpZih0aGlzLm9wdGlvbnMudGFzay53b3JrZXJDaGFuZ2VJbnRlcnZhbCkge1xuICAgICAgICBhd2FpdCB0aGlzLnRhc2suYWRkKCd3b3JrZXJDaGFuZ2UnLCB0aGlzLm9wdGlvbnMudGFzay53b3JrZXJDaGFuZ2VJbnRlcnZhbCwgKCkgPT4gdGhpcy5jaGFuZ2VXb3JrZXIoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgc2VydmljZXNcbiAgICAgKiBcbiAgICAgKiBAYXN5bmNcbiAgICAgKi9cbiAgICBhc3luYyBpbml0U2VydmljZXMoKSB7XG4gICAgICBhd2FpdCB0aGlzLmxvZ2dlci5pbml0KCk7XG4gICAgICB0aGlzLnRhc2sgJiYgYXdhaXQgdGhpcy50YXNrLmluaXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWluaXRpYWxpemUgdGhlIHNlcnZpY2VzXG4gICAgICogXG4gICAgICogQGFzeW5jXG4gICAgICovXG4gICAgYXN5bmMgZGVpbml0U2VydmljZXMoKSB7XG4gICAgICB0aGlzLnRhc2sgJiYgYXdhaXQgdGhpcy50YXNrLmRlaW5pdCgpO1xuICAgICAgYXdhaXQgdGhpcy5sb2dnZXIuZGVpbml0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFuIGF2YWlsYWJsZSBhZGRyZXNzIGZyb20gdGhlIGxpc3RcbiAgICAgKiBcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhZGRyZXNzZXNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEF2YWlsYWJsZUFkZHJlc3MoYWRkcmVzc2VzKSB7XG4gICAgICBsZXQgYXZhaWxhYmxlQWRkcmVzcztcblxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGFkZHJlc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYWRkcmVzc2VzW2ldO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBmZXRjaChgJHt0aGlzLmdldFJlcXVlc3RQcm90b2NvbCgpfTovLyR7YWRkcmVzc30vcGluZ2AsIHRoaXMuY3JlYXRlRGVmYXVsdFJlcXVlc3RPcHRpb25zKHsgXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgdGltZW91dDogdGhpcy5vcHRpb25zLnJlcXVlc3QucGluZ1RpbWVvdXRcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgYXZhaWxhYmxlQWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihlcnIuc3RhY2spO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhdmFpbGFibGVBZGRyZXNzIHx8IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSB3b3JrZXIgYWRkcmVzc1xuICAgICAqIFxuICAgICAqIEBhc3luY1xuICAgICAqL1xuICAgIGFzeW5jIGNoYW5nZVdvcmtlcigpIHtcbiAgICAgIGNvbnN0IGxhc3RBZGRyZXNzID0gdGhpcy53b3JrZXJBZGRyZXNzO1xuXG4gICAgICBjb25zdCBhZGRyZXNzID0gKGF3YWl0IHRoaXMucmVxdWVzdCgnZ2V0LWF2YWlsYWJsZS1ub2RlJywge1xuICAgICAgICB1c2VJbml0aWFsQWRkcmVzczogdHJ1ZVxuICAgICAgfSkpLmFkZHJlc3M7XG5cbiAgICAgIGlmKGFkZHJlc3MgPT0gbGFzdEFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZXRjaChgJHt0aGlzLmdldFJlcXVlc3RQcm90b2NvbCgpfTovLyR7YWRkcmVzc30vcGluZ2AsIHRoaXMuY3JlYXRlRGVmYXVsdFJlcXVlc3RPcHRpb25zKHsgXG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICB0aW1lb3V0OiB0aGlzLm9wdGlvbnMucmVxdWVzdC5waW5nVGltZW91dFxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMud29ya2VyQWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICB9XG4gICAgICBjYXRjaChlcnIpIHsgICAgICAgIFxuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGVyci5zdGFjayk7XG4gICAgICAgIHRoaXMud29ya2VyQWRkcmVzcyA9IGxhc3RBZGRyZXNzO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2UgYSByZXF1ZXN0IHRvIHRoZSBhcGlcbiAgICAgKiBcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5kcG9pbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0KGVuZHBvaW50LCBvcHRpb25zID0ge30pIHtcbiAgICAgIG9wdGlvbnMgPSBtZXJnZSh0aGlzLmNyZWF0ZURlZmF1bHRSZXF1ZXN0T3B0aW9ucygpLCBvcHRpb25zKTtcbiAgICAgIGxldCBib2R5ID0gb3B0aW9ucy5mb3JtRGF0YSB8fCBvcHRpb25zLmJvZHkgfHwge307XG4gICAgICBib2R5LnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICBib2R5LnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cbiAgICAgIGlmKG9wdGlvbnMuZm9ybURhdGEpIHtcbiAgICAgICAgY29uc3QgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICAgIGZvcihsZXQga2V5IGluIGJvZHkpIHtcbiAgICAgICAgICBsZXQgdmFsID0gYm9keVtrZXldO1xuXG4gICAgICAgICAgaWYodHlwZW9mIHZhbCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9ybS5hcHBlbmQoa2V5LCB2YWwudmFsdWUsIHZhbC5vcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3JtLmFwcGVuZChrZXksIHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy5ib2R5ID0gZm9ybTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuZm9ybURhdGE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgICB9IFxuICAgICAgXG4gICAgICBvcHRpb25zLnVybCA9IHRoaXMuY3JlYXRlUmVxdWVzdFVybChlbmRwb2ludCwgeyB1c2VJbml0aWFsQWRkcmVzczogb3B0aW9ucy51c2VJbml0aWFsQWRkcmVzcyB9KTtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcblxuICAgICAgdHJ5IHsgICAgICAgIFxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaChvcHRpb25zLnVybCwgb3B0aW9ucyk7ICAgIFxuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGBSZXF1ZXN0IHRvIFwiJHtvcHRpb25zLnVybH1cIjogJHttcyhEYXRlLm5vdygpIC0gc3RhcnQpfWApOyAgICBcbiAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3VsdC5qc29uKCk7XG5cbiAgICAgICAgaWYocmVzdWx0Lm9rKSB7XG4gICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighYm9keSB8fCB0eXBlb2YgYm9keSAhPSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihib2R5IHx8ICdVbmtub3duIGVycm9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighYm9keS5jb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGJvZHkubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuV29ya0Vycm9yKGJvZHkubWVzc2FnZSwgYm9keS5jb2RlKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoKGVycikge1xuICAgICAgICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leC1hc3NpZ25cbiAgICAgICAgdXRpbHMuaXNSZXF1ZXN0VGltZW91dEVycm9yKGVycikgJiYgKGVyciA9IHV0aWxzLmNyZWF0ZVJlcXVlc3RUaW1lb3V0RXJyb3IoKSk7XG4gICAgICAgIGVyci5yZXF1ZXN0T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBhcGkgcmVxdWVzdCB1cmxcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5kcG9pbnQgXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgXG4gICAgICovXG4gICAgY3JlYXRlUmVxdWVzdFVybChlbmRwb2ludCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICBjb25zdCBxdWVyeSA9IG9wdGlvbnMucXVlcnk/IHFzLnN0cmluZ2lmeShvcHRpb25zLnF1ZXJ5KTogbnVsbDtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBvcHRpb25zLnVzZUluaXRpYWxBZGRyZXNzPyB0aGlzLmFkZHJlc3M6IHRoaXMud29ya2VyQWRkcmVzcztcbiAgICAgIGxldCB1cmwgPSBgJHt0aGlzLmdldFJlcXVlc3RQcm90b2NvbCgpfTovLyR7YWRkcmVzc30vY2xpZW50LyR7ZW5kcG9pbnR9YDtcbiAgICAgIHF1ZXJ5ICYmICh1cmwgKz0gJz8nICsgcXVlcnkpO1xuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZGVmYXVsdCByZXF1ZXN0IG9wdGlvbnNcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlRGVmYXVsdFJlcXVlc3RPcHRpb25zKG9wdGlvbnMgPSB7fSkgeyAgICAgIFxuICAgICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICB0aW1lb3V0OiB0aGlzLm9wdGlvbnMucmVxdWVzdC5jbGllbnRUaW1lb3V0LFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ25ldHdvcmstc2VjcmV0LWtleSc6IHRoaXMub3B0aW9ucy5zZWNyZXRLZXkgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmKG9wdGlvbnMudGltZW91dCkge1xuICAgICAgICBvcHRpb25zLnRpbWVvdXQgPSB1dGlscy5nZXRNcyhvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgfVxuXG4gICAgICBpZih0eXBlb2YgdGhpcy5vcHRpb25zLmh0dHBzID09ICdvYmplY3QnICYmIHRoaXMub3B0aW9ucy5odHRwcy5jYSkge1xuICAgICAgICBvcHRpb25zLmFnZW50ID0gb3B0aW9ucy5hZ2VudCB8fCBuZXcgaHR0cHMuQWdlbnQoKTtcbiAgICAgICAgb3B0aW9ucy5hZ2VudC5vcHRpb25zLmNhID0gdGhpcy5vcHRpb25zLmh0dHBzLmNhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVyZ2Uoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSByZXF1ZXN0IHRpbWVyXG4gICAgICogXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGNyZWF0ZVJlcXVlc3RUaW1lcih0aW1lb3V0KSB7XG4gICAgICByZXR1cm4gdXRpbHMuZ2V0UmVxdWVzdFRpbWVyKHRpbWVvdXQsIHsgbWluOiB0aGlzLm9wdGlvbnMucmVxdWVzdC5waW5nVGltZW91dCB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRoZSBvcHRpb25zXG4gICAgICovXG4gICAgcHJlcGFyZU9wdGlvbnMoKSB7ICAgIFxuICAgICAgdGhpcy5vcHRpb25zLnJlcXVlc3QuY2xpZW50VGltZW91dCA9IHV0aWxzLmdldE1zKHRoaXMub3B0aW9ucy5yZXF1ZXN0LmNsaWVudFRpbWVvdXQpOyAgICAgXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByZXF1ZXN0IHByb3RvY29sXG4gICAgICogXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRSZXF1ZXN0UHJvdG9jb2woKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmh0dHBzPyAnaHR0cHMnOiAnaHR0cCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIGVudmlyb25tZW50XG4gICAgICovXG4gICAgZW52VGVzdChpc0Jyb3dzZXIsIG5hbWUpIHtcbiAgICAgIGNvbnN0IGlzQnJvd3NlckVudiA9IHV0aWxzLmlzQnJvd3NlckVudigpO1xuICAgICAgXG4gICAgICBpZihpc0Jyb3dzZXIgJiYgIWlzQnJvd3NlckVudikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW4ndCB1c2UgXCIke25hbWV9XCIgbWV0aG9kIGluIHRoZSBub2RlanMgZW52aXJvbm1lbnRgKTtcbiAgICAgIH1cblxuICAgICAgaWYoIWlzQnJvd3NlciAmJiBpc0Jyb3dzZXJFbnYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2FuJ3QgdXNlIFwiJHtuYW1lfVwiIG1ldGhvZCBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudGApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTsiLCJtb2R1bGUuZXhwb3J0cy5Xb3JrRXJyb3IgPSBjbGFzcyBXb3JrRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5BY2Nlc3NFcnJvciA9IGNsYXNzIEFjY2Vzc0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gNDAzO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Ob3RGb3VuZEVycm9yID0gY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IDQwNDtcbiAgfVxufTtcbiIsImNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpKCk7XG5jb25zdCBjaGFsayA9IHJlcXVpcmUoJ2NoYWxrJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFBhcmVudCkgPT4ge1xuICAvKipcbiAgICogQ29uc29sZSBsb2dnZXIgdHJhbnNwb3J0XG4gICAqL1xuICByZXR1cm4gY2xhc3MgTG9nZ2VyQ29uc29sZSBleHRlbmRzIChQYXJlbnQgfHwgTG9nZ2VyKSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuXG4gICAgICB0aGlzLmNvbG9ycyA9IHtcbiAgICAgICAgaW5mbzogJ3doaXRlJyxcbiAgICAgICAgd2FybjogJ3llbGxvdycsXG4gICAgICAgIGVycm9yOiAncmVkJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIExvZ2dlci5wcm90b3R5cGUubG9nXG4gICAgICovXG4gICAgYXN5bmMgbG9nKGxldmVsLCAuLi5hcmdzKSB7XG4gICAgICBpZih0aGlzLmlzTGV2ZWxBY3RpdmUobGV2ZWwpKSB7ICAgXG4gICAgICAgIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZVtsZXZlbF0uYXBwbHkoY29uc29sZVtsZXZlbF0sIHV0aWxzLmlzQnJvd3NlckVudigpPyBhcmdzOiBhcmdzLm1hcChhcmcgPT4ge1xuICAgICAgICAgIGFyZyAmJiB0eXBlb2YgYXJnID09ICdvYmplY3QnICYmIChhcmcgPSBKU09OLnN0cmluZ2lmeShhcmcpKTtcbiAgICAgICAgICByZXR1cm4gY2hhbGtbdGhpcy5jb2xvcnNbbGV2ZWxdXShhcmcpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59OyIsImNvbnN0IFNlcnZpY2UgPSByZXF1aXJlKCcuLi8uLi8uLi9zZXJ2aWNlJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoUGFyZW50KSA9PiB7XG4gIC8qKlxuICAgKiBMb2dnZXIgdHJhbnNwb3J0IGludGVyZmFjZVxuICAgKi9cbiAgcmV0dXJuIGNsYXNzIExvZ2dlciBleHRlbmRzIChQYXJlbnQgfHwgU2VydmljZSkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBvcHRpb25zID0ge30pIHtcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczsgICAgXG4gICAgICB0aGlzLmxldmVscyA9IFsnaW5mbycsICd3YXJuJywgJ2Vycm9yJ107XG4gICAgICB0aGlzLmRlZmF1bHRMZXZlbCA9ICdpbmZvJztcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgbG9nZ2VyXG4gICAgICogXG4gICAgICogQGFzeW5jXG4gICAgICovXG4gICAgYXN5bmMgaW5pdCgpIHtcbiAgICAgIHRoaXMuc2V0TGV2ZWwodGhpcy5vcHRpb25zLmxldmVsID09PSB1bmRlZmluZWQ/IHRoaXMuZGVmYXVsdExldmVsOiB0aGlzLm9wdGlvbnMubGV2ZWwpO1xuICAgICAgYXdhaXQgc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8qKiBcbiAgICAgKiBEZWluaXRpYWxpemUgdGhlIGxvZ2dlclxuICAgICAqIFxuICAgICAqIEBhc3luY1xuICAgICAqL1xuICAgIGFzeW5jIGRlaW5pdCgpIHtcbiAgICAgIHRoaXMuc2V0TGV2ZWwoZmFsc2UpO1xuICAgICAgYXdhaXQgc3VwZXIuZGVpbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIExvZyBieSBsZXZlbHNcbiAgICAgKiBcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGV2ZWxcbiAgICAgKi9cbiAgICBhc3luYyBsb2coKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBcImxvZ1wiIGlzIHJlcXVpcmVkIGZvciBsb2dnZXIgdHJhbnNwb3J0Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9nIGluZm9cbiAgICAgKiBcbiAgICAgKiBAYXN5bmNcbiAgICAgKi9cbiAgICBhc3luYyBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgIGF3YWl0IHRoaXMubG9nKCdpbmZvJywgLi4uYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9nIGEgd2FybmluZ1xuICAgICAqIFxuICAgICAqIEBhc3luY1xuICAgICAqL1xuICAgIGFzeW5jIHdhcm4oLi4uYXJncykge1xuICAgICAgYXdhaXQgdGhpcy5sb2coJ3dhcm4nLCAuLi5hcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2cgYW4gZXJyb3JcbiAgICAgKiBcbiAgICAgKiBAYXN5bmNcbiAgICAgKi9cbiAgICBhc3luYyBlcnJvciguLi5hcmdzKSB7XG4gICAgICBhd2FpdCB0aGlzLmxvZygnZXJyb3InLCAuLi5hcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGUgbG9nIGxldmVsIGlzIGFjdGl2ZVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZXZlbFxuICAgICAqL1xuICAgIGlzTGV2ZWxBY3RpdmUobGV2ZWwpIHsgXG4gICAgICBpZighdGhpcy5sZXZlbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzLmxldmVscy5pbmRleE9mKGxldmVsKSA+PSB0aGlzLmxldmVscy5pbmRleE9mKHRoaXMubGV2ZWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBhY3RpdmUgbGV2ZWxcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGV2ZWxcbiAgICAgKi9cbiAgICBzZXRMZXZlbChsZXZlbCkge1xuICAgICAgaWYobGV2ZWwgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxldmVsID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMubGV2ZWxzLmluZGV4T2YobGV2ZWwpID09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgbG9nZ2VyIGxldmVsIFwiJHtsZXZlbH1cImApO1xuICAgICAgfSAgICBcblxuICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIH1cbiAgfVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9ICgpID0+IHtcbiAgLyoqXG4gICAqIFRoZSBzZXJ2aWNlIGNsYXNzXG4gICAqL1xuICByZXR1cm4gY2xhc3MgU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgc2VydmljZVxuICAgICAqIFxuICAgICAqIEBhc3luY1xuICAgICAqL1xuICAgIGFzeW5jIGluaXQoKSB7XG4gICAgICB0aGlzLl9faW5pdGlhbGl6ZWQgPSBEYXRlLm5vdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlaW5pdGlhbGl6ZSB0aGUgc2VydmljZVxuICAgICAqIFxuICAgICAqIEBhc3luY1xuICAgICAqL1xuICAgIGFzeW5jIGRlaW5pdCgpIHtcbiAgICAgIHRoaXMuX19pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIHNlcnZpY2VcbiAgICAgKiBcbiAgICAgKiBAYXN5bmNcbiAgICAgKi9cbiAgICBhc3luYyBkZXN0cm95KCkge1xuICAgICAgdGhpcy5fX2Rlc3Ryb3lpbmcgPSB0cnVlO1xuICAgICAgYXdhaXQgdGhpcy5kZWluaXQoKTtcbiAgICAgIHRoaXMuX19kZXN0cm95aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIHNlcnZpY2UgaXMgaW5pdGlhbGl6ZWRcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0luaXRpYWxpemVkKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fX2luaXRpYWxpemVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoZSBzZXJ2aWNlIGlzIGRlc3Ryb3lpbmdcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0Rlc3Ryb3lpbmcoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl9fZGVzdHJveWluZztcbiAgICB9XG4gIH1cbn07IiwiY29uc3QgVGFzayA9IHJlcXVpcmUoJy4uL3Rhc2snKSgpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChQYXJlbnQpID0+IHtcbiAgLyoqXG4gICAqIEludGVydmFsIHRhc2tzIHRyYW5zcG9ydFxuICAgKi9cbiAgcmV0dXJuIGNsYXNzIFRhc2tJbnRlcnZhbCBleHRlbmRzIChQYXJlbnQgfHwgVGFzaykge1xuICAgIC8qKlxuICAgICAqIEBzZWUgVGFzay5wcm90b3R5cGUuYWRkXG4gICAgICovXG4gICAgYXN5bmMgYWRkKG5hbWUsIGludGVydmFsLCBmbiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHN1cGVyLmFkZChuYW1lLCB1dGlscy5nZXRNcyhpbnRlcnZhbCksIGZuLCBvcHRpb25zKTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQHNlZSBUYXNrLnByb3RvdHlwZS5zdGFydFxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0KHRhc2spIHtcbiAgICAgIGF3YWl0IHN1cGVyLnN0YXJ0KHRhc2spO1xuICAgICAgY29uc3Qgb2JqID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5ydW4odGFzayksIHRhc2suaW50ZXJ2YWwpO1xuICAgICAgdGFzay5pbnRlcnZhbE9iamVjdCA9IG9iajtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIFRhc2sucHJvdG90eXBlLnN0b3BcbiAgICAgKi9cbiAgICBhc3luYyBzdG9wKHRhc2spIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGFzay5pbnRlcnZhbE9iamVjdCk7XG4gICAgICBhd2FpdCBzdXBlci5zdG9wKHRhc2spO1xuICAgIH1cbiAgfSAgXG59OyIsImNvbnN0IG1lcmdlID0gcmVxdWlyZSgnbG9kYXNoL21lcmdlJyk7XG5jb25zdCBTZXJ2aWNlID0gcmVxdWlyZSgnLi4vLi4vLi4vc2VydmljZScpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFBhcmVudCkgPT4ge1xuICAvKipcbiAgICogVGFza3MgdHJhbnNwb3J0XG4gICAqL1xuICByZXR1cm4gY2xhc3MgVGFzayBleHRlbmRzIChQYXJlbnQgfHwgU2VydmljZSkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlKHtcbiAgICAgICAgc2hvd0NvbXBsZXRpb25Mb2dzOiB0cnVlLFxuICAgICAgICBzaG93RmFpbExvZ3M6IHRydWVcbiAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLnRhc2tzID0ge307XG4gICAgfSBcbiAgICBcbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHRhc2tcbiAgICAgKi9cbiAgICBhc3luYyBhZGQobmFtZSwgaW50ZXJ2YWwsIGZuLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCB0YXNrID0gbWVyZ2UoeyBcbiAgICAgICAgaW50ZXJ2YWwsXG4gICAgICAgIGZuLCBcbiAgICAgICAgbmFtZSxcbiAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICB0YXNrLmlzU3RvcHBlZCA9PT0gdW5kZWZpbmVkICYmICh0YXNrLmlzU3RvcHBlZCA9IHRydWUpO1xuICAgICAgdGhpcy50YXNrc1tuYW1lXSA9IHRhc2s7XG4gICAgICBcbiAgICAgIGlmKCF0YXNrLmlzU3RvcHBlZCkge1xuICAgICAgICBhd2FpdCB0aGlzLnN0b3AodGFzayk7XG4gICAgICAgIGF3YWl0IHRoaXMuc3RhcnQodGFzayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXNrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGFza1xuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFxuICAgICAqL1xuICAgIGFzeW5jIGdldChuYW1lKSB7XG4gICAgIHJldHVybiB0aGlzLnRhc2tzW25hbWVdIHx8IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSB0YXNrXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlKG5hbWUpIHtcbiAgICAgIGNvbnN0IHRhc2sgPSB0aGlzLnRhc2tzW25hbWVdO1xuXG4gICAgICBpZighdGFzaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgICF0YXNrLmlzU3RvcHBlZCAmJiBhd2FpdCB0aGlzLnN0b3AodGFzayk7XG4gICAgICBkZWxldGUgdGhpcy50YXNrc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSB0YXNrc1xuICAgICAqIFxuICAgICAqIEBhc3luY1xuICAgICAqL1xuICAgIGFzeW5jIGluaXQoKSB7XG4gICAgICB0aGlzLnN0YXJ0QWxsKCk7IFxuICAgICAgYXdhaXQgc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlaW5pdGlhbGl6ZSB0aGUgdGFza3NcbiAgICAgKiBcbiAgICAgKiBAYXN5bmNcbiAgICAgKi9cbiAgICBhc3luYyBkZWluaXQoKSB7XG4gICAgICB0aGlzLnN0b3BBbGwoKTtcbiAgICAgIGF3YWl0IHN1cGVyLmRlaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGFsbCB0YXNrc1xuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0QWxsKCkge1xuICAgICAgZm9yKGxldCBrZXkgaW4gdGhpcy50YXNrcykge1xuICAgICAgICBhd2FpdCB0aGlzLnN0YXJ0KHRoaXMudGFza3Nba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcCBhbGwgdGFza3NcbiAgICAgKiBcbiAgICAgKiBAYXN5bmNcbiAgICAgKi9cbiAgICBhc3luYyBzdG9wQWxsKCkge1xuICAgICAgZm9yKGxldCBrZXkgaW4gdGhpcy50YXNrcykge1xuICAgICAgICBhd2FpdCB0aGlzLnN0b3AodGhpcy50YXNrc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW4gdGhlIHRhc2sgY2FsbGJhY2tcbiAgICAgKiBcbiAgICAgKiBAYXN5bmNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGFza1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXNrLmludGVydmFsXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gdGFzay5mblxuICAgICAqL1xuICAgIGFzeW5jIHJ1bih0YXNrKSB7XG4gICAgICBpZih0YXNrLmlzU3RvcHBlZCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2hvd0ZhaWxMb2dzICYmIHRoaXMubm9kZS5sb2dnZXIud2FybihgVGFzayBcIiR7dGFzay5uYW1lfVwiIHNob3VsZCBiZSBzdGFydGVkIGF0IGZpcnN0YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYodGFzay5pc1J1bikge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2hvd0ZhaWxMb2dzICYmIHRoaXMubm9kZS5sb2dnZXIud2FybihgVGFzayBcIiR7dGFzay5uYW1lfVwiIGhhcyBibG9ja2luZyBvcGVyYXRpb25zYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGFzay5pc1J1biA9IHRydWU7XG5cbiAgICAgIHRyeSB7ICAgICAgICBcbiAgICAgICAgYXdhaXQgdGFzay5mbigpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2hvd0NvbXBsZXRpb25Mb2dzICYmIHRoaXMubm9kZS5sb2dnZXIuaW5mbyhgVGFzayBcIiR7dGFzay5uYW1lfVwiIGhhcyBiZWVuIGNvbXBsZXRlZGApO1xuICAgICAgfVxuICAgICAgY2F0Y2goZXJyKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zaG93RmFpbExvZ3MgJiYgdGhpcy5ub2RlLmxvZ2dlci5lcnJvcihgVGFzayBcIiR7dGFzay5uYW1lfVwiLGAsIGVyci5zdGFjayk7XG4gICAgICB9XG5cbiAgICAgIHRhc2suaXNSdW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUgdGFza1xuICAgICAqIFxuICAgICAqIEBhc3luY1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0YXNrXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRhc2suaW50ZXJ2YWxcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0YXNrLmZuXG4gICAgICovXG4gICAgYXN5bmMgc3RhcnQodGFzaykge1xuICAgICAgdGFzay5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSB0YXNrXG4gICAgICogXG4gICAgICogQGFzeW5jXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRhc2tcbiAgICAgKi9cbiAgICBhc3luYyBzdG9wKHRhc2spIHtcbiAgICAgIHRhc2suaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07IiwiY29uc3QgdmFsaWRhdGVJUCA9IHJlcXVpcmUoJ3ZhbGlkYXRlLWlwLW5vZGUnKTtcbmNvbnN0IGJ5dGVzID0gcmVxdWlyZSgnYnl0ZXMnKTtcbmNvbnN0IG1zID0gcmVxdWlyZSgnbXMnKTtcbmNvbnN0IGxvb2t1cCA9IHJlcXVpcmUoJ2xvb2t1cC1kbnMtY2FjaGUnKS5sb29rdXA7XG5jb25zdCB0Y3BQb3J0VXNlZCA9IHJlcXVpcmUoJ3RjcC1wb3J0LXVzZWQnKTtcbmNvbnN0IGlwNmFkZHIgPSByZXF1aXJlKCdpcDZhZGRyJyk7IFxuY29uc3QgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTsgXG5cbmNvbnN0IHV0aWxzID0ge1xuICBob3N0VmFsaWRhdGlvblJlZ2V4OiAvXigoW2EtekEtWjAtOV18W2EtekEtWjAtOV1bYS16QS1aMC05LV0qW2EtekEtWjAtOV0pXFwuKSooW0EtWmEtejAtOV18W0EtWmEtejAtOV1bQS1aYS16MC05LV0qW0EtWmEtejAtOV0pJC9cbn07XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIHNjaGVtYVxuICogXG4gKiBAcGFyYW0ge29iamVjdHxhcnJheXxzdHJpbmd9IHNjaGVtYVxuICogQHBhcmFtIHsqfSBkYXRhXG4gKi9cbnV0aWxzLnZhbGlkYXRlU2NoZW1hID0gZnVuY3Rpb24gKHNjaGVtYSwgZGF0YSkgeyAgXG4gIGlmKEFycmF5LmlzQXJyYXkoc2NoZW1hKSB8fCB0eXBlb2Ygc2NoZW1hICE9ICdvYmplY3QnKSB7XG4gICAgc2NoZW1hID0geyB0eXBlOiBzY2hlbWEgfTtcbiAgfVxuXG4gIGNvbnN0IGdldEh1bWFuRGF0YSA9ICgpID0+IEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpO1xuICBjb25zdCBnZXRIdW1hblNjaGVtYSA9ICgpID0+IEpTT04uc3RyaW5naWZ5KHNjaGVtYSwgbnVsbCwgMik7XG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBBcnJheS5pc0FycmF5KHNjaGVtYS50eXBlKT8gc2NoZW1hLnR5cGU6IFtzY2hlbWEudHlwZV07XG4gIGNvbnN0IGRhdGFUeXBlID0gQXJyYXkuaXNBcnJheShkYXRhKT8gJ2FycmF5JzogdHlwZW9mIGRhdGE7XG5cbiAgaWYoc2NoZW1hVHlwZS5pbmRleE9mKGRhdGFUeXBlKSA9PSAtMSkge1xuICAgIGNvbnN0IG1zZyA9IGBXcm9uZyBkYXRhIHR5cGUgXCIke2RhdGFUeXBlfVwiIGluc3RlYWQgb2YgXCIke3NjaGVtYVR5cGV9XCIgJHtnZXRIdW1hbkRhdGEoKX0gZm9yICR7Z2V0SHVtYW5TY2hlbWEoKX1gO1xuICAgIHRocm93IG5ldyBlcnJvcnMuV29ya0Vycm9yKG1zZywgJ0VSUl9TVE9SQUNMRV9WQUxJREFURV9TQ0hFTUFfV1JPTkdfREFUQV9UWVBFJyk7XG4gIH1cblxuICBpZihkYXRhVHlwZSA9PSAnYXJyYXknKSB7XG4gICAgY29uc3QgbWluTGVuZ3RoID0gdHlwZW9mIHNjaGVtYS5taW5MZW5ndGggPT0gJ2Z1bmN0aW9uJz8gbWluTGVuZ3RoKGRhdGEpOiBzY2hlbWEubWluTGVuZ3RoO1xuICAgIGNvbnN0IG1heExlbmd0aCA9IHR5cGVvZiBzY2hlbWEubWF4TGVuZ3RoID09ICdmdW5jdGlvbic/IG1heExlbmd0aChkYXRhKTogc2NoZW1hLm1heExlbmd0aDtcblxuICAgIGlmKG1pbkxlbmd0aCAmJiBkYXRhLmxlbmd0aCA8IG1pbkxlbmd0aCkge1xuICAgICAgY29uc3QgbXNnID0gYFdyb25nIGFycmF5IG1pbiBsZW5ndGggJHtnZXRIdW1hbkRhdGEoKX0gZm9yICR7Z2V0SHVtYW5TY2hlbWEoKX1gO1xuICAgICAgdGhyb3cgbmV3IGVycm9ycy5Xb3JrRXJyb3IobXNnLCAnRVJSX1NUT1JBQ0xFX1ZBTElEQVRFX1NDSEVNQV9XUk9OR19BUlJBWV9NSU5fTEVOR1RIJyk7XG4gICAgfVxuXG4gICAgaWYobWF4TGVuZ3RoICYmIGRhdGEubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICBjb25zdCBtc2cgPSBgV3JvbmcgYXJyYXkgbWF4IGxlbmd0aCAke2dldEh1bWFuRGF0YSgpfSBmb3IgJHtnZXRIdW1hblNjaGVtYSgpfWA7XG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLldvcmtFcnJvcihtc2csICdFUlJfU1RPUkFDTEVfVkFMSURBVEVfU0NIRU1BX1dST05HX0FSUkFZX01BWF9MRU5HVEgnKTtcbiAgICB9XG5cbiAgICBpZihzY2hlbWEuaXRlbXMpIHtcbiAgICAgIGRhdGEuZm9yRWFjaChpdGVtID0+IHRoaXMudmFsaWRhdGVTY2hlbWEoc2NoZW1hLml0ZW1zLCBpdGVtKSk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYoZGF0YVR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCBwcm9wcyA9IHNjaGVtYS5wcm9wcyB8fCB7fTtcbiAgICBjb25zdCByZXF1aXJlZCA9IHNjaGVtYS5yZXF1aXJlZDsgIFxuXG4gICAgaWYocmVxdWlyZWQgJiYgIUFycmF5LmlzQXJyYXkocmVxdWlyZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9wdGlvbiBcInJlcXVpcmVkXCIgZm9yICR7Z2V0SHVtYW5TY2hlbWEoKX0gbXVzdCBiZSBhbiBhcnJheWApO1xuICAgIH1cblxuICAgIGlmKHNjaGVtYS5jYW5CZU51bGwgJiYgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKHNjaGVtYS5jYW5CZU51bGwgPT09IGZhbHNlICYmIGRhdGEgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGBEYXRhIGZvciAke2dldEh1bWFuU2NoZW1hKCl9IGNhbid0IGJlIG51bGxgO1xuICAgICAgdGhyb3cgbmV3IGVycm9ycy5Xb3JrRXJyb3IobXNnLCAnRVJSX1NUT1JBQ0xFX1ZBTElEQVRFX1NDSEVNQV9OVUxMJyk7XG4gICAgfVxuICAgIFxuICAgIGlmKHNjaGVtYS5zdHJpY3QpIHtcbiAgICAgIGNvbnN0IHNjaGVtYUtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuc29ydCgpO1xuICAgICAgY29uc3QgZGF0YUtleXMgPSBPYmplY3Qua2V5cyhkYXRhKS5zb3J0KCk7XG5cbiAgICAgIGlmKHNjaGVtYUtleXMudG9TdHJpbmcoKSAhPSBkYXRhS2V5cy50b1N0cmluZygpKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBXcm9uZyBzdHJpY3Qgb2JqZWN0IHN0cnVjdHVyZSAke2dldEh1bWFuRGF0YSgpfSBmb3IgJHtnZXRIdW1hblNjaGVtYSgpfWA7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuV29ya0Vycm9yKG1zZywgJ0VSUl9TVE9SQUNMRV9WQUxJREFURV9TQ0hFTUFfU1RSSUNUJyk7XG4gICAgICB9ICAgICBcbiAgICB9XG5cbiAgICBpZihzY2hlbWEuZXhwZWN0ZWQpIHtcbiAgICAgIGZvcihsZXQga2V5IGluIGRhdGEpIHtcbiAgICAgICAgaWYoIXByb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBgV3JvbmcgZXhwZWN0ZWQgb2JqZWN0IHN0cnVjdHVyZSAke2dldEh1bWFuRGF0YSgpfSBmb3IgJHtnZXRIdW1hblNjaGVtYSgpfWA7XG4gICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5Xb3JrRXJyb3IobXNnLCAnRVJSX1NUT1JBQ0xFX1ZBTElEQVRFX1NDSEVNQV9FWFBFQ1RFRCcpO1xuICAgICAgICB9ICAgXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWlyZWRLZXlzID0ge307XG4gICAgcmVxdWlyZWQgJiYgcmVxdWlyZWQuZm9yRWFjaChpdGVtID0+IHJlcXVpcmVkS2V5c1tpdGVtXSA9IHRydWUpO1xuICAgIFxuICAgIGZvcihsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgaWYoIWRhdGEuaGFzT3duUHJvcGVydHkocHJvcCkpIHsgICAgICAgIFxuICAgICAgICBpZihyZXF1aXJlZCAmJiByZXF1aXJlZEtleXNbcHJvcF0pIHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBgUHJvcGVydHkgXCIke3Byb3B9XCIgaXMgcmVxdWlyZWQgaW4gJHtnZXRIdW1hbkRhdGEoKX0gZm9yICR7Z2V0SHVtYW5TY2hlbWEoKX1gO1xuICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuV29ya0Vycm9yKG1zZywgJ0VSUl9TVE9SQUNMRV9WQUxJREFURV9TQ0hFTUFfUkVRVUlSRURfUFJPUFMnKTsgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52YWxpZGF0ZVNjaGVtYShwcm9wc1twcm9wXSwgZGF0YVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgaWYoIXNjaGVtYS5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCB2YWxpZDtcblxuICBpZih0eXBlb2Ygc2NoZW1hLnZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICB2YWxpZCA9IHNjaGVtYS52YWx1ZShkYXRhKTtcbiAgfVxuICBlbHNlIGlmKHNjaGVtYS52YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHZhbGlkID0gU3RyaW5nKGRhdGEpLm1hdGNoKHNjaGVtYS52YWx1ZSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgY29uc3QgdmFsdWUgPSBBcnJheS5pc0FycmF5KHNjaGVtYS52YWx1ZSk/IHNjaGVtYS52YWx1ZTogW3NjaGVtYS52YWx1ZV07XG4gICAgdmFsaWQgPSB2YWx1ZS5pbmRleE9mKGRhdGEpICE9IC0xO1xuICB9ICBcblxuICBpZighdmFsaWQpIHtcbiAgICBjb25zdCBtc2cgPSBgVmFsaWRhdGlvbiBpcyBmYWlsZWQgZm9yICR7Z2V0SHVtYW5EYXRhKCl9YDtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLldvcmtFcnJvcihtc2csICdFUlJfU1RPUkFDTEVfVkFMSURBVEVfU0NIRU1BX1ZBTFVFJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpdCBpcyB0aGUgYnJvd3NlciBlbnZpcm9ubWVudCBoZXJlXG4gKiBcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG51dGlscy5pc0Jyb3dzZXJFbnYgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIEdldCBhIHJhbmRvbSBlbGVtZW50IGZyb20gdGhlIGFycmF5XG4gKiBcbiAqIEBwYXJhbSB7YXJyYXl9IGFyclxuICogQHJldHVybnMgeyp9XG4gKi9cbnV0aWxzLmdldFJhbmRvbUVsZW1lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBhcnJbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyLmxlbmd0aCldO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBzdHJpbmcgdG8gbWlsbGlzZWNvbmRzXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IHZhbFxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbnV0aWxzLmdldE1zID0gZnVuY3Rpb24gKHZhbCkge1xuICBpZih0eXBlb2YgdmFsICE9ICdzdHJpbmcnIHx8IHZhbCA9PSAnYXV0bycpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgcmV0dXJuIG1zKHZhbCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIHN0cmluZyB0byBieXRlc1xuICogXG4gKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSB2YWxcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfHN0cmluZ31cbiAqL1xudXRpbHMuZ2V0Qnl0ZXMgPSBmdW5jdGlvbiAodmFsKSB7XG4gIGlmKHR5cGVvZiB2YWwgIT0gJ3N0cmluZycgfHwgdmFsLm1hdGNoKCclJykgfHwgdmFsID09ICdhdXRvJykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZXR1cm4gYnl0ZXModmFsKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjcHUgdXNhZ2UgcGVyY2VudFxuICogXG4gKiBAYXN5bmNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7ZmxvYXR9XG4gKi9cbnV0aWxzLmdldENwdVVzYWdlID0gYXN5bmMgZnVuY3Rpb24ob3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgc3RhcnRVc2FnZSA9IHByb2Nlc3MuY3B1VXNhZ2UoKTtcbiAgICBjb25zdCBzdGFydFRpbWUgID0gcHJvY2Vzcy5ocnRpbWUoKTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4geyAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBpbmZvID0gcHJvY2Vzcy5jcHVVc2FnZShzdGFydFVzYWdlKTtcbiAgICAgICAgY29uc3QgZWxhcFRpbWUgPSBwcm9jZXNzLmhydGltZShzdGFydFRpbWUpO1xuICAgICAgICBjb25zdCBlbGFwVGltZVVzID0gZWxhcFRpbWVbMF0gKiAxMDAwMDAwICsgZWxhcFRpbWVbMV0gLyAxMDAwO1xuICAgICAgICBjb25zdCBjcHVQZXJjZW50ID0gMTAwICogKGluZm8udXNlciArIGluZm8uc3lzdGVtKSAvIGVsYXBUaW1lVXM7XG4gICAgICAgIHJlc29sdmUoY3B1UGVyY2VudCk7XG4gICAgICB9XG4gICAgICBjYXRjaChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSwgb3B0aW9ucy50aW1lb3V0IHx8IDEwMDApO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdGhlIHBvcnQgaXMgdXNlZFxuICogXG4gKiBAYXN5bmNcbiAqIEBwYXJhbSB7aW50ZWdlcn0gcG9ydFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnV0aWxzLmlzUG9ydFVzZWQgPSBhc3luYyBmdW5jdGlvbiAocG9ydCkge1xuICByZXR1cm4gYXdhaXQgdGNwUG9ydFVzZWQuY2hlY2soK3BvcnQsICdsb2NhbGhvc3QnKTtcbn07XG5cbi8qKlxuICogR2V0IGFuIGlwIGFkZHJlc3Mgb2YgdGhlIGhvc3RuYW1lXG4gKiBcbiAqIEBhc3luY1xuICogQHBhcmFtIHtzdHJpbmd9IGhvc3RuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG51dGlscy5nZXRIb3N0SXAgPSBhc3luYyBmdW5jdGlvbiAoaG9zdG5hbWUpIHtcbiAgaWYoaG9zdG5hbWUgPT0gJ2xvY2FsaG9zdCcpIHtcbiAgICByZXR1cm4gJzEyNy4wLjAuMSc7XG4gIH1cblxuICBpZih0aGlzLmlzVmFsaWRJcChob3N0bmFtZSkpIHtcbiAgICByZXR1cm4gaG9zdG5hbWU7XG4gIH1cblxuICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxvb2t1cChob3N0bmFtZSwgKGVyciwgaXApID0+IHsgICAgICBcbiAgICAgIGlmKGVycikge1xuICAgICAgICBpZihlcnIuY29kZSA9PSAnRU5PVEZPVU5EJykge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNvbHZlKGlwKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYWRkcmVzcyBpcFxuICogXG4gKiBAc2VlIHV0aWxzLmdldEhvc3RJcFxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAqL1xudXRpbHMuZ2V0QWRkcmVzc0lwID0gYXN5bmMgZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0SG9zdElwKHRoaXMuc3BsaXRBZGRyZXNzKGFkZHJlc3MpWzBdKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByZXF1ZXN0cyB0aW1lclxuICogXG4gKiBAYXN5bmNcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IFxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gXG4gKi9cbnV0aWxzLmdldFJlcXVlc3RUaW1lciA9IGZ1bmN0aW9uICh0aW1lb3V0LCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGxhc3QgPSBEYXRlLm5vdygpOyBcblxuICByZXR1cm4gZml4QXJyID0+IHtcbiAgICBpZih0aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIHRpbWVvdXQgLT0gbm93IC0gbGFzdDtcbiAgICBsYXN0ID0gbm93O1xuXG4gICAgaWYoZml4QXJyICYmICFBcnJheS5pc0FycmF5KGZpeEFycikpIHtcbiAgICAgIGZpeEFyciA9IFtmaXhBcnJdO1xuICAgIH1cblxuICAgIGlmKGZpeEFycikgeyAgICAgIFxuICAgICAgbGV0IGRldiA9IGZpeEFyci5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKSAvIHRpbWVvdXQ7ICBcbiAgICAgIGxldCByZXMgPSBkZXYgPiAxPyAoZml4QXJyWzBdIC8gZGV2KTogZml4QXJyWzBdO1xuICAgICAgbGV0IG1pbiA9IG9wdGlvbnMubWluID4gdGltZW91dD8gdGltZW91dDogb3B0aW9ucy5taW5cbiAgICAgIG1pbiAmJiByZXMgPCBtaW4gJiYgKHJlcyA9IG1pbik7XG4gICAgICByZXR1cm4gcmVzID4gMD8gcmVzOiAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aW1lb3V0O1xuICB9O1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNsaWVudCByZW1vdGUgaXAgYWRkcmVzc1xuICogXG4gKiBAcGFyYW0ge2h0dHAuQ2xpZW50UmVxdWVzdH0gcmVxIFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xudXRpbHMuZ2V0UmVtb3RlSXAgPSBmdW5jdGlvbiAocmVxKSB7XG4gIGxldCBpcCA9IChyZXEuaGVhZGVyc1sneC1mb3J3YXJkZWQtZm9yJ10gfHwgcmVxLmNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzcyB8fCAnJykuc3BsaXQoJywnKVswXS50cmltKCk7XG5cbiAgaWYoaXAubWF0Y2goJzonKSkge1xuICAgIGlwID0gaXAucmVwbGFjZSgnOjoxJywgJzEyNy4wLjAuMScpO1xuICAgIGlwLm1hdGNoKCcuJykgJiYgKGlwID0gaXAucmVwbGFjZSgvXjo6ZmZmZjovLCAnJykpO1xuICAgIHRoaXMuaXNJcHY2KGlwKSAmJiAoaXAgPSB0aGlzLmdldEZ1bGxJcHY2KGlwKSk7XG4gIH1cblxuICByZXR1cm4gaXA7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaXAgYWRkcmVzcyAodjYpIGluIHRoZSBmdWxsIGZvcm1hdFxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gaXBcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbnV0aWxzLmdldEZ1bGxJcHY2ID0gZnVuY3Rpb24gKGlwKSB7XG4gIHJldHVybiBpcDZhZGRyLnBhcnNlKGlwKS50b1N0cmluZyh7IGZvcm1hdDogJ3Y2JywgemVyb0VsaWRlOiBmYWxzZSwgemVyb1BhZDogdHJ1ZSB9KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdGhlIGlwIGFkZHJlc3MgaXMgdjZcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IGlwXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xudXRpbHMuaXNJcHY2ID0gZnVuY3Rpb24gKGlwKSB7XG4gIHJldHVybiAhISh0eXBlb2YgaXAgPT0gJ3N0cmluZycgJiYgaXAubWF0Y2goJzonKSAmJiB2YWxpZGF0ZUlQKGlwKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgaXB2NCB0byBpcHY2IGZvcm1hdFxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gaXBcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbnV0aWxzLmlwdjRUb3Y2ID0gZnVuY3Rpb24gKGlwKSB7XG4gIHJldHVybiB0aGlzLmdldEZ1bGxJcHY2KCc6OmZmZmY6JyArIGlwKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdGhlIHR3byBpcCBhZGRyZXNzZXMgYXJlIGVxdWFsXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBhXG4gKiBAcGFyYW0ge3N0cmluZ30gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnV0aWxzLmlzSXBFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBpcDZhZGRyLmNvbXBhcmUoaXA2YWRkci5wYXJzZShhKSwgaXA2YWRkci5wYXJzZShiKSkgPT0gMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFkZHJlc3MgZnJvbSB0aGUgaG9zdG5hbWUgYW5kIHBvcnRcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IGhvc3RuYW1lXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHBvcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbnV0aWxzLmNyZWF0ZUFkZHJlc3MgPSBmdW5jdGlvbiAoaG9zdG5hbWUsIHBvcnQpIHtcbiAgaWYodGhpcy5pc0lwdjYoaG9zdG5hbWUpKSB7XG4gICAgcmV0dXJuIGBbJHt0aGlzLmdldEZ1bGxJcHY2KGhvc3RuYW1lKX1dOiR7cG9ydH1gO1xuICB9XG5cbiAgcmV0dXJuIGAke2hvc3RuYW1lfToke3BvcnR9YDtcbn07XG5cbi8qKlxuICogQ2hlY2sgdGhlIHBvcnQgaXMgdmFsaWRcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IHBvcnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG51dGlscy5pc1ZhbGlkUG9ydCA9IGZ1bmN0aW9uIChwb3J0KSB7XG4gIHJldHVybiArcG9ydCA+IDAgJiYgK3BvcnQgPD0gNjU1MzU7XG59O1xuXG4vKipcbiAqIENoZWNrIHRoZSBpcCBhZGRyZXNzIGlzIHZhbGlkXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBpcFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnV0aWxzLmlzVmFsaWRJcCA9IGZ1bmN0aW9uIChpcCkge1xuICByZXR1cm4gdmFsaWRhdGVJUChpcCk7XG59O1xuXG4vKipcbiAqIENoZWNrIHRoZSBob3N0bmFtZSBpcyB2YWxpZFxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gaG9zdG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG51dGlscy5pc1ZhbGlkSG9zdG5hbWUgPSBmdW5jdGlvbiAoaG9zdG5hbWUpIHtcbiAgaWYodHlwZW9mIGhvc3RuYW1lICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIFxuICByZXR1cm4gdGhpcy5ob3N0VmFsaWRhdGlvblJlZ2V4LnRlc3QoaG9zdG5hbWUpIHx8IHRoaXMuaXNWYWxpZElwKGhvc3RuYW1lKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdGhlIGFkZHJlc3MgaXMgdmFsaWRcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBhZGRyZXNzIGFzIFwiaXA6cG9ydFwiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xudXRpbHMuaXNWYWxpZEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICBpZighYWRkcmVzcyB8fCB0eXBlb2YgYWRkcmVzcyAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHBhcnRzID0gdGhpcy5zcGxpdEFkZHJlc3MoYWRkcmVzcyk7XG4gIGNvbnN0IGhvc3QgPSBwYXJ0c1swXTtcbiAgY29uc3QgcG9ydCA9IHBhcnRzWzFdO1xuICByZXR1cm4gdGhpcy5pc1ZhbGlkSG9zdG5hbWUoaG9zdCkgJiYgdGhpcy5pc1ZhbGlkUG9ydChwb3J0KTtcbn07XG5cbi8qKlxuICogU3BsaXQgdGhlIGFkZHJlc3MgdG8gYSBob3N0bmFtZSBhbmQgcG9ydFxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybnMge3N0cmluZ1tdfVxuICovXG51dGlscy5zcGxpdEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICBsZXQgc3A7XG5cbiAgaWYoIWFkZHJlc3MgfHwgdHlwZW9mIGFkZHJlc3MgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZihhZGRyZXNzLm1hdGNoKCddJykpIHtcbiAgICBzcCA9IGFkZHJlc3Muc3BsaXQoJ106Jyk7XG4gICAgcmV0dXJuIFt0aGlzLmdldEZ1bGxJcHY2KHNwWzBdLnNsaWNlKDEpKSwgK3NwWzFdXTtcbiAgfVxuXG4gIHNwID0gYWRkcmVzcy5zcGxpdCgnOicpO1xuICByZXR1cm4gW3NwWzBdLCArc3BbMV1dO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZXF1ZXN0IHRpbWVvdXQgZXJyb3JcbiAqIFxuICogQHJldHVybnMge0Vycm9yfVxuICovXG51dGlscy5jcmVhdGVSZXF1ZXN0VGltZW91dEVycm9yID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ1JlcXVlc3QgdGltZWQgb3V0Jyk7XG4gIGVyci5jb2RlID0gJ0VSUl9TUFJFQURBQkxFX1JFUVVFU1RfVElNRURPVVQnO1xuICByZXR1cm4gZXJyO1xufTtcblxuLyoqXG4gKiBDaGVjayB0aGUgZXJyb3IgaXMgdGhlIHJlcXVlc3QgdGltZW91dCBlcnJvclxuICogXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG51dGlscy5pc1JlcXVlc3RUaW1lb3V0RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHJldHVybiAoWydFU09DS0VUVElNRURPVVQnLCAnRVRJTUVET1VUJ10uaW5kZXhPZihlcnIuY29kZSkgIT0gLTEpIHx8IGVyci50eXBlID09ICdyZXF1ZXN0LXRpbWVvdXQnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsczsiLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iXSwic291cmNlUm9vdCI6IiJ9